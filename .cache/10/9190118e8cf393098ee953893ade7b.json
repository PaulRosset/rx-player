{"id":"../../../manifest/representation_index/types.ts","dependencies":[{"name":"/home/prosset/Documents/Canal+/rx-player/tsconfig.json","includedInParent":true,"mtime":1567699906905},{"name":"/home/prosset/Documents/Canal+/rx-player/package.json","includedInParent":true,"mtime":1571390912278}],"generated":{"js":"\"use strict\";\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});"},"sourceMaps":{"js":{"mappings":[{"source":"../../../manifest/representation_index/types.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":2,"column":0}}],"sources":{"../../../manifest/representation_index/types.ts":"/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ICustomError } from \"../../errors\";\nimport Manifest, {\n  Adaptation,\n  Period,\n  Representation,\n} from \"../../manifest\";\nimport {\n  ILocalManifestInitSegmentLoader,\n  ILocalManifestSegmentLoader,\n} from \"../../parsers/manifest/local\";\n\n// privateInfos specific to Smooth Initialization Segments\nexport interface ISmoothInitSegmentPrivateInfos { codecPrivateData? : string;\n                                                  bitsPerSample? : number;\n                                                  channels? : number;\n                                                  packetSize? : number;\n                                                  samplingRate? : number;\n                                                  protection? : {\n                                                    keyId : Uint8Array;\n                                                    keySystems : Array<{\n                                                      systemId : string;\n                                                      privateData : Uint8Array;\n                                                    }>;\n                                                  }; }\n\nexport interface IBaseContentInfos { manifest: Manifest;\n                                     period: Period;\n                                     adaptation: Adaptation;\n                                     representation: Representation; }\n\nexport interface IMetaPlaylistPrivateInfos { transportType : string;\n                                             baseContent : IBaseContentInfos;\n                                             contentStart : number;\n                                             contentEnd? : number; }\n\n// privateInfos specific to local Manifest's init segments\nexport interface ILocalManifestInitSegmentPrivateInfos {\n  load : ILocalManifestInitSegmentLoader;\n}\n\n// privateInfos specific to local Manifests\nexport interface ILocalManifestSegmentPrivateInfos {\n  load : ILocalManifestSegmentLoader;\n  segment : { time : number; duration : number; timescale : number };\n}\n\nexport interface IPrivateInfos {\n  smoothInit? : ISmoothInitSegmentPrivateInfos;\n  metaplaylistInfos? : IMetaPlaylistPrivateInfos;\n  localManifestInitSegment? : ILocalManifestInitSegmentPrivateInfos;\n  localManifestSegment? : ILocalManifestSegmentPrivateInfos;\n}\n\n// ISegment Object.\n// Represent a single Segment from a Representation.\nexport interface ISegment {\n  duration : number; // Estimated duration of the segment, in timescale\n  id : string; // ID of the Segment. Should be unique for this Representation\n  isInit : boolean; // If true, this Segment contains initialization data\n  mediaURL : string|null; // URL of the segment\n  time : number; // Estimated time of beginning for the segment, in timescale\n  timescale : number; // Timescale to convert time and duration into seconds\n\n  indexRange? : [number, number]; // If set, the corresponding byte-range in the\n                                  // downloaded Segment will contain an index\n                                  // describing other Segments\n                                  // TODO put in privateInfos?\n  number? : number; // Optional number of the Segment\n                    // TODO put in privateInfos?\n  privateInfos? : IPrivateInfos; // Allows a RepresentationIndex to store\n                                 // supplementary information in a given\n                                 // Segment for later downloading/parsing\n  range? : [number, number]; // Optional byte range to retrieve the Segment\n  timestampOffset? : number; // Estimated time, in seconds, at which the\n                             // concerned segment will be offseted when\n                             // decoded.\n}\n\nexport interface IRepresentationIndexSegmentInfos { duration : number;\n                                                    time : number;\n                                                    timescale : number; }\n\n// Interface that should be implemented by any Representation's index\nexport default interface IRepresentationIndex {\n  /**\n   * Returns Segment object allowing to do the Init Segment request.\n   * @returns {Object}\n   */\n  getInitSegment() : ISegment|null;\n\n  /**\n   * Returns an array of Segments needed for the amount of time given.\n   * @param {number} up\n   * @param {number} duration\n   * @returns {Array.<Object>}\n   */\n  getSegments(up : number, duration : number) : ISegment[];\n\n  /**\n   * Returns true if, from the given situation, the manifest has to be refreshed\n   * @param {number} up - Beginning timestamp of what you want\n   * @param {number} to - End timestamp of what you want\n   * @returns {Boolean}\n   */\n  shouldRefresh(up : number, to : number) : boolean;\n\n  /**\n   * Returns the starting time, in seconds, of the earliest segment currently\n   * available.\n   * Returns null if nothing is in the index\n   * Returns undefined if we cannot know this value.\n   * @returns {Number|null}\n   */\n  getFirstPosition() : number | null | undefined;\n\n  /**\n   * Returns the ending time, in seconds, of the last segment currently\n   * available.\n   * Returns null if nothing is in the index\n   * Returns undefined if we cannot know this value.\n   * @returns {Number|null|undefined}\n   */\n  getLastPosition() : number | null | undefined;\n\n  /**\n   * Returns true if a Segment returned by this index is still considered\n   * available.\n   * Returns false if it is not available anymore.\n   * Returns undefined if we cannot know whether it is still available or not.\n   * @param {Object} segment\n   * @returns {Boolean|undefined}\n   */\n  isSegmentStillAvailable(segment : ISegment) : boolean | undefined;\n\n  /**\n   * Returns true if the Error given can indicate that the local index became\n   * \"unsynchronized\" with the server.\n   * Some transport cannot become unsynchronized and can return false directly.\n   * Note: This API assumes that the user first checked that the segment is\n   * still available through `isSegmentStillAvailable`.\n   * @returns {Boolean}\n   */\n  canBeOutOfSyncError(error : ICustomError) : boolean;\n\n  /**\n   * Checks if the given time - in seconds - is in a discontinuity. That is:\n   *   - We're on the upper bound of the current range (end of the range - time\n   *     is inferior to the timescale)\n   *   - The next range starts after the end of the current range.\n   * @param {Number} _time\n   * @returns {Number} - If a discontinuity is present, this is the Starting\n   * time for the next (discontinuited) range. If not this is equal to -1.\n   */\n  checkDiscontinuity(time : number) : number;\n\n  /**\n   * Returns true if the last segments in this index have already been generated\n   * so that we can freely go to the next period.\n   * @returns {boolean}\n   */\n  isFinished() : boolean;\n\n  /**\n   * Update the index with another one, such as after a Manifest update.\n   * TODO Both this and _addSegments mutate the index. They should not be\n   * accessible like that.\n   * Think of another implementation?\n   * @param {Object} newIndex\n   */\n  _update(newIndex : IRepresentationIndex) : void;\n\n  /**\n   * Add new segments to the index, obtained through various other different\n   * ways.\n   * TODO Both this and _update mutate the index. They should not be accessible\n   * like that.\n   * Think of another implementation?\n   * @param {Array.<Object>} nextSegments\n   * @param {Object} currentSegment\n   */\n  _addSegments(\n    nextSegments : Array<{ time : number;\n                           duration : number;\n                           timescale : number;\n                           count? : number;\n                           range? : [number, number]; }>,\n    currentSegment? : { duration? : number;\n                        time : number;\n                        timescale? : number; }\n  ) : void;\n}\n"},"lineCount":null}},"error":null,"hash":"b10b09e87397fe727f50569e8f8cd823","cacheData":{"env":{}}}