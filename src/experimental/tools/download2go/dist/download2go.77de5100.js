// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"../../../../node_modules/core-js/modules/_global.js":[function(require,module,exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],"../../../../node_modules/core-js/modules/_core.js":[function(require,module,exports) {
var core = module.exports = { version: '2.6.9' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],"../../../../node_modules/core-js/modules/_is-object.js":[function(require,module,exports) {
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],"../../../../node_modules/core-js/modules/_an-object.js":[function(require,module,exports) {
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js"}],"../../../../node_modules/core-js/modules/_fails.js":[function(require,module,exports) {
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],"../../../../node_modules/core-js/modules/_descriptors.js":[function(require,module,exports) {
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/_dom-create.js":[function(require,module,exports) {
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_global":"../../../../node_modules/core-js/modules/_global.js"}],"../../../../node_modules/core-js/modules/_ie8-dom-define.js":[function(require,module,exports) {
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_dom-create":"../../../../node_modules/core-js/modules/_dom-create.js"}],"../../../../node_modules/core-js/modules/_to-primitive.js":[function(require,module,exports) {
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js"}],"../../../../node_modules/core-js/modules/_object-dp.js":[function(require,module,exports) {
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_ie8-dom-define":"../../../../node_modules/core-js/modules/_ie8-dom-define.js","./_to-primitive":"../../../../node_modules/core-js/modules/_to-primitive.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js"}],"../../../../node_modules/core-js/modules/_property-desc.js":[function(require,module,exports) {
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],"../../../../node_modules/core-js/modules/_hide.js":[function(require,module,exports) {
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_property-desc":"../../../../node_modules/core-js/modules/_property-desc.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js"}],"../../../../node_modules/core-js/modules/_has.js":[function(require,module,exports) {
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],"../../../../node_modules/core-js/modules/_uid.js":[function(require,module,exports) {
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],"../../../../node_modules/core-js/modules/_library.js":[function(require,module,exports) {
module.exports = false;

},{}],"../../../../node_modules/core-js/modules/_shared.js":[function(require,module,exports) {

var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":"../../../../node_modules/core-js/modules/_core.js","./_global":"../../../../node_modules/core-js/modules/_global.js","./_library":"../../../../node_modules/core-js/modules/_library.js"}],"../../../../node_modules/core-js/modules/_function-to-string.js":[function(require,module,exports) {
module.exports = require('./_shared')('native-function-to-string', Function.toString);

},{"./_shared":"../../../../node_modules/core-js/modules/_shared.js"}],"../../../../node_modules/core-js/modules/_redefine.js":[function(require,module,exports) {

var global = require('./_global');
var hide = require('./_hide');
var has = require('./_has');
var SRC = require('./_uid')('src');
var $toString = require('./_function-to-string');
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_has":"../../../../node_modules/core-js/modules/_has.js","./_uid":"../../../../node_modules/core-js/modules/_uid.js","./_function-to-string":"../../../../node_modules/core-js/modules/_function-to-string.js","./_core":"../../../../node_modules/core-js/modules/_core.js"}],"../../../../node_modules/core-js/modules/_a-function.js":[function(require,module,exports) {
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],"../../../../node_modules/core-js/modules/_ctx.js":[function(require,module,exports) {
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":"../../../../node_modules/core-js/modules/_a-function.js"}],"../../../../node_modules/core-js/modules/_export.js":[function(require,module,exports) {

var global = require('./_global');
var core = require('./_core');
var hide = require('./_hide');
var redefine = require('./_redefine');
var ctx = require('./_ctx');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_core":"../../../../node_modules/core-js/modules/_core.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js","./_ctx":"../../../../node_modules/core-js/modules/_ctx.js"}],"../../../../node_modules/core-js/modules/_defined.js":[function(require,module,exports) {
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],"../../../../node_modules/core-js/modules/_to-object.js":[function(require,module,exports) {
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":"../../../../node_modules/core-js/modules/_defined.js"}],"../../../../node_modules/core-js/modules/_to-integer.js":[function(require,module,exports) {
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],"../../../../node_modules/core-js/modules/_to-absolute-index.js":[function(require,module,exports) {
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":"../../../../node_modules/core-js/modules/_to-integer.js"}],"../../../../node_modules/core-js/modules/_to-length.js":[function(require,module,exports) {
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":"../../../../node_modules/core-js/modules/_to-integer.js"}],"../../../../node_modules/core-js/modules/_array-copy-within.js":[function(require,module,exports) {
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

},{"./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_to-absolute-index":"../../../../node_modules/core-js/modules/_to-absolute-index.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js"}],"../../../../node_modules/core-js/modules/_wks.js":[function(require,module,exports) {
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_shared":"../../../../node_modules/core-js/modules/_shared.js","./_uid":"../../../../node_modules/core-js/modules/_uid.js","./_global":"../../../../node_modules/core-js/modules/_global.js"}],"../../../../node_modules/core-js/modules/_add-to-unscopables.js":[function(require,module,exports) {
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_wks":"../../../../node_modules/core-js/modules/_wks.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js"}],"../../../../node_modules/core-js/modules/es6.array.copy-within.js":[function(require,module,exports) {
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { copyWithin: require('./_array-copy-within') });

require('./_add-to-unscopables')('copyWithin');

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_array-copy-within":"../../../../node_modules/core-js/modules/_array-copy-within.js","./_add-to-unscopables":"../../../../node_modules/core-js/modules/_add-to-unscopables.js"}],"../../../../node_modules/core-js/modules/_array-fill.js":[function(require,module,exports) {
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_to-absolute-index":"../../../../node_modules/core-js/modules/_to-absolute-index.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js"}],"../../../../node_modules/core-js/modules/es6.array.fill.js":[function(require,module,exports) {
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { fill: require('./_array-fill') });

require('./_add-to-unscopables')('fill');

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_array-fill":"../../../../node_modules/core-js/modules/_array-fill.js","./_add-to-unscopables":"../../../../node_modules/core-js/modules/_add-to-unscopables.js"}],"../../../../node_modules/core-js/modules/_cof.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],"../../../../node_modules/core-js/modules/_iobject.js":[function(require,module,exports) {
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":"../../../../node_modules/core-js/modules/_cof.js"}],"../../../../node_modules/core-js/modules/_is-array.js":[function(require,module,exports) {
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":"../../../../node_modules/core-js/modules/_cof.js"}],"../../../../node_modules/core-js/modules/_array-species-constructor.js":[function(require,module,exports) {
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_is-array":"../../../../node_modules/core-js/modules/_is-array.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/_array-species-create.js":[function(require,module,exports) {
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":"../../../../node_modules/core-js/modules/_array-species-constructor.js"}],"../../../../node_modules/core-js/modules/_array-methods.js":[function(require,module,exports) {
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_ctx":"../../../../node_modules/core-js/modules/_ctx.js","./_iobject":"../../../../node_modules/core-js/modules/_iobject.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_array-species-create":"../../../../node_modules/core-js/modules/_array-species-create.js"}],"../../../../node_modules/core-js/modules/es6.array.find.js":[function(require,module,exports) {
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_array-methods":"../../../../node_modules/core-js/modules/_array-methods.js","./_add-to-unscopables":"../../../../node_modules/core-js/modules/_add-to-unscopables.js"}],"../../../../node_modules/core-js/modules/es6.array.find-index.js":[function(require,module,exports) {
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_array-methods":"../../../../node_modules/core-js/modules/_array-methods.js","./_add-to-unscopables":"../../../../node_modules/core-js/modules/_add-to-unscopables.js"}],"../../../../node_modules/core-js/modules/_iter-call.js":[function(require,module,exports) {
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/_iterators.js":[function(require,module,exports) {
module.exports = {};

},{}],"../../../../node_modules/core-js/modules/_is-array-iter.js":[function(require,module,exports) {
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":"../../../../node_modules/core-js/modules/_iterators.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/_create-property.js":[function(require,module,exports) {
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_property-desc":"../../../../node_modules/core-js/modules/_property-desc.js"}],"../../../../node_modules/core-js/modules/_classof.js":[function(require,module,exports) {
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":"../../../../node_modules/core-js/modules/_cof.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/core.get-iterator-method.js":[function(require,module,exports) {
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":"../../../../node_modules/core-js/modules/_classof.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js","./_iterators":"../../../../node_modules/core-js/modules/_iterators.js","./_core":"../../../../node_modules/core-js/modules/_core.js"}],"../../../../node_modules/core-js/modules/_iter-detect.js":[function(require,module,exports) {
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/es6.array.from.js":[function(require,module,exports) {
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_ctx":"../../../../node_modules/core-js/modules/_ctx.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_iter-call":"../../../../node_modules/core-js/modules/_iter-call.js","./_is-array-iter":"../../../../node_modules/core-js/modules/_is-array-iter.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_create-property":"../../../../node_modules/core-js/modules/_create-property.js","./core.get-iterator-method":"../../../../node_modules/core-js/modules/core.get-iterator-method.js","./_iter-detect":"../../../../node_modules/core-js/modules/_iter-detect.js"}],"../../../../node_modules/core-js/modules/_to-iobject.js":[function(require,module,exports) {
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_iobject":"../../../../node_modules/core-js/modules/_iobject.js","./_defined":"../../../../node_modules/core-js/modules/_defined.js"}],"../../../../node_modules/core-js/modules/_array-includes.js":[function(require,module,exports) {
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_to-absolute-index":"../../../../node_modules/core-js/modules/_to-absolute-index.js"}],"../../../../node_modules/core-js/modules/es7.array.includes.js":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export = require('./_export');
var $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_array-includes":"../../../../node_modules/core-js/modules/_array-includes.js","./_add-to-unscopables":"../../../../node_modules/core-js/modules/_add-to-unscopables.js"}],"../../../../node_modules/core-js/modules/_iter-step.js":[function(require,module,exports) {
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],"../../../../node_modules/core-js/modules/_shared-key.js":[function(require,module,exports) {
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":"../../../../node_modules/core-js/modules/_shared.js","./_uid":"../../../../node_modules/core-js/modules/_uid.js"}],"../../../../node_modules/core-js/modules/_object-keys-internal.js":[function(require,module,exports) {
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_has":"../../../../node_modules/core-js/modules/_has.js","./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_array-includes":"../../../../node_modules/core-js/modules/_array-includes.js","./_shared-key":"../../../../node_modules/core-js/modules/_shared-key.js"}],"../../../../node_modules/core-js/modules/_enum-bug-keys.js":[function(require,module,exports) {
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],"../../../../node_modules/core-js/modules/_object-keys.js":[function(require,module,exports) {
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_object-keys-internal":"../../../../node_modules/core-js/modules/_object-keys-internal.js","./_enum-bug-keys":"../../../../node_modules/core-js/modules/_enum-bug-keys.js"}],"../../../../node_modules/core-js/modules/_object-dps.js":[function(require,module,exports) {
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_object-keys":"../../../../node_modules/core-js/modules/_object-keys.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js"}],"../../../../node_modules/core-js/modules/_html.js":[function(require,module,exports) {
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":"../../../../node_modules/core-js/modules/_global.js"}],"../../../../node_modules/core-js/modules/_object-create.js":[function(require,module,exports) {
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_object-dps":"../../../../node_modules/core-js/modules/_object-dps.js","./_enum-bug-keys":"../../../../node_modules/core-js/modules/_enum-bug-keys.js","./_shared-key":"../../../../node_modules/core-js/modules/_shared-key.js","./_dom-create":"../../../../node_modules/core-js/modules/_dom-create.js","./_html":"../../../../node_modules/core-js/modules/_html.js"}],"../../../../node_modules/core-js/modules/_set-to-string-tag.js":[function(require,module,exports) {
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_has":"../../../../node_modules/core-js/modules/_has.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/_iter-create.js":[function(require,module,exports) {
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_object-create":"../../../../node_modules/core-js/modules/_object-create.js","./_property-desc":"../../../../node_modules/core-js/modules/_property-desc.js","./_set-to-string-tag":"../../../../node_modules/core-js/modules/_set-to-string-tag.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/_object-gpo.js":[function(require,module,exports) {
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":"../../../../node_modules/core-js/modules/_has.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_shared-key":"../../../../node_modules/core-js/modules/_shared-key.js"}],"../../../../node_modules/core-js/modules/_iter-define.js":[function(require,module,exports) {
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_library":"../../../../node_modules/core-js/modules/_library.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_iterators":"../../../../node_modules/core-js/modules/_iterators.js","./_iter-create":"../../../../node_modules/core-js/modules/_iter-create.js","./_set-to-string-tag":"../../../../node_modules/core-js/modules/_set-to-string-tag.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/es6.array.iterator.js":[function(require,module,exports) {
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":"../../../../node_modules/core-js/modules/_add-to-unscopables.js","./_iter-step":"../../../../node_modules/core-js/modules/_iter-step.js","./_iterators":"../../../../node_modules/core-js/modules/_iterators.js","./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_iter-define":"../../../../node_modules/core-js/modules/_iter-define.js"}],"../../../../node_modules/core-js/modules/es6.array.of.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_create-property":"../../../../node_modules/core-js/modules/_create-property.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/_strict-method.js":[function(require,module,exports) {
'use strict';
var fails = require('./_fails');

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};

},{"./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/es6.array.sort.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var fails = require('./_fails');
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_strict-method":"../../../../node_modules/core-js/modules/_strict-method.js"}],"../../../../node_modules/core-js/modules/_set-species.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/es6.array.species.js":[function(require,module,exports) {
require('./_set-species')('Array');

},{"./_set-species":"../../../../node_modules/core-js/modules/_set-species.js"}],"../../../../node_modules/core-js/modules/es6.date.to-json.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');

$export($export.P + $export.F * require('./_fails')(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_to-primitive":"../../../../node_modules/core-js/modules/_to-primitive.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/_date-to-primitive.js":[function(require,module,exports) {
'use strict';
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

},{"./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_to-primitive":"../../../../node_modules/core-js/modules/_to-primitive.js"}],"../../../../node_modules/core-js/modules/es6.date.to-primitive.js":[function(require,module,exports) {
var TO_PRIMITIVE = require('./_wks')('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));

},{"./_wks":"../../../../node_modules/core-js/modules/_wks.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_date-to-primitive":"../../../../node_modules/core-js/modules/_date-to-primitive.js"}],"../../../../node_modules/core-js/modules/es6.function.has-instance.js":[function(require,module,exports) {
'use strict';
var isObject = require('./_is-object');
var getPrototypeOf = require('./_object-gpo');
var HAS_INSTANCE = require('./_wks')('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) require('./_object-dp').f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js"}],"../../../../node_modules/core-js/modules/es6.function.name.js":[function(require,module,exports) {
var dP = require('./_object-dp').f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

},{"./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js"}],"../../../../node_modules/core-js/modules/_redefine-all.js":[function(require,module,exports) {
var redefine = require('./_redefine');
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

},{"./_redefine":"../../../../node_modules/core-js/modules/_redefine.js"}],"../../../../node_modules/core-js/modules/_an-instance.js":[function(require,module,exports) {
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],"../../../../node_modules/core-js/modules/_for-of.js":[function(require,module,exports) {
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_ctx":"../../../../node_modules/core-js/modules/_ctx.js","./_iter-call":"../../../../node_modules/core-js/modules/_iter-call.js","./_is-array-iter":"../../../../node_modules/core-js/modules/_is-array-iter.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./core.get-iterator-method":"../../../../node_modules/core-js/modules/core.get-iterator-method.js"}],"../../../../node_modules/core-js/modules/_meta.js":[function(require,module,exports) {
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_uid":"../../../../node_modules/core-js/modules/_uid.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_has":"../../../../node_modules/core-js/modules/_has.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/_validate-collection.js":[function(require,module,exports) {
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js"}],"../../../../node_modules/core-js/modules/_collection-strong.js":[function(require,module,exports) {
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_object-create":"../../../../node_modules/core-js/modules/_object-create.js","./_redefine-all":"../../../../node_modules/core-js/modules/_redefine-all.js","./_ctx":"../../../../node_modules/core-js/modules/_ctx.js","./_an-instance":"../../../../node_modules/core-js/modules/_an-instance.js","./_for-of":"../../../../node_modules/core-js/modules/_for-of.js","./_iter-define":"../../../../node_modules/core-js/modules/_iter-define.js","./_iter-step":"../../../../node_modules/core-js/modules/_iter-step.js","./_set-species":"../../../../node_modules/core-js/modules/_set-species.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_meta":"../../../../node_modules/core-js/modules/_meta.js","./_validate-collection":"../../../../node_modules/core-js/modules/_validate-collection.js"}],"../../../../node_modules/core-js/modules/_object-pie.js":[function(require,module,exports) {
exports.f = {}.propertyIsEnumerable;

},{}],"../../../../node_modules/core-js/modules/_object-gopd.js":[function(require,module,exports) {
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_object-pie":"../../../../node_modules/core-js/modules/_object-pie.js","./_property-desc":"../../../../node_modules/core-js/modules/_property-desc.js","./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_to-primitive":"../../../../node_modules/core-js/modules/_to-primitive.js","./_has":"../../../../node_modules/core-js/modules/_has.js","./_ie8-dom-define":"../../../../node_modules/core-js/modules/_ie8-dom-define.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js"}],"../../../../node_modules/core-js/modules/_set-proto.js":[function(require,module,exports) {
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_ctx":"../../../../node_modules/core-js/modules/_ctx.js","./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js"}],"../../../../node_modules/core-js/modules/_inherit-if-required.js":[function(require,module,exports) {
var isObject = require('./_is-object');
var setPrototypeOf = require('./_set-proto').set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_set-proto":"../../../../node_modules/core-js/modules/_set-proto.js"}],"../../../../node_modules/core-js/modules/_collection.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js","./_redefine-all":"../../../../node_modules/core-js/modules/_redefine-all.js","./_meta":"../../../../node_modules/core-js/modules/_meta.js","./_for-of":"../../../../node_modules/core-js/modules/_for-of.js","./_an-instance":"../../../../node_modules/core-js/modules/_an-instance.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_iter-detect":"../../../../node_modules/core-js/modules/_iter-detect.js","./_set-to-string-tag":"../../../../node_modules/core-js/modules/_set-to-string-tag.js","./_inherit-if-required":"../../../../node_modules/core-js/modules/_inherit-if-required.js"}],"../../../../node_modules/core-js/modules/es6.map.js":[function(require,module,exports) {
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection-strong":"../../../../node_modules/core-js/modules/_collection-strong.js","./_validate-collection":"../../../../node_modules/core-js/modules/_validate-collection.js","./_collection":"../../../../node_modules/core-js/modules/_collection.js"}],"../../../../node_modules/core-js/modules/_math-log1p.js":[function(require,module,exports) {
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

},{}],"../../../../node_modules/core-js/modules/es6.math.acosh.js":[function(require,module,exports) {
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export');
var log1p = require('./_math-log1p');
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_math-log1p":"../../../../node_modules/core-js/modules/_math-log1p.js"}],"../../../../node_modules/core-js/modules/es6.math.asinh.js":[function(require,module,exports) {
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export');
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.math.atanh.js":[function(require,module,exports) {
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export');
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/_math-sign.js":[function(require,module,exports) {
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],"../../../../node_modules/core-js/modules/es6.math.cbrt.js":[function(require,module,exports) {
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export');
var sign = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_math-sign":"../../../../node_modules/core-js/modules/_math-sign.js"}],"../../../../node_modules/core-js/modules/es6.math.clz32.js":[function(require,module,exports) {
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.math.cosh.js":[function(require,module,exports) {
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export');
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/_math-expm1.js":[function(require,module,exports) {
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

},{}],"../../../../node_modules/core-js/modules/es6.math.expm1.js":[function(require,module,exports) {
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export');
var $expm1 = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_math-expm1":"../../../../node_modules/core-js/modules/_math-expm1.js"}],"../../../../node_modules/core-js/modules/_math-fround.js":[function(require,module,exports) {
// 20.2.2.16 Math.fround(x)
var sign = require('./_math-sign');
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

},{"./_math-sign":"../../../../node_modules/core-js/modules/_math-sign.js"}],"../../../../node_modules/core-js/modules/es6.math.fround.js":[function(require,module,exports) {
// 20.2.2.16 Math.fround(x)
var $export = require('./_export');

$export($export.S, 'Math', { fround: require('./_math-fround') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_math-fround":"../../../../node_modules/core-js/modules/_math-fround.js"}],"../../../../node_modules/core-js/modules/es6.math.hypot.js":[function(require,module,exports) {
// 20.2.2.17 Math.hypot([value1[, value2[, â¦ ]]])
var $export = require('./_export');
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.math.imul.js":[function(require,module,exports) {
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export');
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/es6.math.log1p.js":[function(require,module,exports) {
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', { log1p: require('./_math-log1p') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_math-log1p":"../../../../node_modules/core-js/modules/_math-log1p.js"}],"../../../../node_modules/core-js/modules/es6.math.log10.js":[function(require,module,exports) {
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.math.log2.js":[function(require,module,exports) {
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.math.sign.js":[function(require,module,exports) {
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', { sign: require('./_math-sign') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_math-sign":"../../../../node_modules/core-js/modules/_math-sign.js"}],"../../../../node_modules/core-js/modules/es6.math.sinh.js":[function(require,module,exports) {
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_math-expm1":"../../../../node_modules/core-js/modules/_math-expm1.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/es6.math.tanh.js":[function(require,module,exports) {
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_math-expm1":"../../../../node_modules/core-js/modules/_math-expm1.js"}],"../../../../node_modules/core-js/modules/es6.math.trunc.js":[function(require,module,exports) {
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/_object-gopn.js":[function(require,module,exports) {
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_object-keys-internal":"../../../../node_modules/core-js/modules/_object-keys-internal.js","./_enum-bug-keys":"../../../../node_modules/core-js/modules/_enum-bug-keys.js"}],"../../../../node_modules/core-js/modules/_string-ws.js":[function(require,module,exports) {
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

},{}],"../../../../node_modules/core-js/modules/_string-trim.js":[function(require,module,exports) {
var $export = require('./_export');
var defined = require('./_defined');
var fails = require('./_fails');
var spaces = require('./_string-ws');
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_defined":"../../../../node_modules/core-js/modules/_defined.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_string-ws":"../../../../node_modules/core-js/modules/_string-ws.js"}],"../../../../node_modules/core-js/modules/es6.number.constructor.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var has = require('./_has');
var cof = require('./_cof');
var inheritIfRequired = require('./_inherit-if-required');
var toPrimitive = require('./_to-primitive');
var fails = require('./_fails');
var gOPN = require('./_object-gopn').f;
var gOPD = require('./_object-gopd').f;
var dP = require('./_object-dp').f;
var $trim = require('./_string-trim').trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(require('./_object-create')(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_has":"../../../../node_modules/core-js/modules/_has.js","./_cof":"../../../../node_modules/core-js/modules/_cof.js","./_inherit-if-required":"../../../../node_modules/core-js/modules/_inherit-if-required.js","./_to-primitive":"../../../../node_modules/core-js/modules/_to-primitive.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_object-gopn":"../../../../node_modules/core-js/modules/_object-gopn.js","./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_string-trim":"../../../../node_modules/core-js/modules/_string-trim.js","./_object-create":"../../../../node_modules/core-js/modules/_object-create.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js"}],"../../../../node_modules/core-js/modules/es6.number.epsilon.js":[function(require,module,exports) {
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.number.is-finite.js":[function(require,module,exports) {
// 20.1.2.2 Number.isFinite(number)
var $export = require('./_export');
var _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_global":"../../../../node_modules/core-js/modules/_global.js"}],"../../../../node_modules/core-js/modules/_is-integer.js":[function(require,module,exports) {
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object');
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js"}],"../../../../node_modules/core-js/modules/es6.number.is-integer.js":[function(require,module,exports) {
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', { isInteger: require('./_is-integer') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_is-integer":"../../../../node_modules/core-js/modules/_is-integer.js"}],"../../../../node_modules/core-js/modules/es6.number.is-nan.js":[function(require,module,exports) {
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.number.is-safe-integer.js":[function(require,module,exports) {
// 20.1.2.5 Number.isSafeInteger(number)
var $export = require('./_export');
var isInteger = require('./_is-integer');
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_is-integer":"../../../../node_modules/core-js/modules/_is-integer.js"}],"../../../../node_modules/core-js/modules/es6.number.max-safe-integer.js":[function(require,module,exports) {
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.number.min-safe-integer.js":[function(require,module,exports) {
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/_parse-float.js":[function(require,module,exports) {
var $parseFloat = require('./_global').parseFloat;
var $trim = require('./_string-trim').trim;

module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_string-trim":"../../../../node_modules/core-js/modules/_string-trim.js","./_string-ws":"../../../../node_modules/core-js/modules/_string-ws.js"}],"../../../../node_modules/core-js/modules/es6.number.parse-float.js":[function(require,module,exports) {
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_parse-float":"../../../../node_modules/core-js/modules/_parse-float.js"}],"../../../../node_modules/core-js/modules/_parse-int.js":[function(require,module,exports) {
var $parseInt = require('./_global').parseInt;
var $trim = require('./_string-trim').trim;
var ws = require('./_string-ws');
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_string-trim":"../../../../node_modules/core-js/modules/_string-trim.js","./_string-ws":"../../../../node_modules/core-js/modules/_string-ws.js"}],"../../../../node_modules/core-js/modules/es6.number.parse-int.js":[function(require,module,exports) {
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_parse-int":"../../../../node_modules/core-js/modules/_parse-int.js"}],"../../../../node_modules/core-js/modules/_object-gops.js":[function(require,module,exports) {
exports.f = Object.getOwnPropertySymbols;

},{}],"../../../../node_modules/core-js/modules/_object-assign.js":[function(require,module,exports) {
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = require('./_descriptors');
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;

},{"./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_object-keys":"../../../../node_modules/core-js/modules/_object-keys.js","./_object-gops":"../../../../node_modules/core-js/modules/_object-gops.js","./_object-pie":"../../../../node_modules/core-js/modules/_object-pie.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_iobject":"../../../../node_modules/core-js/modules/_iobject.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/es6.object.assign.js":[function(require,module,exports) {
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_object-assign":"../../../../node_modules/core-js/modules/_object-assign.js"}],"../../../../node_modules/core-js/modules/_object-forced-pam.js":[function(require,module,exports) {
'use strict';
// Forced replacement prototype accessors methods
module.exports = require('./_library') || !require('./_fails')(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete require('./_global')[K];
});

},{"./_library":"../../../../node_modules/core-js/modules/_library.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_global":"../../../../node_modules/core-js/modules/_global.js"}],"../../../../node_modules/core-js/modules/es7.object.define-getter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_object-forced-pam":"../../../../node_modules/core-js/modules/_object-forced-pam.js"}],"../../../../node_modules/core-js/modules/es7.object.define-setter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_object-forced-pam":"../../../../node_modules/core-js/modules/_object-forced-pam.js"}],"../../../../node_modules/core-js/modules/_object-to-array.js":[function(require,module,exports) {
var DESCRIPTORS = require('./_descriptors');
var getKeys = require('./_object-keys');
var toIObject = require('./_to-iobject');
var isEnum = require('./_object-pie').f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || isEnum.call(O, key)) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

},{"./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_object-keys":"../../../../node_modules/core-js/modules/_object-keys.js","./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_object-pie":"../../../../node_modules/core-js/modules/_object-pie.js"}],"../../../../node_modules/core-js/modules/es7.object.entries.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_object-to-array":"../../../../node_modules/core-js/modules/_object-to-array.js"}],"../../../../node_modules/core-js/modules/_object-sap.js":[function(require,module,exports) {
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_core":"../../../../node_modules/core-js/modules/_core.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/es6.object.freeze.js":[function(require,module,exports) {
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_meta":"../../../../node_modules/core-js/modules/_meta.js","./_object-sap":"../../../../node_modules/core-js/modules/_object-sap.js"}],"../../../../node_modules/core-js/modules/es6.object.get-own-property-descriptor.js":[function(require,module,exports) {
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js","./_object-sap":"../../../../node_modules/core-js/modules/_object-sap.js"}],"../../../../node_modules/core-js/modules/_own-keys.js":[function(require,module,exports) {
// all object keys, includes non-enumerable and symbols
var gOPN = require('./_object-gopn');
var gOPS = require('./_object-gops');
var anObject = require('./_an-object');
var Reflect = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

},{"./_object-gopn":"../../../../node_modules/core-js/modules/_object-gopn.js","./_object-gops":"../../../../node_modules/core-js/modules/_object-gops.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_global":"../../../../node_modules/core-js/modules/_global.js"}],"../../../../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = require('./_export');
var ownKeys = require('./_own-keys');
var toIObject = require('./_to-iobject');
var gOPD = require('./_object-gopd');
var createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_own-keys":"../../../../node_modules/core-js/modules/_own-keys.js","./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js","./_create-property":"../../../../node_modules/core-js/modules/_create-property.js"}],"../../../../node_modules/core-js/modules/_object-gopn-ext.js":[function(require,module,exports) {
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_object-gopn":"../../../../node_modules/core-js/modules/_object-gopn.js"}],"../../../../node_modules/core-js/modules/es6.object.get-own-property-names.js":[function(require,module,exports) {
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function () {
  return require('./_object-gopn-ext').f;
});

},{"./_object-sap":"../../../../node_modules/core-js/modules/_object-sap.js","./_object-gopn-ext":"../../../../node_modules/core-js/modules/_object-gopn-ext.js"}],"../../../../node_modules/core-js/modules/es6.object.get-prototype-of.js":[function(require,module,exports) {
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js","./_object-sap":"../../../../node_modules/core-js/modules/_object-sap.js"}],"../../../../node_modules/core-js/modules/es7.object.lookup-getter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_to-primitive":"../../../../node_modules/core-js/modules/_to-primitive.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js","./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_object-forced-pam":"../../../../node_modules/core-js/modules/_object-forced-pam.js"}],"../../../../node_modules/core-js/modules/es7.object.lookup-setter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_to-primitive":"../../../../node_modules/core-js/modules/_to-primitive.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js","./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_object-forced-pam":"../../../../node_modules/core-js/modules/_object-forced-pam.js"}],"../../../../node_modules/core-js/modules/es6.object.prevent-extensions.js":[function(require,module,exports) {
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_meta":"../../../../node_modules/core-js/modules/_meta.js","./_object-sap":"../../../../node_modules/core-js/modules/_object-sap.js"}],"../../../../node_modules/core-js/modules/_same-value.js":[function(require,module,exports) {
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],"../../../../node_modules/core-js/modules/es6.object.is.js":[function(require,module,exports) {
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', { is: require('./_same-value') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_same-value":"../../../../node_modules/core-js/modules/_same-value.js"}],"../../../../node_modules/core-js/modules/es6.object.is-frozen.js":[function(require,module,exports) {
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_object-sap":"../../../../node_modules/core-js/modules/_object-sap.js"}],"../../../../node_modules/core-js/modules/es6.object.is-sealed.js":[function(require,module,exports) {
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_object-sap":"../../../../node_modules/core-js/modules/_object-sap.js"}],"../../../../node_modules/core-js/modules/es6.object.is-extensible.js":[function(require,module,exports) {
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_object-sap":"../../../../node_modules/core-js/modules/_object-sap.js"}],"../../../../node_modules/core-js/modules/es6.object.keys.js":[function(require,module,exports) {
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_object-keys":"../../../../node_modules/core-js/modules/_object-keys.js","./_object-sap":"../../../../node_modules/core-js/modules/_object-sap.js"}],"../../../../node_modules/core-js/modules/es6.object.seal.js":[function(require,module,exports) {
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_meta":"../../../../node_modules/core-js/modules/_meta.js","./_object-sap":"../../../../node_modules/core-js/modules/_object-sap.js"}],"../../../../node_modules/core-js/modules/es6.object.set-prototype-of.js":[function(require,module,exports) {
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_set-proto":"../../../../node_modules/core-js/modules/_set-proto.js"}],"../../../../node_modules/core-js/modules/es7.object.values.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_object-to-array":"../../../../node_modules/core-js/modules/_object-to-array.js"}],"../../../../node_modules/core-js/modules/_species-constructor.js":[function(require,module,exports) {
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/_invoke.js":[function(require,module,exports) {
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],"../../../../node_modules/core-js/modules/_task.js":[function(require,module,exports) {


var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_ctx":"../../../../node_modules/core-js/modules/_ctx.js","./_invoke":"../../../../node_modules/core-js/modules/_invoke.js","./_html":"../../../../node_modules/core-js/modules/_html.js","./_dom-create":"../../../../node_modules/core-js/modules/_dom-create.js","./_global":"../../../../node_modules/core-js/modules/_global.js","./_cof":"../../../../node_modules/core-js/modules/_cof.js"}],"../../../../node_modules/core-js/modules/_microtask.js":[function(require,module,exports) {


var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_task":"../../../../node_modules/core-js/modules/_task.js","./_cof":"../../../../node_modules/core-js/modules/_cof.js"}],"../../../../node_modules/core-js/modules/_new-promise-capability.js":[function(require,module,exports) {
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":"../../../../node_modules/core-js/modules/_a-function.js"}],"../../../../node_modules/core-js/modules/_perform.js":[function(require,module,exports) {
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],"../../../../node_modules/core-js/modules/_user-agent.js":[function(require,module,exports) {

var global = require('./_global');
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';

},{"./_global":"../../../../node_modules/core-js/modules/_global.js"}],"../../../../node_modules/core-js/modules/_promise-resolve.js":[function(require,module,exports) {
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_new-promise-capability":"../../../../node_modules/core-js/modules/_new-promise-capability.js"}],"../../../../node_modules/core-js/modules/es6.promise.js":[function(require,module,exports) {


'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var userAgent = require('./_user-agent');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_library":"../../../../node_modules/core-js/modules/_library.js","./_global":"../../../../node_modules/core-js/modules/_global.js","./_ctx":"../../../../node_modules/core-js/modules/_ctx.js","./_classof":"../../../../node_modules/core-js/modules/_classof.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_an-instance":"../../../../node_modules/core-js/modules/_an-instance.js","./_for-of":"../../../../node_modules/core-js/modules/_for-of.js","./_species-constructor":"../../../../node_modules/core-js/modules/_species-constructor.js","./_task":"../../../../node_modules/core-js/modules/_task.js","./_microtask":"../../../../node_modules/core-js/modules/_microtask.js","./_new-promise-capability":"../../../../node_modules/core-js/modules/_new-promise-capability.js","./_perform":"../../../../node_modules/core-js/modules/_perform.js","./_user-agent":"../../../../node_modules/core-js/modules/_user-agent.js","./_promise-resolve":"../../../../node_modules/core-js/modules/_promise-resolve.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js","./_redefine-all":"../../../../node_modules/core-js/modules/_redefine-all.js","./_set-to-string-tag":"../../../../node_modules/core-js/modules/_set-to-string-tag.js","./_set-species":"../../../../node_modules/core-js/modules/_set-species.js","./_core":"../../../../node_modules/core-js/modules/_core.js","./_iter-detect":"../../../../node_modules/core-js/modules/_iter-detect.js"}],"../../../../node_modules/core-js/modules/es7.promise.finally.js":[function(require,module,exports) {

// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_core":"../../../../node_modules/core-js/modules/_core.js","./_global":"../../../../node_modules/core-js/modules/_global.js","./_species-constructor":"../../../../node_modules/core-js/modules/_species-constructor.js","./_promise-resolve":"../../../../node_modules/core-js/modules/_promise-resolve.js"}],"../../../../node_modules/core-js/modules/es6.reflect.apply.js":[function(require,module,exports) {
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = require('./_export');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var rApply = (require('./_global').Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_global":"../../../../node_modules/core-js/modules/_global.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/_bind.js":[function(require,module,exports) {
'use strict';
var aFunction = require('./_a-function');
var isObject = require('./_is-object');
var invoke = require('./_invoke');
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

},{"./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_invoke":"../../../../node_modules/core-js/modules/_invoke.js"}],"../../../../node_modules/core-js/modules/es6.reflect.construct.js":[function(require,module,exports) {
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = require('./_export');
var create = require('./_object-create');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var fails = require('./_fails');
var bind = require('./_bind');
var rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_object-create":"../../../../node_modules/core-js/modules/_object-create.js","./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_bind":"../../../../node_modules/core-js/modules/_bind.js","./_global":"../../../../node_modules/core-js/modules/_global.js"}],"../../../../node_modules/core-js/modules/es6.reflect.define-property.js":[function(require,module,exports) {
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = require('./_object-dp');
var $export = require('./_export');
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_to-primitive":"../../../../node_modules/core-js/modules/_to-primitive.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/es6.reflect.delete-property.js":[function(require,module,exports) {
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = require('./_export');
var gOPD = require('./_object-gopd').f;
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/es6.reflect.get.js":[function(require,module,exports) {
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var isObject = require('./_is-object');
var anObject = require('./_an-object');

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });

},{"./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js","./_has":"../../../../node_modules/core-js/modules/_has.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js":[function(require,module,exports) {
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = require('./_object-gopd');
var $export = require('./_export');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

},{"./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/es6.reflect.get-prototype-of.js":[function(require,module,exports) {
// 26.1.8 Reflect.getPrototypeOf(target)
var $export = require('./_export');
var getProto = require('./_object-gpo');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/es6.reflect.has.js":[function(require,module,exports) {
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.reflect.is-extensible.js":[function(require,module,exports) {
// 26.1.10 Reflect.isExtensible(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/es6.reflect.own-keys.js":[function(require,module,exports) {
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', { ownKeys: require('./_own-keys') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_own-keys":"../../../../node_modules/core-js/modules/_own-keys.js"}],"../../../../node_modules/core-js/modules/es6.reflect.prevent-extensions.js":[function(require,module,exports) {
// 26.1.12 Reflect.preventExtensions(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/es6.reflect.set.js":[function(require,module,exports) {
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = require('./_object-dp');
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var createDesc = require('./_property-desc');
var anObject = require('./_an-object');
var isObject = require('./_is-object');

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });

},{"./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js","./_has":"../../../../node_modules/core-js/modules/_has.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_property-desc":"../../../../node_modules/core-js/modules/_property-desc.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js"}],"../../../../node_modules/core-js/modules/es6.reflect.set-prototype-of.js":[function(require,module,exports) {
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = require('./_export');
var setProto = require('./_set-proto');

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_set-proto":"../../../../node_modules/core-js/modules/_set-proto.js"}],"../../../../node_modules/core-js/modules/_is-regexp.js":[function(require,module,exports) {
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object');
var cof = require('./_cof');
var MATCH = require('./_wks')('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_cof":"../../../../node_modules/core-js/modules/_cof.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/_flags.js":[function(require,module,exports) {
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

},{"./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/es6.regexp.constructor.js":[function(require,module,exports) {

var global = require('./_global');
var inheritIfRequired = require('./_inherit-if-required');
var dP = require('./_object-dp').f;
var gOPN = require('./_object-gopn').f;
var isRegExp = require('./_is-regexp');
var $flags = require('./_flags');
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function () {
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_inherit-if-required":"../../../../node_modules/core-js/modules/_inherit-if-required.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_object-gopn":"../../../../node_modules/core-js/modules/_object-gopn.js","./_is-regexp":"../../../../node_modules/core-js/modules/_is-regexp.js","./_flags":"../../../../node_modules/core-js/modules/_flags.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js","./_set-species":"../../../../node_modules/core-js/modules/_set-species.js"}],"../../../../node_modules/core-js/modules/es6.regexp.flags.js":[function(require,module,exports) {
// 21.2.5.3 get RegExp.prototype.flags()
if (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});

},{"./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_flags":"../../../../node_modules/core-js/modules/_flags.js"}],"../../../../node_modules/core-js/modules/_string-at.js":[function(require,module,exports) {
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_to-integer":"../../../../node_modules/core-js/modules/_to-integer.js","./_defined":"../../../../node_modules/core-js/modules/_defined.js"}],"../../../../node_modules/core-js/modules/_advance-string-index.js":[function(require,module,exports) {
'use strict';
var at = require('./_string-at')(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};

},{"./_string-at":"../../../../node_modules/core-js/modules/_string-at.js"}],"../../../../node_modules/core-js/modules/_regexp-exec-abstract.js":[function(require,module,exports) {
'use strict';

var classof = require('./_classof');
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};

},{"./_classof":"../../../../node_modules/core-js/modules/_classof.js"}],"../../../../node_modules/core-js/modules/_regexp-exec.js":[function(require,module,exports) {
'use strict';

var regexpFlags = require('./_flags');

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;

},{"./_flags":"../../../../node_modules/core-js/modules/_flags.js"}],"../../../../node_modules/core-js/modules/es6.regexp.exec.js":[function(require,module,exports) {
'use strict';
var regexpExec = require('./_regexp-exec');
require('./_export')({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});

},{"./_regexp-exec":"../../../../node_modules/core-js/modules/_regexp-exec.js","./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/_fix-re-wks.js":[function(require,module,exports) {
'use strict';
require('./es6.regexp.exec');
var redefine = require('./_redefine');
var hide = require('./_hide');
var fails = require('./_fails');
var defined = require('./_defined');
var wks = require('./_wks');
var regexpExec = require('./_regexp-exec');

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

},{"./es6.regexp.exec":"../../../../node_modules/core-js/modules/es6.regexp.exec.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_defined":"../../../../node_modules/core-js/modules/_defined.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js","./_regexp-exec":"../../../../node_modules/core-js/modules/_regexp-exec.js"}],"../../../../node_modules/core-js/modules/es6.regexp.match.js":[function(require,module,exports) {
'use strict';

var anObject = require('./_an-object');
var toLength = require('./_to-length');
var advanceStringIndex = require('./_advance-string-index');
var regExpExec = require('./_regexp-exec-abstract');

// @@match logic
require('./_fix-re-wks')('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      if (!rx.global) return regExpExec(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});

},{"./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_advance-string-index":"../../../../node_modules/core-js/modules/_advance-string-index.js","./_regexp-exec-abstract":"../../../../node_modules/core-js/modules/_regexp-exec-abstract.js","./_fix-re-wks":"../../../../node_modules/core-js/modules/_fix-re-wks.js"}],"../../../../node_modules/core-js/modules/es6.regexp.replace.js":[function(require,module,exports) {
var global = arguments[3];
'use strict';

var anObject = require('./_an-object');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var advanceStringIndex = require('./_advance-string-index');
var regExpExec = require('./_regexp-exec-abstract');
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
require('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});

},{"./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_to-integer":"../../../../node_modules/core-js/modules/_to-integer.js","./_advance-string-index":"../../../../node_modules/core-js/modules/_advance-string-index.js","./_regexp-exec-abstract":"../../../../node_modules/core-js/modules/_regexp-exec-abstract.js","./_fix-re-wks":"../../../../node_modules/core-js/modules/_fix-re-wks.js"}],"../../../../node_modules/core-js/modules/es6.regexp.split.js":[function(require,module,exports) {
'use strict';

var isRegExp = require('./_is-regexp');
var anObject = require('./_an-object');
var speciesConstructor = require('./_species-constructor');
var advanceStringIndex = require('./_advance-string-index');
var toLength = require('./_to-length');
var callRegExpExec = require('./_regexp-exec-abstract');
var regexpExec = require('./_regexp-exec');
var fails = require('./_fails');
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });

// @@split logic
require('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});

},{"./_is-regexp":"../../../../node_modules/core-js/modules/_is-regexp.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_species-constructor":"../../../../node_modules/core-js/modules/_species-constructor.js","./_advance-string-index":"../../../../node_modules/core-js/modules/_advance-string-index.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_regexp-exec-abstract":"../../../../node_modules/core-js/modules/_regexp-exec-abstract.js","./_regexp-exec":"../../../../node_modules/core-js/modules/_regexp-exec.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_fix-re-wks":"../../../../node_modules/core-js/modules/_fix-re-wks.js"}],"../../../../node_modules/core-js/modules/es6.regexp.search.js":[function(require,module,exports) {
'use strict';

var anObject = require('./_an-object');
var sameValue = require('./_same-value');
var regExpExec = require('./_regexp-exec-abstract');

// @@search logic
require('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative($search, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});

},{"./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_same-value":"../../../../node_modules/core-js/modules/_same-value.js","./_regexp-exec-abstract":"../../../../node_modules/core-js/modules/_regexp-exec-abstract.js","./_fix-re-wks":"../../../../node_modules/core-js/modules/_fix-re-wks.js"}],"../../../../node_modules/core-js/modules/es6.regexp.to-string.js":[function(require,module,exports) {

'use strict';
require('./es6.regexp.flags');
var anObject = require('./_an-object');
var $flags = require('./_flags');
var DESCRIPTORS = require('./_descriptors');
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (require('./_fails')(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

},{"./es6.regexp.flags":"../../../../node_modules/core-js/modules/es6.regexp.flags.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_flags":"../../../../node_modules/core-js/modules/_flags.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/es6.set.js":[function(require,module,exports) {
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection-strong":"../../../../node_modules/core-js/modules/_collection-strong.js","./_validate-collection":"../../../../node_modules/core-js/modules/_validate-collection.js","./_collection":"../../../../node_modules/core-js/modules/_collection.js"}],"../../../../node_modules/core-js/modules/_wks-ext.js":[function(require,module,exports) {
exports.f = require('./_wks');

},{"./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/_wks-define.js":[function(require,module,exports) {

var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_core":"../../../../node_modules/core-js/modules/_core.js","./_library":"../../../../node_modules/core-js/modules/_library.js","./_wks-ext":"../../../../node_modules/core-js/modules/_wks-ext.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js"}],"../../../../node_modules/core-js/modules/_enum-keys.js":[function(require,module,exports) {
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-keys":"../../../../node_modules/core-js/modules/_object-keys.js","./_object-gops":"../../../../node_modules/core-js/modules/_object-gops.js","./_object-pie":"../../../../node_modules/core-js/modules/_object-pie.js"}],"../../../../node_modules/core-js/modules/es6.symbol.js":[function(require,module,exports) {

'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toObject = require('./_to-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $GOPS = require('./_object-gops');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_has":"../../../../node_modules/core-js/modules/_has.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js","./_meta":"../../../../node_modules/core-js/modules/_meta.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_shared":"../../../../node_modules/core-js/modules/_shared.js","./_set-to-string-tag":"../../../../node_modules/core-js/modules/_set-to-string-tag.js","./_uid":"../../../../node_modules/core-js/modules/_uid.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js","./_wks-ext":"../../../../node_modules/core-js/modules/_wks-ext.js","./_wks-define":"../../../../node_modules/core-js/modules/_wks-define.js","./_enum-keys":"../../../../node_modules/core-js/modules/_enum-keys.js","./_is-array":"../../../../node_modules/core-js/modules/_is-array.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_to-primitive":"../../../../node_modules/core-js/modules/_to-primitive.js","./_property-desc":"../../../../node_modules/core-js/modules/_property-desc.js","./_object-create":"../../../../node_modules/core-js/modules/_object-create.js","./_object-gopn-ext":"../../../../node_modules/core-js/modules/_object-gopn-ext.js","./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js","./_object-gops":"../../../../node_modules/core-js/modules/_object-gops.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_object-keys":"../../../../node_modules/core-js/modules/_object-keys.js","./_object-gopn":"../../../../node_modules/core-js/modules/_object-gopn.js","./_object-pie":"../../../../node_modules/core-js/modules/_object-pie.js","./_library":"../../../../node_modules/core-js/modules/_library.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js"}],"../../../../node_modules/core-js/modules/es7.symbol.async-iterator.js":[function(require,module,exports) {
require('./_wks-define')('asyncIterator');

},{"./_wks-define":"../../../../node_modules/core-js/modules/_wks-define.js"}],"../../../../node_modules/core-js/modules/_string-html.js":[function(require,module,exports) {
var $export = require('./_export');
var fails = require('./_fails');
var defined = require('./_defined');
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_defined":"../../../../node_modules/core-js/modules/_defined.js"}],"../../../../node_modules/core-js/modules/es6.string.anchor.js":[function(require,module,exports) {
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.big.js":[function(require,module,exports) {
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.blink.js":[function(require,module,exports) {
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.bold.js":[function(require,module,exports) {
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.code-point-at.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $at = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_string-at":"../../../../node_modules/core-js/modules/_string-at.js"}],"../../../../node_modules/core-js/modules/_string-context.js":[function(require,module,exports) {
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp');
var defined = require('./_defined');

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

},{"./_is-regexp":"../../../../node_modules/core-js/modules/_is-regexp.js","./_defined":"../../../../node_modules/core-js/modules/_defined.js"}],"../../../../node_modules/core-js/modules/_fails-is-regexp.js":[function(require,module,exports) {
var MATCH = require('./_wks')('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};

},{"./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/es6.string.ends-with.js":[function(require,module,exports) {
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_string-context":"../../../../node_modules/core-js/modules/_string-context.js","./_fails-is-regexp":"../../../../node_modules/core-js/modules/_fails-is-regexp.js"}],"../../../../node_modules/core-js/modules/es6.string.fixed.js":[function(require,module,exports) {
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.fontcolor.js":[function(require,module,exports) {
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.fontsize.js":[function(require,module,exports) {
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.from-code-point.js":[function(require,module,exports) {
var $export = require('./_export');
var toAbsoluteIndex = require('./_to-absolute-index');
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-absolute-index":"../../../../node_modules/core-js/modules/_to-absolute-index.js"}],"../../../../node_modules/core-js/modules/es6.string.includes.js":[function(require,module,exports) {
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export = require('./_export');
var context = require('./_string-context');
var INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_string-context":"../../../../node_modules/core-js/modules/_string-context.js","./_fails-is-regexp":"../../../../node_modules/core-js/modules/_fails-is-regexp.js"}],"../../../../node_modules/core-js/modules/es6.string.italics.js":[function(require,module,exports) {
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.iterator.js":[function(require,module,exports) {
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_string-at":"../../../../node_modules/core-js/modules/_string-at.js","./_iter-define":"../../../../node_modules/core-js/modules/_iter-define.js"}],"../../../../node_modules/core-js/modules/es6.string.link.js":[function(require,module,exports) {
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/_string-repeat.js":[function(require,module,exports) {
'use strict';
var toInteger = require('./_to-integer');
var defined = require('./_defined');

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};

},{"./_to-integer":"../../../../node_modules/core-js/modules/_to-integer.js","./_defined":"../../../../node_modules/core-js/modules/_defined.js"}],"../../../../node_modules/core-js/modules/_string-pad.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length');
var repeat = require('./_string-repeat');
var defined = require('./_defined');

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_string-repeat":"../../../../node_modules/core-js/modules/_string-repeat.js","./_defined":"../../../../node_modules/core-js/modules/_defined.js"}],"../../../../node_modules/core-js/modules/es7.string.pad-start.js":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_string-pad":"../../../../node_modules/core-js/modules/_string-pad.js","./_user-agent":"../../../../node_modules/core-js/modules/_user-agent.js"}],"../../../../node_modules/core-js/modules/es7.string.pad-end.js":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_string-pad":"../../../../node_modules/core-js/modules/_string-pad.js","./_user-agent":"../../../../node_modules/core-js/modules/_user-agent.js"}],"../../../../node_modules/core-js/modules/es6.string.raw.js":[function(require,module,exports) {
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js"}],"../../../../node_modules/core-js/modules/es6.string.repeat.js":[function(require,module,exports) {
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_string-repeat":"../../../../node_modules/core-js/modules/_string-repeat.js"}],"../../../../node_modules/core-js/modules/es6.string.small.js":[function(require,module,exports) {
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.starts-with.js":[function(require,module,exports) {
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_string-context":"../../../../node_modules/core-js/modules/_string-context.js","./_fails-is-regexp":"../../../../node_modules/core-js/modules/_fails-is-regexp.js"}],"../../../../node_modules/core-js/modules/es6.string.strike.js":[function(require,module,exports) {
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.sub.js":[function(require,module,exports) {
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.sup.js":[function(require,module,exports) {
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/_typed.js":[function(require,module,exports) {

var global = require('./_global');
var hide = require('./_hide');
var uid = require('./_uid');
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_uid":"../../../../node_modules/core-js/modules/_uid.js"}],"../../../../node_modules/core-js/modules/_to-index.js":[function(require,module,exports) {
// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

},{"./_to-integer":"../../../../node_modules/core-js/modules/_to-integer.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js"}],"../../../../node_modules/core-js/modules/_typed-buffer.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var DESCRIPTORS = require('./_descriptors');
var LIBRARY = require('./_library');
var $typed = require('./_typed');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var fails = require('./_fails');
var anInstance = require('./_an-instance');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var toIndex = require('./_to-index');
var gOPN = require('./_object-gopn').f;
var dP = require('./_object-dp').f;
var arrayFill = require('./_array-fill');
var setToStringTag = require('./_set-to-string-tag');
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_library":"../../../../node_modules/core-js/modules/_library.js","./_typed":"../../../../node_modules/core-js/modules/_typed.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_redefine-all":"../../../../node_modules/core-js/modules/_redefine-all.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_an-instance":"../../../../node_modules/core-js/modules/_an-instance.js","./_to-integer":"../../../../node_modules/core-js/modules/_to-integer.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_to-index":"../../../../node_modules/core-js/modules/_to-index.js","./_object-gopn":"../../../../node_modules/core-js/modules/_object-gopn.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_array-fill":"../../../../node_modules/core-js/modules/_array-fill.js","./_set-to-string-tag":"../../../../node_modules/core-js/modules/_set-to-string-tag.js"}],"../../../../node_modules/core-js/modules/es6.typed.array-buffer.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $typed = require('./_typed');
var buffer = require('./_typed-buffer');
var anObject = require('./_an-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var isObject = require('./_is-object');
var ArrayBuffer = require('./_global').ArrayBuffer;
var speciesConstructor = require('./_species-constructor');
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_typed":"../../../../node_modules/core-js/modules/_typed.js","./_typed-buffer":"../../../../node_modules/core-js/modules/_typed-buffer.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_to-absolute-index":"../../../../node_modules/core-js/modules/_to-absolute-index.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_global":"../../../../node_modules/core-js/modules/_global.js","./_species-constructor":"../../../../node_modules/core-js/modules/_species-constructor.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_set-species":"../../../../node_modules/core-js/modules/_set-species.js"}],"../../../../node_modules/core-js/modules/_typed-array.js":[function(require,module,exports) {
var global = arguments[3];
'use strict';
if (require('./_descriptors')) {
  var LIBRARY = require('./_library');
  var global = require('./_global');
  var fails = require('./_fails');
  var $export = require('./_export');
  var $typed = require('./_typed');
  var $buffer = require('./_typed-buffer');
  var ctx = require('./_ctx');
  var anInstance = require('./_an-instance');
  var propertyDesc = require('./_property-desc');
  var hide = require('./_hide');
  var redefineAll = require('./_redefine-all');
  var toInteger = require('./_to-integer');
  var toLength = require('./_to-length');
  var toIndex = require('./_to-index');
  var toAbsoluteIndex = require('./_to-absolute-index');
  var toPrimitive = require('./_to-primitive');
  var has = require('./_has');
  var classof = require('./_classof');
  var isObject = require('./_is-object');
  var toObject = require('./_to-object');
  var isArrayIter = require('./_is-array-iter');
  var create = require('./_object-create');
  var getPrototypeOf = require('./_object-gpo');
  var gOPN = require('./_object-gopn').f;
  var getIterFn = require('./core.get-iterator-method');
  var uid = require('./_uid');
  var wks = require('./_wks');
  var createArrayMethod = require('./_array-methods');
  var createArrayIncludes = require('./_array-includes');
  var speciesConstructor = require('./_species-constructor');
  var ArrayIterators = require('./es6.array.iterator');
  var Iterators = require('./_iterators');
  var $iterDetect = require('./_iter-detect');
  var setSpecies = require('./_set-species');
  var arrayFill = require('./_array-fill');
  var arrayCopyWithin = require('./_array-copy-within');
  var $DP = require('./_object-dp');
  var $GOPD = require('./_object-gopd');
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };

},{"./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_library":"../../../../node_modules/core-js/modules/_library.js","./_global":"../../../../node_modules/core-js/modules/_global.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_typed":"../../../../node_modules/core-js/modules/_typed.js","./_typed-buffer":"../../../../node_modules/core-js/modules/_typed-buffer.js","./_ctx":"../../../../node_modules/core-js/modules/_ctx.js","./_an-instance":"../../../../node_modules/core-js/modules/_an-instance.js","./_property-desc":"../../../../node_modules/core-js/modules/_property-desc.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_redefine-all":"../../../../node_modules/core-js/modules/_redefine-all.js","./_to-integer":"../../../../node_modules/core-js/modules/_to-integer.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_to-index":"../../../../node_modules/core-js/modules/_to-index.js","./_to-absolute-index":"../../../../node_modules/core-js/modules/_to-absolute-index.js","./_to-primitive":"../../../../node_modules/core-js/modules/_to-primitive.js","./_has":"../../../../node_modules/core-js/modules/_has.js","./_classof":"../../../../node_modules/core-js/modules/_classof.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_is-array-iter":"../../../../node_modules/core-js/modules/_is-array-iter.js","./_object-create":"../../../../node_modules/core-js/modules/_object-create.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js","./_object-gopn":"../../../../node_modules/core-js/modules/_object-gopn.js","./core.get-iterator-method":"../../../../node_modules/core-js/modules/core.get-iterator-method.js","./_uid":"../../../../node_modules/core-js/modules/_uid.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js","./_array-methods":"../../../../node_modules/core-js/modules/_array-methods.js","./_array-includes":"../../../../node_modules/core-js/modules/_array-includes.js","./_species-constructor":"../../../../node_modules/core-js/modules/_species-constructor.js","./es6.array.iterator":"../../../../node_modules/core-js/modules/es6.array.iterator.js","./_iterators":"../../../../node_modules/core-js/modules/_iterators.js","./_iter-detect":"../../../../node_modules/core-js/modules/_iter-detect.js","./_set-species":"../../../../node_modules/core-js/modules/_set-species.js","./_array-fill":"../../../../node_modules/core-js/modules/_array-fill.js","./_array-copy-within":"../../../../node_modules/core-js/modules/_array-copy-within.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js"}],"../../../../node_modules/core-js/modules/es6.typed.int8-array.js":[function(require,module,exports) {
require('./_typed-array')('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../../../node_modules/core-js/modules/_typed-array.js"}],"../../../../node_modules/core-js/modules/es6.typed.uint8-array.js":[function(require,module,exports) {
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../../../node_modules/core-js/modules/_typed-array.js"}],"../../../../node_modules/core-js/modules/es6.typed.uint8-clamped-array.js":[function(require,module,exports) {
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

},{"./_typed-array":"../../../../node_modules/core-js/modules/_typed-array.js"}],"../../../../node_modules/core-js/modules/es6.typed.int16-array.js":[function(require,module,exports) {
require('./_typed-array')('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../../../node_modules/core-js/modules/_typed-array.js"}],"../../../../node_modules/core-js/modules/es6.typed.uint16-array.js":[function(require,module,exports) {
require('./_typed-array')('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../../../node_modules/core-js/modules/_typed-array.js"}],"../../../../node_modules/core-js/modules/es6.typed.int32-array.js":[function(require,module,exports) {
require('./_typed-array')('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../../../node_modules/core-js/modules/_typed-array.js"}],"../../../../node_modules/core-js/modules/es6.typed.uint32-array.js":[function(require,module,exports) {
require('./_typed-array')('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../../../node_modules/core-js/modules/_typed-array.js"}],"../../../../node_modules/core-js/modules/es6.typed.float32-array.js":[function(require,module,exports) {
require('./_typed-array')('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../../../node_modules/core-js/modules/_typed-array.js"}],"../../../../node_modules/core-js/modules/es6.typed.float64-array.js":[function(require,module,exports) {
require('./_typed-array')('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../../../node_modules/core-js/modules/_typed-array.js"}],"../../../../node_modules/core-js/modules/_collection-weak.js":[function(require,module,exports) {
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_redefine-all":"../../../../node_modules/core-js/modules/_redefine-all.js","./_meta":"../../../../node_modules/core-js/modules/_meta.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_an-instance":"../../../../node_modules/core-js/modules/_an-instance.js","./_for-of":"../../../../node_modules/core-js/modules/_for-of.js","./_array-methods":"../../../../node_modules/core-js/modules/_array-methods.js","./_has":"../../../../node_modules/core-js/modules/_has.js","./_validate-collection":"../../../../node_modules/core-js/modules/_validate-collection.js"}],"../../../../node_modules/core-js/modules/es6.weak-map.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var validate = require('./_validate-collection');
var NATIVE_WEAK_MAP = require('./_validate-collection');
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_array-methods":"../../../../node_modules/core-js/modules/_array-methods.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js","./_meta":"../../../../node_modules/core-js/modules/_meta.js","./_object-assign":"../../../../node_modules/core-js/modules/_object-assign.js","./_collection-weak":"../../../../node_modules/core-js/modules/_collection-weak.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_validate-collection":"../../../../node_modules/core-js/modules/_validate-collection.js","./_collection":"../../../../node_modules/core-js/modules/_collection.js"}],"../../../../node_modules/core-js/modules/es6.weak-set.js":[function(require,module,exports) {
'use strict';
var weak = require('./_collection-weak');
var validate = require('./_validate-collection');
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
require('./_collection')(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

},{"./_collection-weak":"../../../../node_modules/core-js/modules/_collection-weak.js","./_validate-collection":"../../../../node_modules/core-js/modules/_validate-collection.js","./_collection":"../../../../node_modules/core-js/modules/_collection.js"}],"../../../../node_modules/core-js/modules/_flatten-into-array.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = require('./_is-array');
var isObject = require('./_is-object');
var toLength = require('./_to-length');
var ctx = require('./_ctx');
var IS_CONCAT_SPREADABLE = require('./_wks')('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;

},{"./_is-array":"../../../../node_modules/core-js/modules/_is-array.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_ctx":"../../../../node_modules/core-js/modules/_ctx.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/es7.array.flat-map.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var aFunction = require('./_a-function');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

require('./_add-to-unscopables')('flatMap');

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_flatten-into-array":"../../../../node_modules/core-js/modules/_flatten-into-array.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_array-species-create":"../../../../node_modules/core-js/modules/_array-species-create.js","./_add-to-unscopables":"../../../../node_modules/core-js/modules/_add-to-unscopables.js"}],"../../../../node_modules/core-js/modules/web.timers.js":[function(require,module,exports) {

// ie9- setTimeout & setInterval additional parameters fix
var global = require('./_global');
var $export = require('./_export');
var userAgent = require('./_user-agent');
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_user-agent":"../../../../node_modules/core-js/modules/_user-agent.js"}],"../../../../node_modules/core-js/modules/web.immediate.js":[function(require,module,exports) {
var $export = require('./_export');
var $task = require('./_task');
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_task":"../../../../node_modules/core-js/modules/_task.js"}],"../../../../node_modules/core-js/modules/web.dom.iterable.js":[function(require,module,exports) {

var $iterators = require('./es6.array.iterator');
var getKeys = require('./_object-keys');
var redefine = require('./_redefine');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var wks = require('./_wks');
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

},{"./es6.array.iterator":"../../../../node_modules/core-js/modules/es6.array.iterator.js","./_object-keys":"../../../../node_modules/core-js/modules/_object-keys.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js","./_global":"../../../../node_modules/core-js/modules/_global.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_iterators":"../../../../node_modules/core-js/modules/_iterators.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/regenerator-runtime/runtime.js":[function(require,module,exports) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

},{}],"../../../../node_modules/tslib/tslib.es6.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__extends = __extends;
exports.__rest = __rest;
exports.__decorate = __decorate;
exports.__param = __param;
exports.__metadata = __metadata;
exports.__awaiter = __awaiter;
exports.__generator = __generator;
exports.__exportStar = __exportStar;
exports.__values = __values;
exports.__read = __read;
exports.__spread = __spread;
exports.__spreadArrays = __spreadArrays;
exports.__await = __await;
exports.__asyncGenerator = __asyncGenerator;
exports.__asyncDelegator = __asyncDelegator;
exports.__asyncValues = __asyncValues;
exports.__makeTemplateObject = __makeTemplateObject;
exports.__importStar = __importStar;
exports.__importDefault = __importDefault;
exports.__assign = void 0;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function () {
  exports.__assign = __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

exports.__assign = __assign;

function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}

function __exportStar(m, exports) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
  var m = typeof Symbol === "function" && o[Symbol.iterator],
      i = 0;
  if (m) return m.call(o);
  return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}

function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
}

function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

;

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
      i,
      q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;

  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }

  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }

  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }

  function fulfill(value) {
    resume("next", value);
  }

  function reject(value) {
    resume("throw", value);
  }

  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;

  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: n === "return"
      } : f ? f(v) : v;
    } : f;
  }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
      i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);

  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }

  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }

  return cooked;
}

;

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result.default = mod;
  return result;
}

function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}
},{}],"../../../../node_modules/rxjs/_esm5/internal/util/isFunction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFunction = isFunction;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isFunction(x) {
  return typeof x === 'function';
}
},{}],"../../../../node_modules/rxjs/_esm5/internal/config.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.config = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
  Promise: undefined,

  set useDeprecatedSynchronousErrorHandling(value) {
    if (value) {
      var error =
      /*@__PURE__*/
      new Error();
      /*@__PURE__*/

      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
    } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
      /*@__PURE__*/
      console.log('RxJS: Back to a better error behavior. Thank you. <3');
    }

    _enable_super_gross_mode_that_will_cause_bad_things = value;
  },

  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }

};
exports.config = config;
},{}],"../../../../node_modules/rxjs/_esm5/internal/util/hostReportError.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hostReportError = hostReportError;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function hostReportError(err) {
  setTimeout(function () {
    throw err;
  }, 0);
}
},{}],"../../../../node_modules/rxjs/_esm5/internal/Observer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.empty = void 0;

var _config = require("./config");

var _hostReportError = require("./util/hostReportError");

/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */
var empty = {
  closed: true,
  next: function (value) {},
  error: function (err) {
    if (_config.config.useDeprecatedSynchronousErrorHandling) {
      throw err;
    } else {
      (0, _hostReportError.hostReportError)(err);
    }
  },
  complete: function () {}
};
exports.empty = empty;
},{"./config":"../../../../node_modules/rxjs/_esm5/internal/config.js","./util/hostReportError":"../../../../node_modules/rxjs/_esm5/internal/util/hostReportError.js"}],"../../../../node_modules/rxjs/_esm5/internal/util/isArray.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isArray = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArray =
/*@__PURE__*/
function () {
  return Array.isArray || function (x) {
    return x && typeof x.length === 'number';
  };
}();

exports.isArray = isArray;
},{}],"../../../../node_modules/rxjs/_esm5/internal/util/isObject.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isObject = isObject;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isObject(x) {
  return x !== null && typeof x === 'object';
}
},{}],"../../../../node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UnsubscriptionError = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var UnsubscriptionErrorImpl =
/*@__PURE__*/
function () {
  function UnsubscriptionErrorImpl(errors) {
    Error.call(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) {
      return i + 1 + ") " + err.toString();
    }).join('\n  ') : '';
    this.name = 'UnsubscriptionError';
    this.errors = errors;
    return this;
  }

  UnsubscriptionErrorImpl.prototype =
  /*@__PURE__*/
  Object.create(Error.prototype);
  return UnsubscriptionErrorImpl;
}();

var UnsubscriptionError = UnsubscriptionErrorImpl;
exports.UnsubscriptionError = UnsubscriptionError;
},{}],"../../../../node_modules/rxjs/_esm5/internal/Subscription.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Subscription = void 0;

var _isArray = require("./util/isArray");

var _isObject = require("./util/isObject");

var _isFunction = require("./util/isFunction");

var _UnsubscriptionError = require("./util/UnsubscriptionError");

/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */
var Subscription =
/*@__PURE__*/
function () {
  function Subscription(unsubscribe) {
    this.closed = false;
    this._parentOrParents = null;
    this._subscriptions = null;

    if (unsubscribe) {
      this._unsubscribe = unsubscribe;
    }
  }

  Subscription.prototype.unsubscribe = function () {
    var errors;

    if (this.closed) {
      return;
    }

    var _a = this,
        _parentOrParents = _a._parentOrParents,
        _unsubscribe = _a._unsubscribe,
        _subscriptions = _a._subscriptions;

    this.closed = true;
    this._parentOrParents = null;
    this._subscriptions = null;

    if (_parentOrParents instanceof Subscription) {
      _parentOrParents.remove(this);
    } else if (_parentOrParents !== null) {
      for (var index = 0; index < _parentOrParents.length; ++index) {
        var parent_1 = _parentOrParents[index];
        parent_1.remove(this);
      }
    }

    if ((0, _isFunction.isFunction)(_unsubscribe)) {
      try {
        _unsubscribe.call(this);
      } catch (e) {
        errors = e instanceof _UnsubscriptionError.UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
      }
    }

    if ((0, _isArray.isArray)(_subscriptions)) {
      var index = -1;
      var len = _subscriptions.length;

      while (++index < len) {
        var sub = _subscriptions[index];

        if ((0, _isObject.isObject)(sub)) {
          try {
            sub.unsubscribe();
          } catch (e) {
            errors = errors || [];

            if (e instanceof _UnsubscriptionError.UnsubscriptionError) {
              errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
            } else {
              errors.push(e);
            }
          }
        }
      }
    }

    if (errors) {
      throw new _UnsubscriptionError.UnsubscriptionError(errors);
    }
  };

  Subscription.prototype.add = function (teardown) {
    var subscription = teardown;

    if (!teardown) {
      return Subscription.EMPTY;
    }

    switch (typeof teardown) {
      case 'function':
        subscription = new Subscription(teardown);

      case 'object':
        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
          return subscription;
        } else if (this.closed) {
          subscription.unsubscribe();
          return subscription;
        } else if (!(subscription instanceof Subscription)) {
          var tmp = subscription;
          subscription = new Subscription();
          subscription._subscriptions = [tmp];
        }

        break;

      default:
        {
          throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
    }

    var _parentOrParents = subscription._parentOrParents;

    if (_parentOrParents === null) {
      subscription._parentOrParents = this;
    } else if (_parentOrParents instanceof Subscription) {
      if (_parentOrParents === this) {
        return subscription;
      }

      subscription._parentOrParents = [_parentOrParents, this];
    } else if (_parentOrParents.indexOf(this) === -1) {
      _parentOrParents.push(this);
    } else {
      return subscription;
    }

    var subscriptions = this._subscriptions;

    if (subscriptions === null) {
      this._subscriptions = [subscription];
    } else {
      subscriptions.push(subscription);
    }

    return subscription;
  };

  Subscription.prototype.remove = function (subscription) {
    var subscriptions = this._subscriptions;

    if (subscriptions) {
      var subscriptionIndex = subscriptions.indexOf(subscription);

      if (subscriptionIndex !== -1) {
        subscriptions.splice(subscriptionIndex, 1);
      }
    }
  };

  Subscription.EMPTY = function (empty) {
    empty.closed = true;
    return empty;
  }(new Subscription());

  return Subscription;
}();

exports.Subscription = Subscription;

function flattenUnsubscriptionErrors(errors) {
  return errors.reduce(function (errs, err) {
    return errs.concat(err instanceof _UnsubscriptionError.UnsubscriptionError ? err.errors : err);
  }, []);
}
},{"./util/isArray":"../../../../node_modules/rxjs/_esm5/internal/util/isArray.js","./util/isObject":"../../../../node_modules/rxjs/_esm5/internal/util/isObject.js","./util/isFunction":"../../../../node_modules/rxjs/_esm5/internal/util/isFunction.js","./util/UnsubscriptionError":"../../../../node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js"}],"../../../../node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.$$rxSubscriber = exports.rxSubscriber = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var rxSubscriber =
/*@__PURE__*/
function () {
  return typeof Symbol === 'function' ?
  /*@__PURE__*/
  Symbol('rxSubscriber') : '@@rxSubscriber_' +
  /*@__PURE__*/
  Math.random();
}();

exports.rxSubscriber = rxSubscriber;
var $$rxSubscriber = rxSubscriber;
exports.$$rxSubscriber = $$rxSubscriber;
},{}],"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SafeSubscriber = exports.Subscriber = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _isFunction = require("./util/isFunction");

var _Observer = require("./Observer");

var _Subscription = require("./Subscription");

var _rxSubscriber = require("../internal/symbol/rxSubscriber");

var _config = require("./config");

var _hostReportError = require("./util/hostReportError");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */
var Subscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(Subscriber, _super);

  function Subscriber(destinationOrNext, error, complete) {
    var _this = _super.call(this) || this;

    _this.syncErrorValue = null;
    _this.syncErrorThrown = false;
    _this.syncErrorThrowable = false;
    _this.isStopped = false;

    switch (arguments.length) {
      case 0:
        _this.destination = _Observer.empty;
        break;

      case 1:
        if (!destinationOrNext) {
          _this.destination = _Observer.empty;
          break;
        }

        if (typeof destinationOrNext === 'object') {
          if (destinationOrNext instanceof Subscriber) {
            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
            _this.destination = destinationOrNext;
            destinationOrNext.add(_this);
          } else {
            _this.syncErrorThrowable = true;
            _this.destination = new SafeSubscriber(_this, destinationOrNext);
          }

          break;
        }

      default:
        _this.syncErrorThrowable = true;
        _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
        break;
    }

    return _this;
  }

  Subscriber.prototype[_rxSubscriber.rxSubscriber] = function () {
    return this;
  };

  Subscriber.create = function (next, error, complete) {
    var subscriber = new Subscriber(next, error, complete);
    subscriber.syncErrorThrowable = false;
    return subscriber;
  };

  Subscriber.prototype.next = function (value) {
    if (!this.isStopped) {
      this._next(value);
    }
  };

  Subscriber.prototype.error = function (err) {
    if (!this.isStopped) {
      this.isStopped = true;

      this._error(err);
    }
  };

  Subscriber.prototype.complete = function () {
    if (!this.isStopped) {
      this.isStopped = true;

      this._complete();
    }
  };

  Subscriber.prototype.unsubscribe = function () {
    if (this.closed) {
      return;
    }

    this.isStopped = true;

    _super.prototype.unsubscribe.call(this);
  };

  Subscriber.prototype._next = function (value) {
    this.destination.next(value);
  };

  Subscriber.prototype._error = function (err) {
    this.destination.error(err);
    this.unsubscribe();
  };

  Subscriber.prototype._complete = function () {
    this.destination.complete();
    this.unsubscribe();
  };

  Subscriber.prototype._unsubscribeAndRecycle = function () {
    var _parentOrParents = this._parentOrParents;
    this._parentOrParents = null;
    this.unsubscribe();
    this.closed = false;
    this.isStopped = false;
    this._parentOrParents = _parentOrParents;
    return this;
  };

  return Subscriber;
}(_Subscription.Subscription);

exports.Subscriber = Subscriber;

var SafeSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(SafeSubscriber, _super);

  function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
    var _this = _super.call(this) || this;

    _this._parentSubscriber = _parentSubscriber;
    var next;
    var context = _this;

    if ((0, _isFunction.isFunction)(observerOrNext)) {
      next = observerOrNext;
    } else if (observerOrNext) {
      next = observerOrNext.next;
      error = observerOrNext.error;
      complete = observerOrNext.complete;

      if (observerOrNext !== _Observer.empty) {
        context = Object.create(observerOrNext);

        if ((0, _isFunction.isFunction)(context.unsubscribe)) {
          _this.add(context.unsubscribe.bind(context));
        }

        context.unsubscribe = _this.unsubscribe.bind(_this);
      }
    }

    _this._context = context;
    _this._next = next;
    _this._error = error;
    _this._complete = complete;
    return _this;
  }

  SafeSubscriber.prototype.next = function (value) {
    if (!this.isStopped && this._next) {
      var _parentSubscriber = this._parentSubscriber;

      if (!_config.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
        this.__tryOrUnsub(this._next, value);
      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
        this.unsubscribe();
      }
    }
  };

  SafeSubscriber.prototype.error = function (err) {
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      var useDeprecatedSynchronousErrorHandling = _config.config.useDeprecatedSynchronousErrorHandling;

      if (this._error) {
        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(this._error, err);

          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, this._error, err);

          this.unsubscribe();
        }
      } else if (!_parentSubscriber.syncErrorThrowable) {
        this.unsubscribe();

        if (useDeprecatedSynchronousErrorHandling) {
          throw err;
        }

        (0, _hostReportError.hostReportError)(err);
      } else {
        if (useDeprecatedSynchronousErrorHandling) {
          _parentSubscriber.syncErrorValue = err;
          _parentSubscriber.syncErrorThrown = true;
        } else {
          (0, _hostReportError.hostReportError)(err);
        }

        this.unsubscribe();
      }
    }
  };

  SafeSubscriber.prototype.complete = function () {
    var _this = this;

    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;

      if (this._complete) {
        var wrappedComplete = function () {
          return _this._complete.call(_this._context);
        };

        if (!_config.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(wrappedComplete);

          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, wrappedComplete);

          this.unsubscribe();
        }
      } else {
        this.unsubscribe();
      }
    }
  };

  SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
    try {
      fn.call(this._context, value);
    } catch (err) {
      this.unsubscribe();

      if (_config.config.useDeprecatedSynchronousErrorHandling) {
        throw err;
      } else {
        (0, _hostReportError.hostReportError)(err);
      }
    }
  };

  SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
    if (!_config.config.useDeprecatedSynchronousErrorHandling) {
      throw new Error('bad call');
    }

    try {
      fn.call(this._context, value);
    } catch (err) {
      if (_config.config.useDeprecatedSynchronousErrorHandling) {
        parent.syncErrorValue = err;
        parent.syncErrorThrown = true;
        return true;
      } else {
        (0, _hostReportError.hostReportError)(err);
        return true;
      }
    }

    return false;
  };

  SafeSubscriber.prototype._unsubscribe = function () {
    var _parentSubscriber = this._parentSubscriber;
    this._context = null;
    this._parentSubscriber = null;

    _parentSubscriber.unsubscribe();
  };

  return SafeSubscriber;
}(Subscriber);

exports.SafeSubscriber = SafeSubscriber;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","./util/isFunction":"../../../../node_modules/rxjs/_esm5/internal/util/isFunction.js","./Observer":"../../../../node_modules/rxjs/_esm5/internal/Observer.js","./Subscription":"../../../../node_modules/rxjs/_esm5/internal/Subscription.js","../internal/symbol/rxSubscriber":"../../../../node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js","./config":"../../../../node_modules/rxjs/_esm5/internal/config.js","./util/hostReportError":"../../../../node_modules/rxjs/_esm5/internal/util/hostReportError.js"}],"../../../../node_modules/rxjs/_esm5/internal/util/canReportError.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canReportError = canReportError;

var _Subscriber = require("../Subscriber");

/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */
function canReportError(observer) {
  while (observer) {
    var _a = observer,
        closed_1 = _a.closed,
        destination = _a.destination,
        isStopped = _a.isStopped;

    if (closed_1 || isStopped) {
      return false;
    } else if (destination && destination instanceof _Subscriber.Subscriber) {
      observer = destination;
    } else {
      observer = null;
    }
  }

  return true;
}
},{"../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/util/toSubscriber.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toSubscriber = toSubscriber;

var _Subscriber = require("../Subscriber");

var _rxSubscriber = require("../symbol/rxSubscriber");

var _Observer = require("../Observer");

/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
function toSubscriber(nextOrObserver, error, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof _Subscriber.Subscriber) {
      return nextOrObserver;
    }

    if (nextOrObserver[_rxSubscriber.rxSubscriber]) {
      return nextOrObserver[_rxSubscriber.rxSubscriber]();
    }
  }

  if (!nextOrObserver && !error && !complete) {
    return new _Subscriber.Subscriber(_Observer.empty);
  }

  return new _Subscriber.Subscriber(nextOrObserver, error, complete);
}
},{"../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../symbol/rxSubscriber":"../../../../node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js","../Observer":"../../../../node_modules/rxjs/_esm5/internal/Observer.js"}],"../../../../node_modules/rxjs/_esm5/internal/symbol/observable.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.observable = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var observable =
/*@__PURE__*/
function () {
  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
}();

exports.observable = observable;
},{}],"../../../../node_modules/rxjs/_esm5/internal/util/noop.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.noop = noop;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function noop() {}
},{}],"../../../../node_modules/rxjs/_esm5/internal/util/pipe.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pipe = pipe;
exports.pipeFromArray = pipeFromArray;

var _noop = require("./noop");

/** PURE_IMPORTS_START _noop PURE_IMPORTS_END */
function pipe() {
  var fns = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }

  return pipeFromArray(fns);
}

function pipeFromArray(fns) {
  if (!fns) {
    return _noop.noop;
  }

  if (fns.length === 1) {
    return fns[0];
  }

  return function piped(input) {
    return fns.reduce(function (prev, fn) {
      return fn(prev);
    }, input);
  };
}
},{"./noop":"../../../../node_modules/rxjs/_esm5/internal/util/noop.js"}],"../../../../node_modules/rxjs/_esm5/internal/Observable.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Observable = void 0;

var _canReportError = require("./util/canReportError");

var _toSubscriber = require("./util/toSubscriber");

var _observable = require("./symbol/observable");

var _pipe = require("./util/pipe");

var _config = require("./config");

/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
var Observable =
/*@__PURE__*/
function () {
  function Observable(subscribe) {
    this._isScalar = false;

    if (subscribe) {
      this._subscribe = subscribe;
    }
  }

  Observable.prototype.lift = function (operator) {
    var observable = new Observable();
    observable.source = this;
    observable.operator = operator;
    return observable;
  };

  Observable.prototype.subscribe = function (observerOrNext, error, complete) {
    var operator = this.operator;
    var sink = (0, _toSubscriber.toSubscriber)(observerOrNext, error, complete);

    if (operator) {
      sink.add(operator.call(sink, this.source));
    } else {
      sink.add(this.source || _config.config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
    }

    if (_config.config.useDeprecatedSynchronousErrorHandling) {
      if (sink.syncErrorThrowable) {
        sink.syncErrorThrowable = false;

        if (sink.syncErrorThrown) {
          throw sink.syncErrorValue;
        }
      }
    }

    return sink;
  };

  Observable.prototype._trySubscribe = function (sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      if (_config.config.useDeprecatedSynchronousErrorHandling) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
      }

      if ((0, _canReportError.canReportError)(sink)) {
        sink.error(err);
      } else {
        console.warn(err);
      }
    }
  };

  Observable.prototype.forEach = function (next, promiseCtor) {
    var _this = this;

    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function (resolve, reject) {
      var subscription;
      subscription = _this.subscribe(function (value) {
        try {
          next(value);
        } catch (err) {
          reject(err);

          if (subscription) {
            subscription.unsubscribe();
          }
        }
      }, reject, resolve);
    });
  };

  Observable.prototype._subscribe = function (subscriber) {
    var source = this.source;
    return source && source.subscribe(subscriber);
  };

  Observable.prototype[_observable.observable] = function () {
    return this;
  };

  Observable.prototype.pipe = function () {
    var operations = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }

    if (operations.length === 0) {
      return this;
    }

    return (0, _pipe.pipeFromArray)(operations)(this);
  };

  Observable.prototype.toPromise = function (promiseCtor) {
    var _this = this;

    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function (resolve, reject) {
      var value;

      _this.subscribe(function (x) {
        return value = x;
      }, function (err) {
        return reject(err);
      }, function () {
        return resolve(value);
      });
    });
  };

  Observable.create = function (subscribe) {
    return new Observable(subscribe);
  };

  return Observable;
}();

exports.Observable = Observable;

function getPromiseCtor(promiseCtor) {
  if (!promiseCtor) {
    promiseCtor = _config.config.Promise || Promise;
  }

  if (!promiseCtor) {
    throw new Error('no Promise impl found');
  }

  return promiseCtor;
}
},{"./util/canReportError":"../../../../node_modules/rxjs/_esm5/internal/util/canReportError.js","./util/toSubscriber":"../../../../node_modules/rxjs/_esm5/internal/util/toSubscriber.js","./symbol/observable":"../../../../node_modules/rxjs/_esm5/internal/symbol/observable.js","./util/pipe":"../../../../node_modules/rxjs/_esm5/internal/util/pipe.js","./config":"../../../../node_modules/rxjs/_esm5/internal/config.js"}],"../../../../node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectUnsubscribedError = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var ObjectUnsubscribedErrorImpl =
/*@__PURE__*/
function () {
  function ObjectUnsubscribedErrorImpl() {
    Error.call(this);
    this.message = 'object unsubscribed';
    this.name = 'ObjectUnsubscribedError';
    return this;
  }

  ObjectUnsubscribedErrorImpl.prototype =
  /*@__PURE__*/
  Object.create(Error.prototype);
  return ObjectUnsubscribedErrorImpl;
}();

var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
},{}],"../../../../node_modules/rxjs/_esm5/internal/SubjectSubscription.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SubjectSubscription = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscription = require("./Subscription");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
var SubjectSubscription =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(SubjectSubscription, _super);

  function SubjectSubscription(subject, subscriber) {
    var _this = _super.call(this) || this;

    _this.subject = subject;
    _this.subscriber = subscriber;
    _this.closed = false;
    return _this;
  }

  SubjectSubscription.prototype.unsubscribe = function () {
    if (this.closed) {
      return;
    }

    this.closed = true;
    var subject = this.subject;
    var observers = subject.observers;
    this.subject = null;

    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
      return;
    }

    var subscriberIndex = observers.indexOf(this.subscriber);

    if (subscriberIndex !== -1) {
      observers.splice(subscriberIndex, 1);
    }
  };

  return SubjectSubscription;
}(_Subscription.Subscription);

exports.SubjectSubscription = SubjectSubscription;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","./Subscription":"../../../../node_modules/rxjs/_esm5/internal/Subscription.js"}],"../../../../node_modules/rxjs/_esm5/internal/Subject.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnonymousSubject = exports.Subject = exports.SubjectSubscriber = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Observable = require("./Observable");

var _Subscriber = require("./Subscriber");

var _Subscription = require("./Subscription");

var _ObjectUnsubscribedError = require("./util/ObjectUnsubscribedError");

var _SubjectSubscription = require("./SubjectSubscription");

var _rxSubscriber = require("../internal/symbol/rxSubscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */
var SubjectSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(SubjectSubscriber, _super);

  function SubjectSubscriber(destination) {
    var _this = _super.call(this, destination) || this;

    _this.destination = destination;
    return _this;
  }

  return SubjectSubscriber;
}(_Subscriber.Subscriber);

exports.SubjectSubscriber = SubjectSubscriber;

var Subject =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(Subject, _super);

  function Subject() {
    var _this = _super.call(this) || this;

    _this.observers = [];
    _this.closed = false;
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }

  Subject.prototype[_rxSubscriber.rxSubscriber] = function () {
    return new SubjectSubscriber(this);
  };

  Subject.prototype.lift = function (operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };

  Subject.prototype.next = function (value) {
    if (this.closed) {
      throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
    }

    if (!this.isStopped) {
      var observers = this.observers;
      var len = observers.length;
      var copy = observers.slice();

      for (var i = 0; i < len; i++) {
        copy[i].next(value);
      }
    }
  };

  Subject.prototype.error = function (err) {
    if (this.closed) {
      throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
    }

    this.hasError = true;
    this.thrownError = err;
    this.isStopped = true;
    var observers = this.observers;
    var len = observers.length;
    var copy = observers.slice();

    for (var i = 0; i < len; i++) {
      copy[i].error(err);
    }

    this.observers.length = 0;
  };

  Subject.prototype.complete = function () {
    if (this.closed) {
      throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
    }

    this.isStopped = true;
    var observers = this.observers;
    var len = observers.length;
    var copy = observers.slice();

    for (var i = 0; i < len; i++) {
      copy[i].complete();
    }

    this.observers.length = 0;
  };

  Subject.prototype.unsubscribe = function () {
    this.isStopped = true;
    this.closed = true;
    this.observers = null;
  };

  Subject.prototype._trySubscribe = function (subscriber) {
    if (this.closed) {
      throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
    } else {
      return _super.prototype._trySubscribe.call(this, subscriber);
    }
  };

  Subject.prototype._subscribe = function (subscriber) {
    if (this.closed) {
      throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
    } else if (this.hasError) {
      subscriber.error(this.thrownError);
      return _Subscription.Subscription.EMPTY;
    } else if (this.isStopped) {
      subscriber.complete();
      return _Subscription.Subscription.EMPTY;
    } else {
      this.observers.push(subscriber);
      return new _SubjectSubscription.SubjectSubscription(this, subscriber);
    }
  };

  Subject.prototype.asObservable = function () {
    var observable = new _Observable.Observable();
    observable.source = this;
    return observable;
  };

  Subject.create = function (destination, source) {
    return new AnonymousSubject(destination, source);
  };

  return Subject;
}(_Observable.Observable);

exports.Subject = Subject;

var AnonymousSubject =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(AnonymousSubject, _super);

  function AnonymousSubject(destination, source) {
    var _this = _super.call(this) || this;

    _this.destination = destination;
    _this.source = source;
    return _this;
  }

  AnonymousSubject.prototype.next = function (value) {
    var destination = this.destination;

    if (destination && destination.next) {
      destination.next(value);
    }
  };

  AnonymousSubject.prototype.error = function (err) {
    var destination = this.destination;

    if (destination && destination.error) {
      this.destination.error(err);
    }
  };

  AnonymousSubject.prototype.complete = function () {
    var destination = this.destination;

    if (destination && destination.complete) {
      this.destination.complete();
    }
  };

  AnonymousSubject.prototype._subscribe = function (subscriber) {
    var source = this.source;

    if (source) {
      return this.source.subscribe(subscriber);
    } else {
      return _Subscription.Subscription.EMPTY;
    }
  };

  return AnonymousSubject;
}(Subject);

exports.AnonymousSubject = AnonymousSubject;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","./Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","./Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","./Subscription":"../../../../node_modules/rxjs/_esm5/internal/Subscription.js","./util/ObjectUnsubscribedError":"../../../../node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js","./SubjectSubscription":"../../../../node_modules/rxjs/_esm5/internal/SubjectSubscription.js","../internal/symbol/rxSubscriber":"../../../../node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/refCount.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.refCount = refCount;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function refCount() {
  return function refCountOperatorFunction(source) {
    return source.lift(new RefCountOperator(source));
  };
}

var RefCountOperator =
/*@__PURE__*/
function () {
  function RefCountOperator(connectable) {
    this.connectable = connectable;
  }

  RefCountOperator.prototype.call = function (subscriber, source) {
    var connectable = this.connectable;
    connectable._refCount++;
    var refCounter = new RefCountSubscriber(subscriber, connectable);
    var subscription = source.subscribe(refCounter);

    if (!refCounter.closed) {
      refCounter.connection = connectable.connect();
    }

    return subscription;
  };

  return RefCountOperator;
}();

var RefCountSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(RefCountSubscriber, _super);

  function RefCountSubscriber(destination, connectable) {
    var _this = _super.call(this, destination) || this;

    _this.connectable = connectable;
    return _this;
  }

  RefCountSubscriber.prototype._unsubscribe = function () {
    var connectable = this.connectable;

    if (!connectable) {
      this.connection = null;
      return;
    }

    this.connectable = null;
    var refCount = connectable._refCount;

    if (refCount <= 0) {
      this.connection = null;
      return;
    }

    connectable._refCount = refCount - 1;

    if (refCount > 1) {
      this.connection = null;
      return;
    }

    var connection = this.connection;
    var sharedConnection = connectable._connection;
    this.connection = null;

    if (sharedConnection && (!connection || sharedConnection === connection)) {
      sharedConnection.unsubscribe();
    }
  };

  return RefCountSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connectableObservableDescriptor = exports.ConnectableObservable = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subject = require("../Subject");

var _Observable = require("../Observable");

var _Subscriber = require("../Subscriber");

var _Subscription = require("../Subscription");

var _refCount = require("../operators/refCount");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */
var ConnectableObservable =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(ConnectableObservable, _super);

  function ConnectableObservable(source, subjectFactory) {
    var _this = _super.call(this) || this;

    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._refCount = 0;
    _this._isComplete = false;
    return _this;
  }

  ConnectableObservable.prototype._subscribe = function (subscriber) {
    return this.getSubject().subscribe(subscriber);
  };

  ConnectableObservable.prototype.getSubject = function () {
    var subject = this._subject;

    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }

    return this._subject;
  };

  ConnectableObservable.prototype.connect = function () {
    var connection = this._connection;

    if (!connection) {
      this._isComplete = false;
      connection = this._connection = new _Subscription.Subscription();
      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));

      if (connection.closed) {
        this._connection = null;
        connection = _Subscription.Subscription.EMPTY;
      }
    }

    return connection;
  };

  ConnectableObservable.prototype.refCount = function () {
    return (0, _refCount.refCount)()(this);
  };

  return ConnectableObservable;
}(_Observable.Observable);

exports.ConnectableObservable = ConnectableObservable;

var connectableObservableDescriptor =
/*@__PURE__*/
function () {
  var connectableProto = ConnectableObservable.prototype;
  return {
    operator: {
      value: null
    },
    _refCount: {
      value: 0,
      writable: true
    },
    _subject: {
      value: null,
      writable: true
    },
    _connection: {
      value: null,
      writable: true
    },
    _subscribe: {
      value: connectableProto._subscribe
    },
    _isComplete: {
      value: connectableProto._isComplete,
      writable: true
    },
    getSubject: {
      value: connectableProto.getSubject
    },
    connect: {
      value: connectableProto.connect
    },
    refCount: {
      value: connectableProto.refCount
    }
  };
}();

exports.connectableObservableDescriptor = connectableObservableDescriptor;

var ConnectableSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(ConnectableSubscriber, _super);

  function ConnectableSubscriber(destination, connectable) {
    var _this = _super.call(this, destination) || this;

    _this.connectable = connectable;
    return _this;
  }

  ConnectableSubscriber.prototype._error = function (err) {
    this._unsubscribe();

    _super.prototype._error.call(this, err);
  };

  ConnectableSubscriber.prototype._complete = function () {
    this.connectable._isComplete = true;

    this._unsubscribe();

    _super.prototype._complete.call(this);
  };

  ConnectableSubscriber.prototype._unsubscribe = function () {
    var connectable = this.connectable;

    if (connectable) {
      this.connectable = null;
      var connection = connectable._connection;
      connectable._refCount = 0;
      connectable._subject = null;
      connectable._connection = null;

      if (connection) {
        connection.unsubscribe();
      }
    }
  };

  return ConnectableSubscriber;
}(_Subject.SubjectSubscriber);

var RefCountOperator =
/*@__PURE__*/
function () {
  function RefCountOperator(connectable) {
    this.connectable = connectable;
  }

  RefCountOperator.prototype.call = function (subscriber, source) {
    var connectable = this.connectable;
    connectable._refCount++;
    var refCounter = new RefCountSubscriber(subscriber, connectable);
    var subscription = source.subscribe(refCounter);

    if (!refCounter.closed) {
      refCounter.connection = connectable.connect();
    }

    return subscription;
  };

  return RefCountOperator;
}();

var RefCountSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(RefCountSubscriber, _super);

  function RefCountSubscriber(destination, connectable) {
    var _this = _super.call(this, destination) || this;

    _this.connectable = connectable;
    return _this;
  }

  RefCountSubscriber.prototype._unsubscribe = function () {
    var connectable = this.connectable;

    if (!connectable) {
      this.connection = null;
      return;
    }

    this.connectable = null;
    var refCount = connectable._refCount;

    if (refCount <= 0) {
      this.connection = null;
      return;
    }

    connectable._refCount = refCount - 1;

    if (refCount > 1) {
      this.connection = null;
      return;
    }

    var connection = this.connection;
    var sharedConnection = connectable._connection;
    this.connection = null;

    if (sharedConnection && (!connection || sharedConnection === connection)) {
      sharedConnection.unsubscribe();
    }
  };

  return RefCountSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subject":"../../../../node_modules/rxjs/_esm5/internal/Subject.js","../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../Subscription":"../../../../node_modules/rxjs/_esm5/internal/Subscription.js","../operators/refCount":"../../../../node_modules/rxjs/_esm5/internal/operators/refCount.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/groupBy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.groupBy = groupBy;
exports.GroupedObservable = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

var _Subscription = require("../Subscription");

var _Observable = require("../Observable");

var _Subject = require("../Subject");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
  return function (source) {
    return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
  };
}

var GroupByOperator =
/*@__PURE__*/
function () {
  function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
    this.keySelector = keySelector;
    this.elementSelector = elementSelector;
    this.durationSelector = durationSelector;
    this.subjectSelector = subjectSelector;
  }

  GroupByOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
  };

  return GroupByOperator;
}();

var GroupBySubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(GroupBySubscriber, _super);

  function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
    var _this = _super.call(this, destination) || this;

    _this.keySelector = keySelector;
    _this.elementSelector = elementSelector;
    _this.durationSelector = durationSelector;
    _this.subjectSelector = subjectSelector;
    _this.groups = null;
    _this.attemptedToUnsubscribe = false;
    _this.count = 0;
    return _this;
  }

  GroupBySubscriber.prototype._next = function (value) {
    var key;

    try {
      key = this.keySelector(value);
    } catch (err) {
      this.error(err);
      return;
    }

    this._group(value, key);
  };

  GroupBySubscriber.prototype._group = function (value, key) {
    var groups = this.groups;

    if (!groups) {
      groups = this.groups = new Map();
    }

    var group = groups.get(key);
    var element;

    if (this.elementSelector) {
      try {
        element = this.elementSelector(value);
      } catch (err) {
        this.error(err);
      }
    } else {
      element = value;
    }

    if (!group) {
      group = this.subjectSelector ? this.subjectSelector() : new _Subject.Subject();
      groups.set(key, group);
      var groupedObservable = new GroupedObservable(key, group, this);
      this.destination.next(groupedObservable);

      if (this.durationSelector) {
        var duration = void 0;

        try {
          duration = this.durationSelector(new GroupedObservable(key, group));
        } catch (err) {
          this.error(err);
          return;
        }

        this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
      }
    }

    if (!group.closed) {
      group.next(element);
    }
  };

  GroupBySubscriber.prototype._error = function (err) {
    var groups = this.groups;

    if (groups) {
      groups.forEach(function (group, key) {
        group.error(err);
      });
      groups.clear();
    }

    this.destination.error(err);
  };

  GroupBySubscriber.prototype._complete = function () {
    var groups = this.groups;

    if (groups) {
      groups.forEach(function (group, key) {
        group.complete();
      });
      groups.clear();
    }

    this.destination.complete();
  };

  GroupBySubscriber.prototype.removeGroup = function (key) {
    this.groups.delete(key);
  };

  GroupBySubscriber.prototype.unsubscribe = function () {
    if (!this.closed) {
      this.attemptedToUnsubscribe = true;

      if (this.count === 0) {
        _super.prototype.unsubscribe.call(this);
      }
    }
  };

  return GroupBySubscriber;
}(_Subscriber.Subscriber);

var GroupDurationSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(GroupDurationSubscriber, _super);

  function GroupDurationSubscriber(key, group, parent) {
    var _this = _super.call(this, group) || this;

    _this.key = key;
    _this.group = group;
    _this.parent = parent;
    return _this;
  }

  GroupDurationSubscriber.prototype._next = function (value) {
    this.complete();
  };

  GroupDurationSubscriber.prototype._unsubscribe = function () {
    var _a = this,
        parent = _a.parent,
        key = _a.key;

    this.key = this.parent = null;

    if (parent) {
      parent.removeGroup(key);
    }
  };

  return GroupDurationSubscriber;
}(_Subscriber.Subscriber);

var GroupedObservable =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(GroupedObservable, _super);

  function GroupedObservable(key, groupSubject, refCountSubscription) {
    var _this = _super.call(this) || this;

    _this.key = key;
    _this.groupSubject = groupSubject;
    _this.refCountSubscription = refCountSubscription;
    return _this;
  }

  GroupedObservable.prototype._subscribe = function (subscriber) {
    var subscription = new _Subscription.Subscription();

    var _a = this,
        refCountSubscription = _a.refCountSubscription,
        groupSubject = _a.groupSubject;

    if (refCountSubscription && !refCountSubscription.closed) {
      subscription.add(new InnerRefCountSubscription(refCountSubscription));
    }

    subscription.add(groupSubject.subscribe(subscriber));
    return subscription;
  };

  return GroupedObservable;
}(_Observable.Observable);

exports.GroupedObservable = GroupedObservable;

var InnerRefCountSubscription =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(InnerRefCountSubscription, _super);

  function InnerRefCountSubscription(parent) {
    var _this = _super.call(this) || this;

    _this.parent = parent;
    parent.count++;
    return _this;
  }

  InnerRefCountSubscription.prototype.unsubscribe = function () {
    var parent = this.parent;

    if (!parent.closed && !this.closed) {
      _super.prototype.unsubscribe.call(this);

      parent.count -= 1;

      if (parent.count === 0 && parent.attemptedToUnsubscribe) {
        parent.unsubscribe();
      }
    }
  };

  return InnerRefCountSubscription;
}(_Subscription.Subscription);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../Subscription":"../../../../node_modules/rxjs/_esm5/internal/Subscription.js","../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../Subject":"../../../../node_modules/rxjs/_esm5/internal/Subject.js"}],"../../../../node_modules/rxjs/_esm5/internal/BehaviorSubject.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BehaviorSubject = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subject = require("./Subject");

var _ObjectUnsubscribedError = require("./util/ObjectUnsubscribedError");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */
var BehaviorSubject =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(BehaviorSubject, _super);

  function BehaviorSubject(_value) {
    var _this = _super.call(this) || this;

    _this._value = _value;
    return _this;
  }

  Object.defineProperty(BehaviorSubject.prototype, "value", {
    get: function () {
      return this.getValue();
    },
    enumerable: true,
    configurable: true
  });

  BehaviorSubject.prototype._subscribe = function (subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);

    if (subscription && !subscription.closed) {
      subscriber.next(this._value);
    }

    return subscription;
  };

  BehaviorSubject.prototype.getValue = function () {
    if (this.hasError) {
      throw this.thrownError;
    } else if (this.closed) {
      throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
    } else {
      return this._value;
    }
  };

  BehaviorSubject.prototype.next = function (value) {
    _super.prototype.next.call(this, this._value = value);
  };

  return BehaviorSubject;
}(_Subject.Subject);

exports.BehaviorSubject = BehaviorSubject;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","./Subject":"../../../../node_modules/rxjs/_esm5/internal/Subject.js","./util/ObjectUnsubscribedError":"../../../../node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js"}],"../../../../node_modules/rxjs/_esm5/internal/scheduler/Action.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Action = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscription = require("../Subscription");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
var Action =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(Action, _super);

  function Action(scheduler, work) {
    return _super.call(this) || this;
  }

  Action.prototype.schedule = function (state, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    return this;
  };

  return Action;
}(_Subscription.Subscription);

exports.Action = Action;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscription":"../../../../node_modules/rxjs/_esm5/internal/Subscription.js"}],"../../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsyncAction = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Action = require("./Action");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */
var AsyncAction =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(AsyncAction, _super);

  function AsyncAction(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;

    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }

  AsyncAction.prototype.schedule = function (state, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (this.closed) {
      return this;
    }

    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;

    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay);
    }

    this.pending = true;
    this.delay = delay;
    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
    return this;
  };

  AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    return setInterval(scheduler.flush.bind(scheduler, this), delay);
  };

  AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (delay !== null && this.delay === delay && this.pending === false) {
      return id;
    }

    clearInterval(id);
    return undefined;
  };

  AsyncAction.prototype.execute = function (state, delay) {
    if (this.closed) {
      return new Error('executing a cancelled action');
    }

    this.pending = false;

    var error = this._execute(state, delay);

    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };

  AsyncAction.prototype._execute = function (state, delay) {
    var errored = false;
    var errorValue = undefined;

    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = !!e && e || new Error(e);
    }

    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };

  AsyncAction.prototype._unsubscribe = function () {
    var id = this.id;
    var scheduler = this.scheduler;
    var actions = scheduler.actions;
    var index = actions.indexOf(this);
    this.work = null;
    this.state = null;
    this.pending = false;
    this.scheduler = null;

    if (index !== -1) {
      actions.splice(index, 1);
    }

    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, null);
    }

    this.delay = null;
  };

  return AsyncAction;
}(_Action.Action);

exports.AsyncAction = AsyncAction;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","./Action":"../../../../node_modules/rxjs/_esm5/internal/scheduler/Action.js"}],"../../../../node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QueueAction = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _AsyncAction = require("./AsyncAction");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
var QueueAction =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(QueueAction, _super);

  function QueueAction(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;

    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }

  QueueAction.prototype.schedule = function (state, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (delay > 0) {
      return _super.prototype.schedule.call(this, state, delay);
    }

    this.delay = delay;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };

  QueueAction.prototype.execute = function (state, delay) {
    return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
  };

  QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
    }

    return scheduler.flush(this);
  };

  return QueueAction;
}(_AsyncAction.AsyncAction);

exports.QueueAction = QueueAction;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","./AsyncAction":"../../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js"}],"../../../../node_modules/rxjs/_esm5/internal/Scheduler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scheduler = void 0;

var Scheduler =
/*@__PURE__*/
function () {
  function Scheduler(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }

    this.SchedulerAction = SchedulerAction;
    this.now = now;
  }

  Scheduler.prototype.schedule = function (work, delay, state) {
    if (delay === void 0) {
      delay = 0;
    }

    return new this.SchedulerAction(this, work).schedule(state, delay);
  };

  Scheduler.now = function () {
    return Date.now();
  };

  return Scheduler;
}();

exports.Scheduler = Scheduler;
},{}],"../../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsyncScheduler = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Scheduler = require("../Scheduler");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */
var AsyncScheduler =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(AsyncScheduler, _super);

  function AsyncScheduler(SchedulerAction, now) {
    if (now === void 0) {
      now = _Scheduler.Scheduler.now;
    }

    var _this = _super.call(this, SchedulerAction, function () {
      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
        return AsyncScheduler.delegate.now();
      } else {
        return now();
      }
    }) || this;

    _this.actions = [];
    _this.active = false;
    _this.scheduled = undefined;
    return _this;
  }

  AsyncScheduler.prototype.schedule = function (work, delay, state) {
    if (delay === void 0) {
      delay = 0;
    }

    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
      return AsyncScheduler.delegate.schedule(work, delay, state);
    } else {
      return _super.prototype.schedule.call(this, work, delay, state);
    }
  };

  AsyncScheduler.prototype.flush = function (action) {
    var actions = this.actions;

    if (this.active) {
      actions.push(action);
      return;
    }

    var error;
    this.active = true;

    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());

    this.active = false;

    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }

      throw error;
    }
  };

  return AsyncScheduler;
}(_Scheduler.Scheduler);

exports.AsyncScheduler = AsyncScheduler;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Scheduler":"../../../../node_modules/rxjs/_esm5/internal/Scheduler.js"}],"../../../../node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QueueScheduler = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _AsyncScheduler = require("./AsyncScheduler");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var QueueScheduler =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(QueueScheduler, _super);

  function QueueScheduler() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  return QueueScheduler;
}(_AsyncScheduler.AsyncScheduler);

exports.QueueScheduler = QueueScheduler;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","./AsyncScheduler":"../../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js"}],"../../../../node_modules/rxjs/_esm5/internal/scheduler/queue.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.queue = void 0;

var _QueueAction = require("./QueueAction");

var _QueueScheduler = require("./QueueScheduler");

/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */
var queue =
/*@__PURE__*/
new _QueueScheduler.QueueScheduler(_QueueAction.QueueAction);
exports.queue = queue;
},{"./QueueAction":"../../../../node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js","./QueueScheduler":"../../../../node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/empty.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.empty = empty;
exports.EMPTY = void 0;

var _Observable = require("../Observable");

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
var EMPTY =
/*@__PURE__*/
new _Observable.Observable(function (subscriber) {
  return subscriber.complete();
});
exports.EMPTY = EMPTY;

function empty(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}

function emptyScheduled(scheduler) {
  return new _Observable.Observable(function (subscriber) {
    return scheduler.schedule(function () {
      return subscriber.complete();
    });
  });
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js"}],"../../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isScheduler = isScheduler;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isScheduler(value) {
  return value && typeof value.schedule === 'function';
}
},{}],"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToArray.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.subscribeToArray = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var subscribeToArray = function (array) {
  return function (subscriber) {
    for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }

    subscriber.complete();
  };
};

exports.subscribeToArray = subscribeToArray;
},{}],"../../../../node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scheduleArray = scheduleArray;

var _Observable = require("../Observable");

var _Subscription = require("../Subscription");

/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
function scheduleArray(input, scheduler) {
  return new _Observable.Observable(function (subscriber) {
    var sub = new _Subscription.Subscription();
    var i = 0;
    sub.add(scheduler.schedule(function () {
      if (i === input.length) {
        subscriber.complete();
        return;
      }

      subscriber.next(input[i++]);

      if (!subscriber.closed) {
        sub.add(this.schedule());
      }
    }));
    return sub;
  });
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../Subscription":"../../../../node_modules/rxjs/_esm5/internal/Subscription.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/fromArray.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromArray = fromArray;

var _Observable = require("../Observable");

var _subscribeToArray = require("../util/subscribeToArray");

var _scheduleArray = require("../scheduled/scheduleArray");

/** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */
function fromArray(input, scheduler) {
  if (!scheduler) {
    return new _Observable.Observable((0, _subscribeToArray.subscribeToArray)(input));
  } else {
    return (0, _scheduleArray.scheduleArray)(input, scheduler);
  }
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../util/subscribeToArray":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToArray.js","../scheduled/scheduleArray":"../../../../node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/of.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.of = of;

var _isScheduler = require("../util/isScheduler");

var _fromArray = require("./fromArray");

var _scheduleArray = require("../scheduled/scheduleArray");

/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_scheduled_scheduleArray PURE_IMPORTS_END */
function of() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  var scheduler = args[args.length - 1];

  if ((0, _isScheduler.isScheduler)(scheduler)) {
    args.pop();
    return (0, _scheduleArray.scheduleArray)(args, scheduler);
  } else {
    return (0, _fromArray.fromArray)(args);
  }
}
},{"../util/isScheduler":"../../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js","./fromArray":"../../../../node_modules/rxjs/_esm5/internal/observable/fromArray.js","../scheduled/scheduleArray":"../../../../node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/throwError.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.throwError = throwError;

var _Observable = require("../Observable");

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
function throwError(error, scheduler) {
  if (!scheduler) {
    return new _Observable.Observable(function (subscriber) {
      return subscriber.error(error);
    });
  } else {
    return new _Observable.Observable(function (subscriber) {
      return scheduler.schedule(dispatch, 0, {
        error: error,
        subscriber: subscriber
      });
    });
  }
}

function dispatch(_a) {
  var error = _a.error,
      subscriber = _a.subscriber;
  subscriber.error(error);
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js"}],"../../../../node_modules/rxjs/_esm5/internal/Notification.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Notification = exports.NotificationKind = void 0;

var _empty = require("./observable/empty");

var _of = require("./observable/of");

var _throwError = require("./observable/throwError");

/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */
var NotificationKind;
/*@__PURE__*/

exports.NotificationKind = NotificationKind;

(function (NotificationKind) {
  NotificationKind["NEXT"] = "N";
  NotificationKind["ERROR"] = "E";
  NotificationKind["COMPLETE"] = "C";
})(NotificationKind || (exports.NotificationKind = NotificationKind = {}));

var Notification =
/*@__PURE__*/
function () {
  function Notification(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === 'N';
  }

  Notification.prototype.observe = function (observer) {
    switch (this.kind) {
      case 'N':
        return observer.next && observer.next(this.value);

      case 'E':
        return observer.error && observer.error(this.error);

      case 'C':
        return observer.complete && observer.complete();
    }
  };

  Notification.prototype.do = function (next, error, complete) {
    var kind = this.kind;

    switch (kind) {
      case 'N':
        return next && next(this.value);

      case 'E':
        return error && error(this.error);

      case 'C':
        return complete && complete();
    }
  };

  Notification.prototype.accept = function (nextOrObserver, error, complete) {
    if (nextOrObserver && typeof nextOrObserver.next === 'function') {
      return this.observe(nextOrObserver);
    } else {
      return this.do(nextOrObserver, error, complete);
    }
  };

  Notification.prototype.toObservable = function () {
    var kind = this.kind;

    switch (kind) {
      case 'N':
        return (0, _of.of)(this.value);

      case 'E':
        return (0, _throwError.throwError)(this.error);

      case 'C':
        return (0, _empty.empty)();
    }

    throw new Error('unexpected notification kind value');
  };

  Notification.createNext = function (value) {
    if (typeof value !== 'undefined') {
      return new Notification('N', value);
    }

    return Notification.undefinedValueNotification;
  };

  Notification.createError = function (err) {
    return new Notification('E', undefined, err);
  };

  Notification.createComplete = function () {
    return Notification.completeNotification;
  };

  Notification.completeNotification = new Notification('C');
  Notification.undefinedValueNotification = new Notification('N', undefined);
  return Notification;
}();

exports.Notification = Notification;
},{"./observable/empty":"../../../../node_modules/rxjs/_esm5/internal/observable/empty.js","./observable/of":"../../../../node_modules/rxjs/_esm5/internal/observable/of.js","./observable/throwError":"../../../../node_modules/rxjs/_esm5/internal/observable/throwError.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/observeOn.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.observeOn = observeOn;
exports.ObserveOnMessage = exports.ObserveOnSubscriber = exports.ObserveOnOperator = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

var _Notification = require("../Notification");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */
function observeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }

  return function observeOnOperatorFunction(source) {
    return source.lift(new ObserveOnOperator(scheduler, delay));
  };
}

var ObserveOnOperator =
/*@__PURE__*/
function () {
  function ObserveOnOperator(scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    this.scheduler = scheduler;
    this.delay = delay;
  }

  ObserveOnOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
  };

  return ObserveOnOperator;
}();

exports.ObserveOnOperator = ObserveOnOperator;

var ObserveOnSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(ObserveOnSubscriber, _super);

  function ObserveOnSubscriber(destination, scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    var _this = _super.call(this, destination) || this;

    _this.scheduler = scheduler;
    _this.delay = delay;
    return _this;
  }

  ObserveOnSubscriber.dispatch = function (arg) {
    var notification = arg.notification,
        destination = arg.destination;
    notification.observe(destination);
    this.unsubscribe();
  };

  ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
    var destination = this.destination;
    destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
  };

  ObserveOnSubscriber.prototype._next = function (value) {
    this.scheduleMessage(_Notification.Notification.createNext(value));
  };

  ObserveOnSubscriber.prototype._error = function (err) {
    this.scheduleMessage(_Notification.Notification.createError(err));
    this.unsubscribe();
  };

  ObserveOnSubscriber.prototype._complete = function () {
    this.scheduleMessage(_Notification.Notification.createComplete());
    this.unsubscribe();
  };

  return ObserveOnSubscriber;
}(_Subscriber.Subscriber);

exports.ObserveOnSubscriber = ObserveOnSubscriber;

var ObserveOnMessage =
/*@__PURE__*/
function () {
  function ObserveOnMessage(notification, destination) {
    this.notification = notification;
    this.destination = destination;
  }

  return ObserveOnMessage;
}();

exports.ObserveOnMessage = ObserveOnMessage;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../Notification":"../../../../node_modules/rxjs/_esm5/internal/Notification.js"}],"../../../../node_modules/rxjs/_esm5/internal/ReplaySubject.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReplaySubject = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subject = require("./Subject");

var _queue = require("./scheduler/queue");

var _Subscription = require("./Subscription");

var _observeOn = require("./operators/observeOn");

var _ObjectUnsubscribedError = require("./util/ObjectUnsubscribedError");

var _SubjectSubscription = require("./SubjectSubscription");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */
var ReplaySubject =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(ReplaySubject, _super);

  function ReplaySubject(bufferSize, windowTime, scheduler) {
    if (bufferSize === void 0) {
      bufferSize = Number.POSITIVE_INFINITY;
    }

    if (windowTime === void 0) {
      windowTime = Number.POSITIVE_INFINITY;
    }

    var _this = _super.call(this) || this;

    _this.scheduler = scheduler;
    _this._events = [];
    _this._infiniteTimeWindow = false;
    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
    _this._windowTime = windowTime < 1 ? 1 : windowTime;

    if (windowTime === Number.POSITIVE_INFINITY) {
      _this._infiniteTimeWindow = true;
      _this.next = _this.nextInfiniteTimeWindow;
    } else {
      _this.next = _this.nextTimeWindow;
    }

    return _this;
  }

  ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
    var _events = this._events;

    _events.push(value);

    if (_events.length > this._bufferSize) {
      _events.shift();
    }

    _super.prototype.next.call(this, value);
  };

  ReplaySubject.prototype.nextTimeWindow = function (value) {
    this._events.push(new ReplayEvent(this._getNow(), value));

    this._trimBufferThenGetEvents();

    _super.prototype.next.call(this, value);
  };

  ReplaySubject.prototype._subscribe = function (subscriber) {
    var _infiniteTimeWindow = this._infiniteTimeWindow;

    var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();

    var scheduler = this.scheduler;
    var len = _events.length;
    var subscription;

    if (this.closed) {
      throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
    } else if (this.isStopped || this.hasError) {
      subscription = _Subscription.Subscription.EMPTY;
    } else {
      this.observers.push(subscriber);
      subscription = new _SubjectSubscription.SubjectSubscription(this, subscriber);
    }

    if (scheduler) {
      subscriber.add(subscriber = new _observeOn.ObserveOnSubscriber(subscriber, scheduler));
    }

    if (_infiniteTimeWindow) {
      for (var i = 0; i < len && !subscriber.closed; i++) {
        subscriber.next(_events[i]);
      }
    } else {
      for (var i = 0; i < len && !subscriber.closed; i++) {
        subscriber.next(_events[i].value);
      }
    }

    if (this.hasError) {
      subscriber.error(this.thrownError);
    } else if (this.isStopped) {
      subscriber.complete();
    }

    return subscription;
  };

  ReplaySubject.prototype._getNow = function () {
    return (this.scheduler || _queue.queue).now();
  };

  ReplaySubject.prototype._trimBufferThenGetEvents = function () {
    var now = this._getNow();

    var _bufferSize = this._bufferSize;
    var _windowTime = this._windowTime;
    var _events = this._events;
    var eventsCount = _events.length;
    var spliceCount = 0;

    while (spliceCount < eventsCount) {
      if (now - _events[spliceCount].time < _windowTime) {
        break;
      }

      spliceCount++;
    }

    if (eventsCount > _bufferSize) {
      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
    }

    if (spliceCount > 0) {
      _events.splice(0, spliceCount);
    }

    return _events;
  };

  return ReplaySubject;
}(_Subject.Subject);

exports.ReplaySubject = ReplaySubject;

var ReplayEvent =
/*@__PURE__*/
function () {
  function ReplayEvent(time, value) {
    this.time = time;
    this.value = value;
  }

  return ReplayEvent;
}();
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","./Subject":"../../../../node_modules/rxjs/_esm5/internal/Subject.js","./scheduler/queue":"../../../../node_modules/rxjs/_esm5/internal/scheduler/queue.js","./Subscription":"../../../../node_modules/rxjs/_esm5/internal/Subscription.js","./operators/observeOn":"../../../../node_modules/rxjs/_esm5/internal/operators/observeOn.js","./util/ObjectUnsubscribedError":"../../../../node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js","./SubjectSubscription":"../../../../node_modules/rxjs/_esm5/internal/SubjectSubscription.js"}],"../../../../node_modules/rxjs/_esm5/internal/AsyncSubject.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsyncSubject = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subject = require("./Subject");

var _Subscription = require("./Subscription");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */
var AsyncSubject =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(AsyncSubject, _super);

  function AsyncSubject() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.value = null;
    _this.hasNext = false;
    _this.hasCompleted = false;
    return _this;
  }

  AsyncSubject.prototype._subscribe = function (subscriber) {
    if (this.hasError) {
      subscriber.error(this.thrownError);
      return _Subscription.Subscription.EMPTY;
    } else if (this.hasCompleted && this.hasNext) {
      subscriber.next(this.value);
      subscriber.complete();
      return _Subscription.Subscription.EMPTY;
    }

    return _super.prototype._subscribe.call(this, subscriber);
  };

  AsyncSubject.prototype.next = function (value) {
    if (!this.hasCompleted) {
      this.value = value;
      this.hasNext = true;
    }
  };

  AsyncSubject.prototype.error = function (error) {
    if (!this.hasCompleted) {
      _super.prototype.error.call(this, error);
    }
  };

  AsyncSubject.prototype.complete = function () {
    this.hasCompleted = true;

    if (this.hasNext) {
      _super.prototype.next.call(this, this.value);
    }

    _super.prototype.complete.call(this);
  };

  return AsyncSubject;
}(_Subject.Subject);

exports.AsyncSubject = AsyncSubject;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","./Subject":"../../../../node_modules/rxjs/_esm5/internal/Subject.js","./Subscription":"../../../../node_modules/rxjs/_esm5/internal/Subscription.js"}],"../../../../node_modules/rxjs/_esm5/internal/util/Immediate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Immediate = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var nextHandle = 1;
var tasksByHandle = {};

function runIfPresent(handle) {
  var cb = tasksByHandle[handle];

  if (cb) {
    cb();
  }
}

var Immediate = {
  setImmediate: function (cb) {
    var handle = nextHandle++;
    tasksByHandle[handle] = cb;
    Promise.resolve().then(function () {
      return runIfPresent(handle);
    });
    return handle;
  },
  clearImmediate: function (handle) {
    delete tasksByHandle[handle];
  }
};
exports.Immediate = Immediate;
},{}],"../../../../node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsapAction = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Immediate = require("../util/Immediate");

var _AsyncAction = require("./AsyncAction");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */
var AsapAction =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(AsapAction, _super);

  function AsapAction(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;

    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }

  AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (delay !== null && delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
    }

    scheduler.actions.push(this);
    return scheduler.scheduled || (scheduler.scheduled = _Immediate.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
  };

  AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
    }

    if (scheduler.actions.length === 0) {
      _Immediate.Immediate.clearImmediate(id);

      scheduler.scheduled = undefined;
    }

    return undefined;
  };

  return AsapAction;
}(_AsyncAction.AsyncAction);

exports.AsapAction = AsapAction;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../util/Immediate":"../../../../node_modules/rxjs/_esm5/internal/util/Immediate.js","./AsyncAction":"../../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js"}],"../../../../node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsapScheduler = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _AsyncScheduler = require("./AsyncScheduler");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var AsapScheduler =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(AsapScheduler, _super);

  function AsapScheduler() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  AsapScheduler.prototype.flush = function (action) {
    this.active = true;
    this.scheduled = undefined;
    var actions = this.actions;
    var error;
    var index = -1;
    var count = actions.length;
    action = action || actions.shift();

    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (++index < count && (action = actions.shift()));

    this.active = false;

    if (error) {
      while (++index < count && (action = actions.shift())) {
        action.unsubscribe();
      }

      throw error;
    }
  };

  return AsapScheduler;
}(_AsyncScheduler.AsyncScheduler);

exports.AsapScheduler = AsapScheduler;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","./AsyncScheduler":"../../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js"}],"../../../../node_modules/rxjs/_esm5/internal/scheduler/asap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.asap = void 0;

var _AsapAction = require("./AsapAction");

var _AsapScheduler = require("./AsapScheduler");

/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */
var asap =
/*@__PURE__*/
new _AsapScheduler.AsapScheduler(_AsapAction.AsapAction);
exports.asap = asap;
},{"./AsapAction":"../../../../node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js","./AsapScheduler":"../../../../node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js"}],"../../../../node_modules/rxjs/_esm5/internal/scheduler/async.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.async = void 0;

var _AsyncAction = require("./AsyncAction");

var _AsyncScheduler = require("./AsyncScheduler");

/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
var async =
/*@__PURE__*/
new _AsyncScheduler.AsyncScheduler(_AsyncAction.AsyncAction);
exports.async = async;
},{"./AsyncAction":"../../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js","./AsyncScheduler":"../../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js"}],"../../../../node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameAction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnimationFrameAction = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _AsyncAction = require("./AsyncAction");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
var AnimationFrameAction =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(AnimationFrameAction, _super);

  function AnimationFrameAction(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;

    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }

  AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (delay !== null && delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
    }

    scheduler.actions.push(this);
    return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () {
      return scheduler.flush(null);
    }));
  };

  AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
    }

    if (scheduler.actions.length === 0) {
      cancelAnimationFrame(id);
      scheduler.scheduled = undefined;
    }

    return undefined;
  };

  return AnimationFrameAction;
}(_AsyncAction.AsyncAction);

exports.AnimationFrameAction = AnimationFrameAction;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","./AsyncAction":"../../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js"}],"../../../../node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameScheduler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnimationFrameScheduler = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _AsyncScheduler = require("./AsyncScheduler");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var AnimationFrameScheduler =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(AnimationFrameScheduler, _super);

  function AnimationFrameScheduler() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  AnimationFrameScheduler.prototype.flush = function (action) {
    this.active = true;
    this.scheduled = undefined;
    var actions = this.actions;
    var error;
    var index = -1;
    var count = actions.length;
    action = action || actions.shift();

    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (++index < count && (action = actions.shift()));

    this.active = false;

    if (error) {
      while (++index < count && (action = actions.shift())) {
        action.unsubscribe();
      }

      throw error;
    }
  };

  return AnimationFrameScheduler;
}(_AsyncScheduler.AsyncScheduler);

exports.AnimationFrameScheduler = AnimationFrameScheduler;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","./AsyncScheduler":"../../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js"}],"../../../../node_modules/rxjs/_esm5/internal/scheduler/animationFrame.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.animationFrame = void 0;

var _AnimationFrameAction = require("./AnimationFrameAction");

var _AnimationFrameScheduler = require("./AnimationFrameScheduler");

/** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */
var animationFrame =
/*@__PURE__*/
new _AnimationFrameScheduler.AnimationFrameScheduler(_AnimationFrameAction.AnimationFrameAction);
exports.animationFrame = animationFrame;
},{"./AnimationFrameAction":"../../../../node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameAction.js","./AnimationFrameScheduler":"../../../../node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameScheduler.js"}],"../../../../node_modules/rxjs/_esm5/internal/scheduler/VirtualTimeScheduler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VirtualAction = exports.VirtualTimeScheduler = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _AsyncAction = require("./AsyncAction");

var _AsyncScheduler = require("./AsyncScheduler");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
var VirtualTimeScheduler =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(VirtualTimeScheduler, _super);

  function VirtualTimeScheduler(SchedulerAction, maxFrames) {
    if (SchedulerAction === void 0) {
      SchedulerAction = VirtualAction;
    }

    if (maxFrames === void 0) {
      maxFrames = Number.POSITIVE_INFINITY;
    }

    var _this = _super.call(this, SchedulerAction, function () {
      return _this.frame;
    }) || this;

    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }

  VirtualTimeScheduler.prototype.flush = function () {
    var _a = this,
        actions = _a.actions,
        maxFrames = _a.maxFrames;

    var error, action;

    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;

      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }

    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }

      throw error;
    }
  };

  VirtualTimeScheduler.frameTimeFactor = 10;
  return VirtualTimeScheduler;
}(_AsyncScheduler.AsyncScheduler);

exports.VirtualTimeScheduler = VirtualTimeScheduler;

var VirtualAction =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(VirtualAction, _super);

  function VirtualAction(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }

    var _this = _super.call(this, scheduler, work) || this;

    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }

  VirtualAction.prototype.schedule = function (state, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (!this.id) {
      return _super.prototype.schedule.call(this, state, delay);
    }

    this.active = false;
    var action = new VirtualAction(this.scheduler, this.work);
    this.add(action);
    return action.schedule(state, delay);
  };

  VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    this.delay = scheduler.frame + delay;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction.sortActions);
    return true;
  };

  VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    return undefined;
  };

  VirtualAction.prototype._execute = function (state, delay) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay);
    }
  };

  VirtualAction.sortActions = function (a, b) {
    if (a.delay === b.delay) {
      if (a.index === b.index) {
        return 0;
      } else if (a.index > b.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a.delay > b.delay) {
      return 1;
    } else {
      return -1;
    }
  };

  return VirtualAction;
}(_AsyncAction.AsyncAction);

exports.VirtualAction = VirtualAction;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","./AsyncAction":"../../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js","./AsyncScheduler":"../../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js"}],"../../../../node_modules/rxjs/_esm5/internal/util/identity.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.identity = identity;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function identity(x) {
  return x;
}
},{}],"../../../../node_modules/rxjs/_esm5/internal/util/isObservable.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isObservable = isObservable;

var _Observable = require("../Observable");

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
function isObservable(obj) {
  return !!obj && (obj instanceof _Observable.Observable || typeof obj.lift === 'function' && typeof obj.subscribe === 'function');
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js"}],"../../../../node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArgumentOutOfRangeError = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var ArgumentOutOfRangeErrorImpl =
/*@__PURE__*/
function () {
  function ArgumentOutOfRangeErrorImpl() {
    Error.call(this);
    this.message = 'argument out of range';
    this.name = 'ArgumentOutOfRangeError';
    return this;
  }

  ArgumentOutOfRangeErrorImpl.prototype =
  /*@__PURE__*/
  Object.create(Error.prototype);
  return ArgumentOutOfRangeErrorImpl;
}();

var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;
},{}],"../../../../node_modules/rxjs/_esm5/internal/util/EmptyError.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EmptyError = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var EmptyErrorImpl =
/*@__PURE__*/
function () {
  function EmptyErrorImpl() {
    Error.call(this);
    this.message = 'no elements in sequence';
    this.name = 'EmptyError';
    return this;
  }

  EmptyErrorImpl.prototype =
  /*@__PURE__*/
  Object.create(Error.prototype);
  return EmptyErrorImpl;
}();

var EmptyError = EmptyErrorImpl;
exports.EmptyError = EmptyError;
},{}],"../../../../node_modules/rxjs/_esm5/internal/util/TimeoutError.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TimeoutError = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var TimeoutErrorImpl =
/*@__PURE__*/
function () {
  function TimeoutErrorImpl() {
    Error.call(this);
    this.message = 'Timeout has occurred';
    this.name = 'TimeoutError';
    return this;
  }

  TimeoutErrorImpl.prototype =
  /*@__PURE__*/
  Object.create(Error.prototype);
  return TimeoutErrorImpl;
}();

var TimeoutError = TimeoutErrorImpl;
exports.TimeoutError = TimeoutError;
},{}],"../../../../node_modules/rxjs/_esm5/internal/operators/map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.map = map;
exports.MapOperator = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function map(project, thisArg) {
  return function mapOperation(source) {
    if (typeof project !== 'function') {
      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
    }

    return source.lift(new MapOperator(project, thisArg));
  };
}

var MapOperator =
/*@__PURE__*/
function () {
  function MapOperator(project, thisArg) {
    this.project = project;
    this.thisArg = thisArg;
  }

  MapOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
  };

  return MapOperator;
}();

exports.MapOperator = MapOperator;

var MapSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(MapSubscriber, _super);

  function MapSubscriber(destination, project, thisArg) {
    var _this = _super.call(this, destination) || this;

    _this.project = project;
    _this.count = 0;
    _this.thisArg = thisArg || _this;
    return _this;
  }

  MapSubscriber.prototype._next = function (value) {
    var result;

    try {
      result = this.project.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    this.destination.next(result);
  };

  return MapSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/bindCallback.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bindCallback = bindCallback;

var _Observable = require("../Observable");

var _AsyncSubject = require("../AsyncSubject");

var _map = require("../operators/map");

var _canReportError = require("../util/canReportError");

var _isArray = require("../util/isArray");

var _isScheduler = require("../util/isScheduler");

/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isArray,_util_isScheduler PURE_IMPORTS_END */
function bindCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if ((0, _isScheduler.isScheduler)(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function () {
        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe((0, _map.map)(function (args) {
          return (0, _isArray.isArray)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
        }));
      };
    }
  }

  return function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    var context = this;
    var subject;
    var params = {
      context: context,
      subject: subject,
      callbackFunc: callbackFunc,
      scheduler: scheduler
    };
    return new _Observable.Observable(function (subscriber) {
      if (!scheduler) {
        if (!subject) {
          subject = new _AsyncSubject.AsyncSubject();

          var handler = function () {
            var innerArgs = [];

            for (var _i = 0; _i < arguments.length; _i++) {
              innerArgs[_i] = arguments[_i];
            }

            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };

          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            if ((0, _canReportError.canReportError)(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }

        return subject.subscribe(subscriber);
      } else {
        var state = {
          args: args,
          subscriber: subscriber,
          params: params
        };
        return scheduler.schedule(dispatch, 0, state);
      }
    });
  };
}

function dispatch(state) {
  var _this = this;

  var self = this;
  var args = state.args,
      subscriber = state.subscriber,
      params = state.params;
  var callbackFunc = params.callbackFunc,
      context = params.context,
      scheduler = params.scheduler;
  var subject = params.subject;

  if (!subject) {
    subject = params.subject = new _AsyncSubject.AsyncSubject();

    var handler = function () {
      var innerArgs = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        innerArgs[_i] = arguments[_i];
      }

      var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;

      _this.add(scheduler.schedule(dispatchNext, 0, {
        value: value,
        subject: subject
      }));
    };

    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      subject.error(err);
    }
  }

  this.add(subject.subscribe(subscriber));
}

function dispatchNext(state) {
  var value = state.value,
      subject = state.subject;
  subject.next(value);
  subject.complete();
}

function dispatchError(state) {
  var err = state.err,
      subject = state.subject;
  subject.error(err);
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../AsyncSubject":"../../../../node_modules/rxjs/_esm5/internal/AsyncSubject.js","../operators/map":"../../../../node_modules/rxjs/_esm5/internal/operators/map.js","../util/canReportError":"../../../../node_modules/rxjs/_esm5/internal/util/canReportError.js","../util/isArray":"../../../../node_modules/rxjs/_esm5/internal/util/isArray.js","../util/isScheduler":"../../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/bindNodeCallback.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bindNodeCallback = bindNodeCallback;

var _Observable = require("../Observable");

var _AsyncSubject = require("../AsyncSubject");

var _map = require("../operators/map");

var _canReportError = require("../util/canReportError");

var _isScheduler = require("../util/isScheduler");

var _isArray = require("../util/isArray");

/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isScheduler,_util_isArray PURE_IMPORTS_END */
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if ((0, _isScheduler.isScheduler)(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function () {
        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe((0, _map.map)(function (args) {
          return (0, _isArray.isArray)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
        }));
      };
    }
  }

  return function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    var params = {
      subject: undefined,
      args: args,
      callbackFunc: callbackFunc,
      scheduler: scheduler,
      context: this
    };
    return new _Observable.Observable(function (subscriber) {
      var context = params.context;
      var subject = params.subject;

      if (!scheduler) {
        if (!subject) {
          subject = params.subject = new _AsyncSubject.AsyncSubject();

          var handler = function () {
            var innerArgs = [];

            for (var _i = 0; _i < arguments.length; _i++) {
              innerArgs[_i] = arguments[_i];
            }

            var err = innerArgs.shift();

            if (err) {
              subject.error(err);
              return;
            }

            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };

          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            if ((0, _canReportError.canReportError)(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }

        return subject.subscribe(subscriber);
      } else {
        return scheduler.schedule(dispatch, 0, {
          params: params,
          subscriber: subscriber,
          context: context
        });
      }
    });
  };
}

function dispatch(state) {
  var _this = this;

  var params = state.params,
      subscriber = state.subscriber,
      context = state.context;
  var callbackFunc = params.callbackFunc,
      args = params.args,
      scheduler = params.scheduler;
  var subject = params.subject;

  if (!subject) {
    subject = params.subject = new _AsyncSubject.AsyncSubject();

    var handler = function () {
      var innerArgs = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        innerArgs[_i] = arguments[_i];
      }

      var err = innerArgs.shift();

      if (err) {
        _this.add(scheduler.schedule(dispatchError, 0, {
          err: err,
          subject: subject
        }));
      } else {
        var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;

        _this.add(scheduler.schedule(dispatchNext, 0, {
          value: value,
          subject: subject
        }));
      }
    };

    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      this.add(scheduler.schedule(dispatchError, 0, {
        err: err,
        subject: subject
      }));
    }
  }

  this.add(subject.subscribe(subscriber));
}

function dispatchNext(arg) {
  var value = arg.value,
      subject = arg.subject;
  subject.next(value);
  subject.complete();
}

function dispatchError(arg) {
  var err = arg.err,
      subject = arg.subject;
  subject.error(err);
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../AsyncSubject":"../../../../node_modules/rxjs/_esm5/internal/AsyncSubject.js","../operators/map":"../../../../node_modules/rxjs/_esm5/internal/operators/map.js","../util/canReportError":"../../../../node_modules/rxjs/_esm5/internal/util/canReportError.js","../util/isScheduler":"../../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js","../util/isArray":"../../../../node_modules/rxjs/_esm5/internal/util/isArray.js"}],"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OuterSubscriber = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("./Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var OuterSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(OuterSubscriber, _super);

  function OuterSubscriber() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  };

  OuterSubscriber.prototype.notifyError = function (error, innerSub) {
    this.destination.error(error);
  };

  OuterSubscriber.prototype.notifyComplete = function (innerSub) {
    this.destination.complete();
  };

  return OuterSubscriber;
}(_Subscriber.Subscriber);

exports.OuterSubscriber = OuterSubscriber;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","./Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/InnerSubscriber.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InnerSubscriber = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("./Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var InnerSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(InnerSubscriber, _super);

  function InnerSubscriber(parent, outerValue, outerIndex) {
    var _this = _super.call(this) || this;

    _this.parent = parent;
    _this.outerValue = outerValue;
    _this.outerIndex = outerIndex;
    _this.index = 0;
    return _this;
  }

  InnerSubscriber.prototype._next = function (value) {
    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
  };

  InnerSubscriber.prototype._error = function (error) {
    this.parent.notifyError(error, this);
    this.unsubscribe();
  };

  InnerSubscriber.prototype._complete = function () {
    this.parent.notifyComplete(this);
    this.unsubscribe();
  };

  return InnerSubscriber;
}(_Subscriber.Subscriber);

exports.InnerSubscriber = InnerSubscriber;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","./Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.subscribeToPromise = void 0;

var _hostReportError = require("./hostReportError");

/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */
var subscribeToPromise = function (promise) {
  return function (subscriber) {
    promise.then(function (value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function (err) {
      return subscriber.error(err);
    }).then(null, _hostReportError.hostReportError);
    return subscriber;
  };
};

exports.subscribeToPromise = subscribeToPromise;
},{"./hostReportError":"../../../../node_modules/rxjs/_esm5/internal/util/hostReportError.js"}],"../../../../node_modules/rxjs/_esm5/internal/symbol/iterator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSymbolIterator = getSymbolIterator;
exports.$$iterator = exports.iterator = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function getSymbolIterator() {
  if (typeof Symbol !== 'function' || !Symbol.iterator) {
    return '@@iterator';
  }

  return Symbol.iterator;
}

var iterator =
/*@__PURE__*/
getSymbolIterator();
exports.iterator = iterator;
var $$iterator = iterator;
exports.$$iterator = $$iterator;
},{}],"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.subscribeToIterable = void 0;

var _iterator = require("../symbol/iterator");

/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
var subscribeToIterable = function (iterable) {
  return function (subscriber) {
    var iterator = iterable[_iterator.iterator]();

    do {
      var item = iterator.next();

      if (item.done) {
        subscriber.complete();
        break;
      }

      subscriber.next(item.value);

      if (subscriber.closed) {
        break;
      }
    } while (true);

    if (typeof iterator.return === 'function') {
      subscriber.add(function () {
        if (iterator.return) {
          iterator.return();
        }
      });
    }

    return subscriber;
  };
};

exports.subscribeToIterable = subscribeToIterable;
},{"../symbol/iterator":"../../../../node_modules/rxjs/_esm5/internal/symbol/iterator.js"}],"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.subscribeToObservable = void 0;

var _observable = require("../symbol/observable");

/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
var subscribeToObservable = function (obj) {
  return function (subscriber) {
    var obs = obj[_observable.observable]();

    if (typeof obs.subscribe !== 'function') {
      throw new TypeError('Provided object does not correctly implement Symbol.observable');
    } else {
      return obs.subscribe(subscriber);
    }
  };
};

exports.subscribeToObservable = subscribeToObservable;
},{"../symbol/observable":"../../../../node_modules/rxjs/_esm5/internal/symbol/observable.js"}],"../../../../node_modules/rxjs/_esm5/internal/util/isArrayLike.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isArrayLike = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArrayLike = function (x) {
  return x && typeof x.length === 'number' && typeof x !== 'function';
};

exports.isArrayLike = isArrayLike;
},{}],"../../../../node_modules/rxjs/_esm5/internal/util/isPromise.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPromise = isPromise;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isPromise(value) {
  return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
},{}],"../../../../node_modules/rxjs/_esm5/internal/util/subscribeTo.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.subscribeTo = void 0;

var _subscribeToArray = require("./subscribeToArray");

var _subscribeToPromise = require("./subscribeToPromise");

var _subscribeToIterable = require("./subscribeToIterable");

var _subscribeToObservable = require("./subscribeToObservable");

var _isArrayLike = require("./isArrayLike");

var _isPromise = require("./isPromise");

var _isObject = require("./isObject");

var _iterator = require("../symbol/iterator");

var _observable = require("../symbol/observable");

/** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */
var subscribeTo = function (result) {
  if (!!result && typeof result[_observable.observable] === 'function') {
    return (0, _subscribeToObservable.subscribeToObservable)(result);
  } else if ((0, _isArrayLike.isArrayLike)(result)) {
    return (0, _subscribeToArray.subscribeToArray)(result);
  } else if ((0, _isPromise.isPromise)(result)) {
    return (0, _subscribeToPromise.subscribeToPromise)(result);
  } else if (!!result && typeof result[_iterator.iterator] === 'function') {
    return (0, _subscribeToIterable.subscribeToIterable)(result);
  } else {
    var value = (0, _isObject.isObject)(result) ? 'an invalid object' : "'" + result + "'";
    var msg = "You provided " + value + " where a stream was expected." + ' You can provide an Observable, Promise, Array, or Iterable.';
    throw new TypeError(msg);
  }
};

exports.subscribeTo = subscribeTo;
},{"./subscribeToArray":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToArray.js","./subscribeToPromise":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js","./subscribeToIterable":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js","./subscribeToObservable":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js","./isArrayLike":"../../../../node_modules/rxjs/_esm5/internal/util/isArrayLike.js","./isPromise":"../../../../node_modules/rxjs/_esm5/internal/util/isPromise.js","./isObject":"../../../../node_modules/rxjs/_esm5/internal/util/isObject.js","../symbol/iterator":"../../../../node_modules/rxjs/_esm5/internal/symbol/iterator.js","../symbol/observable":"../../../../node_modules/rxjs/_esm5/internal/symbol/observable.js"}],"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.subscribeToResult = subscribeToResult;

var _InnerSubscriber = require("../InnerSubscriber");

var _subscribeTo = require("./subscribeTo");

var _Observable = require("../Observable");

/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo,_Observable PURE_IMPORTS_END */
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
  if (destination === void 0) {
    destination = new _InnerSubscriber.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
  }

  if (destination.closed) {
    return undefined;
  }

  if (result instanceof _Observable.Observable) {
    return result.subscribe(destination);
  }

  return (0, _subscribeTo.subscribeTo)(result)(destination);
}
},{"../InnerSubscriber":"../../../../node_modules/rxjs/_esm5/internal/InnerSubscriber.js","./subscribeTo":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeTo.js","../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/combineLatest.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.combineLatest = combineLatest;
exports.CombineLatestSubscriber = exports.CombineLatestOperator = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _isScheduler = require("../util/isScheduler");

var _isArray = require("../util/isArray");

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

var _fromArray = require("./fromArray");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */
var NONE = {};

function combineLatest() {
  var observables = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }

  var resultSelector = null;
  var scheduler = null;

  if ((0, _isScheduler.isScheduler)(observables[observables.length - 1])) {
    scheduler = observables.pop();
  }

  if (typeof observables[observables.length - 1] === 'function') {
    resultSelector = observables.pop();
  }

  if (observables.length === 1 && (0, _isArray.isArray)(observables[0])) {
    observables = observables[0];
  }

  return (0, _fromArray.fromArray)(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}

var CombineLatestOperator =
/*@__PURE__*/
function () {
  function CombineLatestOperator(resultSelector) {
    this.resultSelector = resultSelector;
  }

  CombineLatestOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
  };

  return CombineLatestOperator;
}();

exports.CombineLatestOperator = CombineLatestOperator;

var CombineLatestSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(CombineLatestSubscriber, _super);

  function CombineLatestSubscriber(destination, resultSelector) {
    var _this = _super.call(this, destination) || this;

    _this.resultSelector = resultSelector;
    _this.active = 0;
    _this.values = [];
    _this.observables = [];
    return _this;
  }

  CombineLatestSubscriber.prototype._next = function (observable) {
    this.values.push(NONE);
    this.observables.push(observable);
  };

  CombineLatestSubscriber.prototype._complete = function () {
    var observables = this.observables;
    var len = observables.length;

    if (len === 0) {
      this.destination.complete();
    } else {
      this.active = len;
      this.toRespond = len;

      for (var i = 0; i < len; i++) {
        var observable = observables[i];
        this.add((0, _subscribeToResult.subscribeToResult)(this, observable, observable, i));
      }
    }
  };

  CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
    if ((this.active -= 1) === 0) {
      this.destination.complete();
    }
  };

  CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    var values = this.values;
    var oldVal = values[outerIndex];
    var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
    values[outerIndex] = innerValue;

    if (toRespond === 0) {
      if (this.resultSelector) {
        this._tryResultSelector(values);
      } else {
        this.destination.next(values.slice());
      }
    }
  };

  CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
    var result;

    try {
      result = this.resultSelector.apply(this, values);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    this.destination.next(result);
  };

  return CombineLatestSubscriber;
}(_OuterSubscriber.OuterSubscriber);

exports.CombineLatestSubscriber = CombineLatestSubscriber;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../util/isScheduler":"../../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js","../util/isArray":"../../../../node_modules/rxjs/_esm5/internal/util/isArray.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js","./fromArray":"../../../../node_modules/rxjs/_esm5/internal/observable/fromArray.js"}],"../../../../node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scheduleObservable = scheduleObservable;

var _Observable = require("../Observable");

var _Subscription = require("../Subscription");

var _observable = require("../symbol/observable");

/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable PURE_IMPORTS_END */
function scheduleObservable(input, scheduler) {
  return new _Observable.Observable(function (subscriber) {
    var sub = new _Subscription.Subscription();
    sub.add(scheduler.schedule(function () {
      var observable = input[_observable.observable]();

      sub.add(observable.subscribe({
        next: function (value) {
          sub.add(scheduler.schedule(function () {
            return subscriber.next(value);
          }));
        },
        error: function (err) {
          sub.add(scheduler.schedule(function () {
            return subscriber.error(err);
          }));
        },
        complete: function () {
          sub.add(scheduler.schedule(function () {
            return subscriber.complete();
          }));
        }
      }));
    }));
    return sub;
  });
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../Subscription":"../../../../node_modules/rxjs/_esm5/internal/Subscription.js","../symbol/observable":"../../../../node_modules/rxjs/_esm5/internal/symbol/observable.js"}],"../../../../node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.schedulePromise = schedulePromise;

var _Observable = require("../Observable");

var _Subscription = require("../Subscription");

/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
function schedulePromise(input, scheduler) {
  return new _Observable.Observable(function (subscriber) {
    var sub = new _Subscription.Subscription();
    sub.add(scheduler.schedule(function () {
      return input.then(function (value) {
        sub.add(scheduler.schedule(function () {
          subscriber.next(value);
          sub.add(scheduler.schedule(function () {
            return subscriber.complete();
          }));
        }));
      }, function (err) {
        sub.add(scheduler.schedule(function () {
          return subscriber.error(err);
        }));
      });
    }));
    return sub;
  });
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../Subscription":"../../../../node_modules/rxjs/_esm5/internal/Subscription.js"}],"../../../../node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scheduleIterable = scheduleIterable;

var _Observable = require("../Observable");

var _Subscription = require("../Subscription");

var _iterator = require("../symbol/iterator");

/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator PURE_IMPORTS_END */
function scheduleIterable(input, scheduler) {
  if (!input) {
    throw new Error('Iterable cannot be null');
  }

  return new _Observable.Observable(function (subscriber) {
    var sub = new _Subscription.Subscription();
    var iterator;
    sub.add(function () {
      if (iterator && typeof iterator.return === 'function') {
        iterator.return();
      }
    });
    sub.add(scheduler.schedule(function () {
      iterator = input[_iterator.iterator]();
      sub.add(scheduler.schedule(function () {
        if (subscriber.closed) {
          return;
        }

        var value;
        var done;

        try {
          var result = iterator.next();
          value = result.value;
          done = result.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }

        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
          this.schedule();
        }
      }));
    }));
    return sub;
  });
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../Subscription":"../../../../node_modules/rxjs/_esm5/internal/Subscription.js","../symbol/iterator":"../../../../node_modules/rxjs/_esm5/internal/symbol/iterator.js"}],"../../../../node_modules/rxjs/_esm5/internal/util/isInteropObservable.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isInteropObservable = isInteropObservable;

var _observable = require("../symbol/observable");

/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
function isInteropObservable(input) {
  return input && typeof input[_observable.observable] === 'function';
}
},{"../symbol/observable":"../../../../node_modules/rxjs/_esm5/internal/symbol/observable.js"}],"../../../../node_modules/rxjs/_esm5/internal/util/isIterable.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isIterable = isIterable;

var _iterator = require("../symbol/iterator");

/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
function isIterable(input) {
  return input && typeof input[_iterator.iterator] === 'function';
}
},{"../symbol/iterator":"../../../../node_modules/rxjs/_esm5/internal/symbol/iterator.js"}],"../../../../node_modules/rxjs/_esm5/internal/scheduled/scheduled.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scheduled = scheduled;

var _scheduleObservable = require("./scheduleObservable");

var _schedulePromise = require("./schedulePromise");

var _scheduleArray = require("./scheduleArray");

var _scheduleIterable = require("./scheduleIterable");

var _isInteropObservable = require("../util/isInteropObservable");

var _isPromise = require("../util/isPromise");

var _isArrayLike = require("../util/isArrayLike");

var _isIterable = require("../util/isIterable");

/** PURE_IMPORTS_START _scheduleObservable,_schedulePromise,_scheduleArray,_scheduleIterable,_util_isInteropObservable,_util_isPromise,_util_isArrayLike,_util_isIterable PURE_IMPORTS_END */
function scheduled(input, scheduler) {
  if (input != null) {
    if ((0, _isInteropObservable.isInteropObservable)(input)) {
      return (0, _scheduleObservable.scheduleObservable)(input, scheduler);
    } else if ((0, _isPromise.isPromise)(input)) {
      return (0, _schedulePromise.schedulePromise)(input, scheduler);
    } else if ((0, _isArrayLike.isArrayLike)(input)) {
      return (0, _scheduleArray.scheduleArray)(input, scheduler);
    } else if ((0, _isIterable.isIterable)(input) || typeof input === 'string') {
      return (0, _scheduleIterable.scheduleIterable)(input, scheduler);
    }
  }

  throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}
},{"./scheduleObservable":"../../../../node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js","./schedulePromise":"../../../../node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js","./scheduleArray":"../../../../node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js","./scheduleIterable":"../../../../node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js","../util/isInteropObservable":"../../../../node_modules/rxjs/_esm5/internal/util/isInteropObservable.js","../util/isPromise":"../../../../node_modules/rxjs/_esm5/internal/util/isPromise.js","../util/isArrayLike":"../../../../node_modules/rxjs/_esm5/internal/util/isArrayLike.js","../util/isIterable":"../../../../node_modules/rxjs/_esm5/internal/util/isIterable.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/from.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.from = from;

var _Observable = require("../Observable");

var _subscribeTo = require("../util/subscribeTo");

var _scheduled = require("../scheduled/scheduled");

/** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */
function from(input, scheduler) {
  if (!scheduler) {
    if (input instanceof _Observable.Observable) {
      return input;
    }

    return new _Observable.Observable((0, _subscribeTo.subscribeTo)(input));
  } else {
    return (0, _scheduled.scheduled)(input, scheduler);
  }
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../util/subscribeTo":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeTo.js","../scheduled/scheduled":"../../../../node_modules/rxjs/_esm5/internal/scheduled/scheduled.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/mergeMap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeMap = mergeMap;
exports.MergeMapSubscriber = exports.MergeMapOperator = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _subscribeToResult = require("../util/subscribeToResult");

var _OuterSubscriber = require("../OuterSubscriber");

var _InnerSubscriber = require("../InnerSubscriber");

var _map = require("./map");

var _from = require("../observable/from");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber,_map,_observable_from PURE_IMPORTS_END */
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }

  if (typeof resultSelector === 'function') {
    return function (source) {
      return source.pipe(mergeMap(function (a, i) {
        return (0, _from.from)(project(a, i)).pipe((0, _map.map)(function (b, ii) {
          return resultSelector(a, b, i, ii);
        }));
      }, concurrent));
    };
  } else if (typeof resultSelector === 'number') {
    concurrent = resultSelector;
  }

  return function (source) {
    return source.lift(new MergeMapOperator(project, concurrent));
  };
}

var MergeMapOperator =
/*@__PURE__*/
function () {
  function MergeMapOperator(project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }

    this.project = project;
    this.concurrent = concurrent;
  }

  MergeMapOperator.prototype.call = function (observer, source) {
    return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
  };

  return MergeMapOperator;
}();

exports.MergeMapOperator = MergeMapOperator;

var MergeMapSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(MergeMapSubscriber, _super);

  function MergeMapSubscriber(destination, project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }

    var _this = _super.call(this, destination) || this;

    _this.project = project;
    _this.concurrent = concurrent;
    _this.hasCompleted = false;
    _this.buffer = [];
    _this.active = 0;
    _this.index = 0;
    return _this;
  }

  MergeMapSubscriber.prototype._next = function (value) {
    if (this.active < this.concurrent) {
      this._tryNext(value);
    } else {
      this.buffer.push(value);
    }
  };

  MergeMapSubscriber.prototype._tryNext = function (value) {
    var result;
    var index = this.index++;

    try {
      result = this.project(value, index);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    this.active++;

    this._innerSub(result, value, index);
  };

  MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
    var innerSubscriber = new _InnerSubscriber.InnerSubscriber(this, undefined, undefined);
    var destination = this.destination;
    destination.add(innerSubscriber);
    (0, _subscribeToResult.subscribeToResult)(this, ish, value, index, innerSubscriber);
  };

  MergeMapSubscriber.prototype._complete = function () {
    this.hasCompleted = true;

    if (this.active === 0 && this.buffer.length === 0) {
      this.destination.complete();
    }

    this.unsubscribe();
  };

  MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  };

  MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
    var buffer = this.buffer;
    this.remove(innerSub);
    this.active--;

    if (buffer.length > 0) {
      this._next(buffer.shift());
    } else if (this.active === 0 && this.hasCompleted) {
      this.destination.complete();
    }
  };

  return MergeMapSubscriber;
}(_OuterSubscriber.OuterSubscriber);

exports.MergeMapSubscriber = MergeMapSubscriber;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../InnerSubscriber":"../../../../node_modules/rxjs/_esm5/internal/InnerSubscriber.js","./map":"../../../../node_modules/rxjs/_esm5/internal/operators/map.js","../observable/from":"../../../../node_modules/rxjs/_esm5/internal/observable/from.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/mergeAll.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeAll = mergeAll;

var _mergeMap = require("./mergeMap");

var _identity = require("../util/identity");

/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }

  return (0, _mergeMap.mergeMap)(_identity.identity, concurrent);
}
},{"./mergeMap":"../../../../node_modules/rxjs/_esm5/internal/operators/mergeMap.js","../util/identity":"../../../../node_modules/rxjs/_esm5/internal/util/identity.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/concatAll.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.concatAll = concatAll;

var _mergeAll = require("./mergeAll");

/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */
function concatAll() {
  return (0, _mergeAll.mergeAll)(1);
}
},{"./mergeAll":"../../../../node_modules/rxjs/_esm5/internal/operators/mergeAll.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/concat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.concat = concat;

var _of = require("./of");

var _concatAll = require("../operators/concatAll");

/** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */
function concat() {
  var observables = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }

  return (0, _concatAll.concatAll)()(_of.of.apply(void 0, observables));
}
},{"./of":"../../../../node_modules/rxjs/_esm5/internal/observable/of.js","../operators/concatAll":"../../../../node_modules/rxjs/_esm5/internal/operators/concatAll.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/defer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defer = defer;

var _Observable = require("../Observable");

var _from = require("./from");

var _empty = require("./empty");

/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
function defer(observableFactory) {
  return new _Observable.Observable(function (subscriber) {
    var input;

    try {
      input = observableFactory();
    } catch (err) {
      subscriber.error(err);
      return undefined;
    }

    var source = input ? (0, _from.from)(input) : (0, _empty.empty)();
    return source.subscribe(subscriber);
  });
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","./from":"../../../../node_modules/rxjs/_esm5/internal/observable/from.js","./empty":"../../../../node_modules/rxjs/_esm5/internal/observable/empty.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/forkJoin.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forkJoin = forkJoin;

var _Observable = require("../Observable");

var _isArray = require("../util/isArray");

var _map = require("../operators/map");

var _isObject = require("../util/isObject");

var _from = require("./from");

/** PURE_IMPORTS_START _Observable,_util_isArray,_operators_map,_util_isObject,_from PURE_IMPORTS_END */
function forkJoin() {
  var sources = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }

  if (sources.length === 1) {
    var first_1 = sources[0];

    if ((0, _isArray.isArray)(first_1)) {
      return forkJoinInternal(first_1, null);
    }

    if ((0, _isObject.isObject)(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
      var keys = Object.keys(first_1);
      return forkJoinInternal(keys.map(function (key) {
        return first_1[key];
      }), keys);
    }
  }

  if (typeof sources[sources.length - 1] === 'function') {
    var resultSelector_1 = sources.pop();
    sources = sources.length === 1 && (0, _isArray.isArray)(sources[0]) ? sources[0] : sources;
    return forkJoinInternal(sources, null).pipe((0, _map.map)(function (args) {
      return resultSelector_1.apply(void 0, args);
    }));
  }

  return forkJoinInternal(sources, null);
}

function forkJoinInternal(sources, keys) {
  return new _Observable.Observable(function (subscriber) {
    var len = sources.length;

    if (len === 0) {
      subscriber.complete();
      return;
    }

    var values = new Array(len);
    var completed = 0;
    var emitted = 0;

    var _loop_1 = function (i) {
      var source = (0, _from.from)(sources[i]);
      var hasValue = false;
      subscriber.add(source.subscribe({
        next: function (value) {
          if (!hasValue) {
            hasValue = true;
            emitted++;
          }

          values[i] = value;
        },
        error: function (err) {
          return subscriber.error(err);
        },
        complete: function () {
          completed++;

          if (completed === len || !hasValue) {
            if (emitted === len) {
              subscriber.next(keys ? keys.reduce(function (result, key, i) {
                return result[key] = values[i], result;
              }, {}) : values);
            }

            subscriber.complete();
          }
        }
      }));
    };

    for (var i = 0; i < len; i++) {
      _loop_1(i);
    }
  });
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../util/isArray":"../../../../node_modules/rxjs/_esm5/internal/util/isArray.js","../operators/map":"../../../../node_modules/rxjs/_esm5/internal/operators/map.js","../util/isObject":"../../../../node_modules/rxjs/_esm5/internal/util/isObject.js","./from":"../../../../node_modules/rxjs/_esm5/internal/observable/from.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/fromEvent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromEvent = fromEvent;

var _Observable = require("../Observable");

var _isArray = require("../util/isArray");

var _isFunction = require("../util/isFunction");

var _map = require("../operators/map");

/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
var toString =
/*@__PURE__*/
function () {
  return Object.prototype.toString;
}();

function fromEvent(target, eventName, options, resultSelector) {
  if ((0, _isFunction.isFunction)(options)) {
    resultSelector = options;
    options = undefined;
  }

  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe((0, _map.map)(function (args) {
      return (0, _isArray.isArray)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }

  return new _Observable.Observable(function (subscriber) {
    function handler(e) {
      if (arguments.length > 1) {
        subscriber.next(Array.prototype.slice.call(arguments));
      } else {
        subscriber.next(e);
      }
    }

    setupSubscription(target, eventName, handler, subscriber, options);
  });
}

function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
  var unsubscribe;

  if (isEventTarget(sourceObj)) {
    var source_1 = sourceObj;
    sourceObj.addEventListener(eventName, handler, options);

    unsubscribe = function () {
      return source_1.removeEventListener(eventName, handler, options);
    };
  } else if (isJQueryStyleEventEmitter(sourceObj)) {
    var source_2 = sourceObj;
    sourceObj.on(eventName, handler);

    unsubscribe = function () {
      return source_2.off(eventName, handler);
    };
  } else if (isNodeStyleEventEmitter(sourceObj)) {
    var source_3 = sourceObj;
    sourceObj.addListener(eventName, handler);

    unsubscribe = function () {
      return source_3.removeListener(eventName, handler);
    };
  } else if (sourceObj && sourceObj.length) {
    for (var i = 0, len = sourceObj.length; i < len; i++) {
      setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
    }
  } else {
    throw new TypeError('Invalid event target');
  }

  subscriber.add(unsubscribe);
}

function isNodeStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}

function isJQueryStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}

function isEventTarget(sourceObj) {
  return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../util/isArray":"../../../../node_modules/rxjs/_esm5/internal/util/isArray.js","../util/isFunction":"../../../../node_modules/rxjs/_esm5/internal/util/isFunction.js","../operators/map":"../../../../node_modules/rxjs/_esm5/internal/operators/map.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/fromEventPattern.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromEventPattern = fromEventPattern;

var _Observable = require("../Observable");

var _isArray = require("../util/isArray");

var _isFunction = require("../util/isFunction");

var _map = require("../operators/map");

/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  if (resultSelector) {
    return fromEventPattern(addHandler, removeHandler).pipe((0, _map.map)(function (args) {
      return (0, _isArray.isArray)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }

  return new _Observable.Observable(function (subscriber) {
    var handler = function () {
      var e = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        e[_i] = arguments[_i];
      }

      return subscriber.next(e.length === 1 ? e[0] : e);
    };

    var retValue;

    try {
      retValue = addHandler(handler);
    } catch (err) {
      subscriber.error(err);
      return undefined;
    }

    if (!(0, _isFunction.isFunction)(removeHandler)) {
      return undefined;
    }

    return function () {
      return removeHandler(handler, retValue);
    };
  });
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../util/isArray":"../../../../node_modules/rxjs/_esm5/internal/util/isArray.js","../util/isFunction":"../../../../node_modules/rxjs/_esm5/internal/util/isFunction.js","../operators/map":"../../../../node_modules/rxjs/_esm5/internal/operators/map.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/generate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generate = generate;

var _Observable = require("../Observable");

var _identity = require("../util/identity");

var _isScheduler = require("../util/isScheduler");

/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */
function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
  var resultSelector;
  var initialState;

  if (arguments.length == 1) {
    var options = initialStateOrOptions;
    initialState = options.initialState;
    condition = options.condition;
    iterate = options.iterate;
    resultSelector = options.resultSelector || _identity.identity;
    scheduler = options.scheduler;
  } else if (resultSelectorOrObservable === undefined || (0, _isScheduler.isScheduler)(resultSelectorOrObservable)) {
    initialState = initialStateOrOptions;
    resultSelector = _identity.identity;
    scheduler = resultSelectorOrObservable;
  } else {
    initialState = initialStateOrOptions;
    resultSelector = resultSelectorOrObservable;
  }

  return new _Observable.Observable(function (subscriber) {
    var state = initialState;

    if (scheduler) {
      return scheduler.schedule(dispatch, 0, {
        subscriber: subscriber,
        iterate: iterate,
        condition: condition,
        resultSelector: resultSelector,
        state: state
      });
    }

    do {
      if (condition) {
        var conditionResult = void 0;

        try {
          conditionResult = condition(state);
        } catch (err) {
          subscriber.error(err);
          return undefined;
        }

        if (!conditionResult) {
          subscriber.complete();
          break;
        }
      }

      var value = void 0;

      try {
        value = resultSelector(state);
      } catch (err) {
        subscriber.error(err);
        return undefined;
      }

      subscriber.next(value);

      if (subscriber.closed) {
        break;
      }

      try {
        state = iterate(state);
      } catch (err) {
        subscriber.error(err);
        return undefined;
      }
    } while (true);

    return undefined;
  });
}

function dispatch(state) {
  var subscriber = state.subscriber,
      condition = state.condition;

  if (subscriber.closed) {
    return undefined;
  }

  if (state.needIterate) {
    try {
      state.state = state.iterate(state.state);
    } catch (err) {
      subscriber.error(err);
      return undefined;
    }
  } else {
    state.needIterate = true;
  }

  if (condition) {
    var conditionResult = void 0;

    try {
      conditionResult = condition(state.state);
    } catch (err) {
      subscriber.error(err);
      return undefined;
    }

    if (!conditionResult) {
      subscriber.complete();
      return undefined;
    }

    if (subscriber.closed) {
      return undefined;
    }
  }

  var value;

  try {
    value = state.resultSelector(state.state);
  } catch (err) {
    subscriber.error(err);
    return undefined;
  }

  if (subscriber.closed) {
    return undefined;
  }

  subscriber.next(value);

  if (subscriber.closed) {
    return undefined;
  }

  return this.schedule(state);
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../util/identity":"../../../../node_modules/rxjs/_esm5/internal/util/identity.js","../util/isScheduler":"../../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/iif.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.iif = iif;

var _defer = require("./defer");

var _empty = require("./empty");

/** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */
function iif(condition, trueResult, falseResult) {
  if (trueResult === void 0) {
    trueResult = _empty.EMPTY;
  }

  if (falseResult === void 0) {
    falseResult = _empty.EMPTY;
  }

  return (0, _defer.defer)(function () {
    return condition() ? trueResult : falseResult;
  });
}
},{"./defer":"../../../../node_modules/rxjs/_esm5/internal/observable/defer.js","./empty":"../../../../node_modules/rxjs/_esm5/internal/observable/empty.js"}],"../../../../node_modules/rxjs/_esm5/internal/util/isNumeric.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNumeric = isNumeric;

var _isArray = require("./isArray");

/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */
function isNumeric(val) {
  return !(0, _isArray.isArray)(val) && val - parseFloat(val) + 1 >= 0;
}
},{"./isArray":"../../../../node_modules/rxjs/_esm5/internal/util/isArray.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/interval.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interval = interval;

var _Observable = require("../Observable");

var _async = require("../scheduler/async");

var _isNumeric = require("../util/isNumeric");

/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */
function interval(period, scheduler) {
  if (period === void 0) {
    period = 0;
  }

  if (scheduler === void 0) {
    scheduler = _async.async;
  }

  if (!(0, _isNumeric.isNumeric)(period) || period < 0) {
    period = 0;
  }

  if (!scheduler || typeof scheduler.schedule !== 'function') {
    scheduler = _async.async;
  }

  return new _Observable.Observable(function (subscriber) {
    subscriber.add(scheduler.schedule(dispatch, period, {
      subscriber: subscriber,
      counter: 0,
      period: period
    }));
    return subscriber;
  });
}

function dispatch(state) {
  var subscriber = state.subscriber,
      counter = state.counter,
      period = state.period;
  subscriber.next(counter);
  this.schedule({
    subscriber: subscriber,
    counter: counter + 1,
    period: period
  }, period);
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../scheduler/async":"../../../../node_modules/rxjs/_esm5/internal/scheduler/async.js","../util/isNumeric":"../../../../node_modules/rxjs/_esm5/internal/util/isNumeric.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/merge.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.merge = merge;

var _Observable = require("../Observable");

var _isScheduler = require("../util/isScheduler");

var _mergeAll = require("../operators/mergeAll");

var _fromArray = require("./fromArray");

/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */
function merge() {
  var observables = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }

  var concurrent = Number.POSITIVE_INFINITY;
  var scheduler = null;
  var last = observables[observables.length - 1];

  if ((0, _isScheduler.isScheduler)(last)) {
    scheduler = observables.pop();

    if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
      concurrent = observables.pop();
    }
  } else if (typeof last === 'number') {
    concurrent = observables.pop();
  }

  if (scheduler === null && observables.length === 1 && observables[0] instanceof _Observable.Observable) {
    return observables[0];
  }

  return (0, _mergeAll.mergeAll)(concurrent)((0, _fromArray.fromArray)(observables, scheduler));
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../util/isScheduler":"../../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js","../operators/mergeAll":"../../../../node_modules/rxjs/_esm5/internal/operators/mergeAll.js","./fromArray":"../../../../node_modules/rxjs/_esm5/internal/observable/fromArray.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/never.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.never = never;
exports.NEVER = void 0;

var _Observable = require("../Observable");

var _noop = require("../util/noop");

/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */
var NEVER =
/*@__PURE__*/
new _Observable.Observable(_noop.noop);
exports.NEVER = NEVER;

function never() {
  return NEVER;
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../util/noop":"../../../../node_modules/rxjs/_esm5/internal/util/noop.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/onErrorResumeNext.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onErrorResumeNext = onErrorResumeNext;

var _Observable = require("../Observable");

var _from = require("./from");

var _isArray = require("../util/isArray");

var _empty = require("./empty");

/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */
function onErrorResumeNext() {
  var sources = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }

  if (sources.length === 0) {
    return _empty.EMPTY;
  }

  var first = sources[0],
      remainder = sources.slice(1);

  if (sources.length === 1 && (0, _isArray.isArray)(first)) {
    return onErrorResumeNext.apply(void 0, first);
  }

  return new _Observable.Observable(function (subscriber) {
    var subNext = function () {
      return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber));
    };

    return (0, _from.from)(first).subscribe({
      next: function (value) {
        subscriber.next(value);
      },
      error: subNext,
      complete: subNext
    });
  });
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","./from":"../../../../node_modules/rxjs/_esm5/internal/observable/from.js","../util/isArray":"../../../../node_modules/rxjs/_esm5/internal/util/isArray.js","./empty":"../../../../node_modules/rxjs/_esm5/internal/observable/empty.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/pairs.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pairs = pairs;
exports.dispatch = dispatch;

var _Observable = require("../Observable");

var _Subscription = require("../Subscription");

/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
function pairs(obj, scheduler) {
  if (!scheduler) {
    return new _Observable.Observable(function (subscriber) {
      var keys = Object.keys(obj);

      for (var i = 0; i < keys.length && !subscriber.closed; i++) {
        var key = keys[i];

        if (obj.hasOwnProperty(key)) {
          subscriber.next([key, obj[key]]);
        }
      }

      subscriber.complete();
    });
  } else {
    return new _Observable.Observable(function (subscriber) {
      var keys = Object.keys(obj);
      var subscription = new _Subscription.Subscription();
      subscription.add(scheduler.schedule(dispatch, 0, {
        keys: keys,
        index: 0,
        subscriber: subscriber,
        subscription: subscription,
        obj: obj
      }));
      return subscription;
    });
  }
}

function dispatch(state) {
  var keys = state.keys,
      index = state.index,
      subscriber = state.subscriber,
      subscription = state.subscription,
      obj = state.obj;

  if (!subscriber.closed) {
    if (index < keys.length) {
      var key = keys[index];
      subscriber.next([key, obj[key]]);
      subscription.add(this.schedule({
        keys: keys,
        index: index + 1,
        subscriber: subscriber,
        subscription: subscription,
        obj: obj
      }));
    } else {
      subscriber.complete();
    }
  }
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../Subscription":"../../../../node_modules/rxjs/_esm5/internal/Subscription.js"}],"../../../../node_modules/rxjs/_esm5/internal/util/not.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.not = not;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function not(pred, thisArg) {
  function notPred() {
    return !notPred.pred.apply(notPred.thisArg, arguments);
  }

  notPred.pred = pred;
  notPred.thisArg = thisArg;
  return notPred;
}
},{}],"../../../../node_modules/rxjs/_esm5/internal/operators/filter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filter = filter;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function filter(predicate, thisArg) {
  return function filterOperatorFunction(source) {
    return source.lift(new FilterOperator(predicate, thisArg));
  };
}

var FilterOperator =
/*@__PURE__*/
function () {
  function FilterOperator(predicate, thisArg) {
    this.predicate = predicate;
    this.thisArg = thisArg;
  }

  FilterOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
  };

  return FilterOperator;
}();

var FilterSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(FilterSubscriber, _super);

  function FilterSubscriber(destination, predicate, thisArg) {
    var _this = _super.call(this, destination) || this;

    _this.predicate = predicate;
    _this.thisArg = thisArg;
    _this.count = 0;
    return _this;
  }

  FilterSubscriber.prototype._next = function (value) {
    var result;

    try {
      result = this.predicate.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    if (result) {
      this.destination.next(value);
    }
  };

  return FilterSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/partition.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.partition = partition;

var _not = require("../util/not");

var _subscribeTo = require("../util/subscribeTo");

var _filter = require("../operators/filter");

var _Observable = require("../Observable");

/** PURE_IMPORTS_START _util_not,_util_subscribeTo,_operators_filter,_Observable PURE_IMPORTS_END */
function partition(source, predicate, thisArg) {
  return [(0, _filter.filter)(predicate, thisArg)(new _Observable.Observable((0, _subscribeTo.subscribeTo)(source))), (0, _filter.filter)((0, _not.not)(predicate, thisArg))(new _Observable.Observable((0, _subscribeTo.subscribeTo)(source)))];
}
},{"../util/not":"../../../../node_modules/rxjs/_esm5/internal/util/not.js","../util/subscribeTo":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeTo.js","../operators/filter":"../../../../node_modules/rxjs/_esm5/internal/operators/filter.js","../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/race.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.race = race;
exports.RaceSubscriber = exports.RaceOperator = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _isArray = require("../util/isArray");

var _fromArray = require("./fromArray");

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function race() {
  var observables = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }

  if (observables.length === 1) {
    if ((0, _isArray.isArray)(observables[0])) {
      observables = observables[0];
    } else {
      return observables[0];
    }
  }

  return (0, _fromArray.fromArray)(observables, undefined).lift(new RaceOperator());
}

var RaceOperator =
/*@__PURE__*/
function () {
  function RaceOperator() {}

  RaceOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new RaceSubscriber(subscriber));
  };

  return RaceOperator;
}();

exports.RaceOperator = RaceOperator;

var RaceSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(RaceSubscriber, _super);

  function RaceSubscriber(destination) {
    var _this = _super.call(this, destination) || this;

    _this.hasFirst = false;
    _this.observables = [];
    _this.subscriptions = [];
    return _this;
  }

  RaceSubscriber.prototype._next = function (observable) {
    this.observables.push(observable);
  };

  RaceSubscriber.prototype._complete = function () {
    var observables = this.observables;
    var len = observables.length;

    if (len === 0) {
      this.destination.complete();
    } else {
      for (var i = 0; i < len && !this.hasFirst; i++) {
        var observable = observables[i];
        var subscription = (0, _subscribeToResult.subscribeToResult)(this, observable, observable, i);

        if (this.subscriptions) {
          this.subscriptions.push(subscription);
        }

        this.add(subscription);
      }

      this.observables = null;
    }
  };

  RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    if (!this.hasFirst) {
      this.hasFirst = true;

      for (var i = 0; i < this.subscriptions.length; i++) {
        if (i !== outerIndex) {
          var subscription = this.subscriptions[i];
          subscription.unsubscribe();
          this.remove(subscription);
        }
      }

      this.subscriptions = null;
    }

    this.destination.next(innerValue);
  };

  return RaceSubscriber;
}(_OuterSubscriber.OuterSubscriber);

exports.RaceSubscriber = RaceSubscriber;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../util/isArray":"../../../../node_modules/rxjs/_esm5/internal/util/isArray.js","./fromArray":"../../../../node_modules/rxjs/_esm5/internal/observable/fromArray.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/range.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.range = range;
exports.dispatch = dispatch;

var _Observable = require("../Observable");

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
function range(start, count, scheduler) {
  if (start === void 0) {
    start = 0;
  }

  return new _Observable.Observable(function (subscriber) {
    if (count === undefined) {
      count = start;
      start = 0;
    }

    var index = 0;
    var current = start;

    if (scheduler) {
      return scheduler.schedule(dispatch, 0, {
        index: index,
        count: count,
        start: start,
        subscriber: subscriber
      });
    } else {
      do {
        if (index++ >= count) {
          subscriber.complete();
          break;
        }

        subscriber.next(current++);

        if (subscriber.closed) {
          break;
        }
      } while (true);
    }

    return undefined;
  });
}

function dispatch(state) {
  var start = state.start,
      index = state.index,
      count = state.count,
      subscriber = state.subscriber;

  if (index >= count) {
    subscriber.complete();
    return;
  }

  subscriber.next(start);

  if (subscriber.closed) {
    return;
  }

  state.index = index + 1;
  state.start = start + 1;
  this.schedule(state);
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/timer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.timer = timer;

var _Observable = require("../Observable");

var _async = require("../scheduler/async");

var _isNumeric = require("../util/isNumeric");

var _isScheduler = require("../util/isScheduler");

/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
function timer(dueTime, periodOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }

  var period = -1;

  if ((0, _isNumeric.isNumeric)(periodOrScheduler)) {
    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
  } else if ((0, _isScheduler.isScheduler)(periodOrScheduler)) {
    scheduler = periodOrScheduler;
  }

  if (!(0, _isScheduler.isScheduler)(scheduler)) {
    scheduler = _async.async;
  }

  return new _Observable.Observable(function (subscriber) {
    var due = (0, _isNumeric.isNumeric)(dueTime) ? dueTime : +dueTime - scheduler.now();
    return scheduler.schedule(dispatch, due, {
      index: 0,
      period: period,
      subscriber: subscriber
    });
  });
}

function dispatch(state) {
  var index = state.index,
      period = state.period,
      subscriber = state.subscriber;
  subscriber.next(index);

  if (subscriber.closed) {
    return;
  } else if (period === -1) {
    return subscriber.complete();
  }

  state.index = index + 1;
  this.schedule(state, period);
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../scheduler/async":"../../../../node_modules/rxjs/_esm5/internal/scheduler/async.js","../util/isNumeric":"../../../../node_modules/rxjs/_esm5/internal/util/isNumeric.js","../util/isScheduler":"../../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/using.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.using = using;

var _Observable = require("../Observable");

var _from = require("./from");

var _empty = require("./empty");

/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
function using(resourceFactory, observableFactory) {
  return new _Observable.Observable(function (subscriber) {
    var resource;

    try {
      resource = resourceFactory();
    } catch (err) {
      subscriber.error(err);
      return undefined;
    }

    var result;

    try {
      result = observableFactory(resource);
    } catch (err) {
      subscriber.error(err);
      return undefined;
    }

    var source = result ? (0, _from.from)(result) : _empty.EMPTY;
    var subscription = source.subscribe(subscriber);
    return function () {
      subscription.unsubscribe();

      if (resource) {
        resource.unsubscribe();
      }
    };
  });
}
},{"../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","./from":"../../../../node_modules/rxjs/_esm5/internal/observable/from.js","./empty":"../../../../node_modules/rxjs/_esm5/internal/observable/empty.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/zip.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zip = zip;
exports.ZipSubscriber = exports.ZipOperator = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _fromArray = require("./fromArray");

var _isArray = require("../util/isArray");

var _Subscriber = require("../Subscriber");

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

var _iterator = require("../../internal/symbol/iterator");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_OuterSubscriber,_util_subscribeToResult,_.._internal_symbol_iterator PURE_IMPORTS_END */
function zip() {
  var observables = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }

  var resultSelector = observables[observables.length - 1];

  if (typeof resultSelector === 'function') {
    observables.pop();
  }

  return (0, _fromArray.fromArray)(observables, undefined).lift(new ZipOperator(resultSelector));
}

var ZipOperator =
/*@__PURE__*/
function () {
  function ZipOperator(resultSelector) {
    this.resultSelector = resultSelector;
  }

  ZipOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
  };

  return ZipOperator;
}();

exports.ZipOperator = ZipOperator;

var ZipSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(ZipSubscriber, _super);

  function ZipSubscriber(destination, resultSelector, values) {
    if (values === void 0) {
      values = Object.create(null);
    }

    var _this = _super.call(this, destination) || this;

    _this.iterators = [];
    _this.active = 0;
    _this.resultSelector = typeof resultSelector === 'function' ? resultSelector : null;
    _this.values = values;
    return _this;
  }

  ZipSubscriber.prototype._next = function (value) {
    var iterators = this.iterators;

    if ((0, _isArray.isArray)(value)) {
      iterators.push(new StaticArrayIterator(value));
    } else if (typeof value[_iterator.iterator] === 'function') {
      iterators.push(new StaticIterator(value[_iterator.iterator]()));
    } else {
      iterators.push(new ZipBufferIterator(this.destination, this, value));
    }
  };

  ZipSubscriber.prototype._complete = function () {
    var iterators = this.iterators;
    var len = iterators.length;
    this.unsubscribe();

    if (len === 0) {
      this.destination.complete();
      return;
    }

    this.active = len;

    for (var i = 0; i < len; i++) {
      var iterator = iterators[i];

      if (iterator.stillUnsubscribed) {
        var destination = this.destination;
        destination.add(iterator.subscribe(iterator, i));
      } else {
        this.active--;
      }
    }
  };

  ZipSubscriber.prototype.notifyInactive = function () {
    this.active--;

    if (this.active === 0) {
      this.destination.complete();
    }
  };

  ZipSubscriber.prototype.checkIterators = function () {
    var iterators = this.iterators;
    var len = iterators.length;
    var destination = this.destination;

    for (var i = 0; i < len; i++) {
      var iterator = iterators[i];

      if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
        return;
      }
    }

    var shouldComplete = false;
    var args = [];

    for (var i = 0; i < len; i++) {
      var iterator = iterators[i];
      var result = iterator.next();

      if (iterator.hasCompleted()) {
        shouldComplete = true;
      }

      if (result.done) {
        destination.complete();
        return;
      }

      args.push(result.value);
    }

    if (this.resultSelector) {
      this._tryresultSelector(args);
    } else {
      destination.next(args);
    }

    if (shouldComplete) {
      destination.complete();
    }
  };

  ZipSubscriber.prototype._tryresultSelector = function (args) {
    var result;

    try {
      result = this.resultSelector.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    this.destination.next(result);
  };

  return ZipSubscriber;
}(_Subscriber.Subscriber);

exports.ZipSubscriber = ZipSubscriber;

var StaticIterator =
/*@__PURE__*/
function () {
  function StaticIterator(iterator) {
    this.iterator = iterator;
    this.nextResult = iterator.next();
  }

  StaticIterator.prototype.hasValue = function () {
    return true;
  };

  StaticIterator.prototype.next = function () {
    var result = this.nextResult;
    this.nextResult = this.iterator.next();
    return result;
  };

  StaticIterator.prototype.hasCompleted = function () {
    var nextResult = this.nextResult;
    return nextResult && nextResult.done;
  };

  return StaticIterator;
}();

var StaticArrayIterator =
/*@__PURE__*/
function () {
  function StaticArrayIterator(array) {
    this.array = array;
    this.index = 0;
    this.length = 0;
    this.length = array.length;
  }

  StaticArrayIterator.prototype[_iterator.iterator] = function () {
    return this;
  };

  StaticArrayIterator.prototype.next = function (value) {
    var i = this.index++;
    var array = this.array;
    return i < this.length ? {
      value: array[i],
      done: false
    } : {
      value: null,
      done: true
    };
  };

  StaticArrayIterator.prototype.hasValue = function () {
    return this.array.length > this.index;
  };

  StaticArrayIterator.prototype.hasCompleted = function () {
    return this.array.length === this.index;
  };

  return StaticArrayIterator;
}();

var ZipBufferIterator =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(ZipBufferIterator, _super);

  function ZipBufferIterator(destination, parent, observable) {
    var _this = _super.call(this, destination) || this;

    _this.parent = parent;
    _this.observable = observable;
    _this.stillUnsubscribed = true;
    _this.buffer = [];
    _this.isComplete = false;
    return _this;
  }

  ZipBufferIterator.prototype[_iterator.iterator] = function () {
    return this;
  };

  ZipBufferIterator.prototype.next = function () {
    var buffer = this.buffer;

    if (buffer.length === 0 && this.isComplete) {
      return {
        value: null,
        done: true
      };
    } else {
      return {
        value: buffer.shift(),
        done: false
      };
    }
  };

  ZipBufferIterator.prototype.hasValue = function () {
    return this.buffer.length > 0;
  };

  ZipBufferIterator.prototype.hasCompleted = function () {
    return this.buffer.length === 0 && this.isComplete;
  };

  ZipBufferIterator.prototype.notifyComplete = function () {
    if (this.buffer.length > 0) {
      this.isComplete = true;
      this.parent.notifyInactive();
    } else {
      this.destination.complete();
    }
  };

  ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.buffer.push(innerValue);
    this.parent.checkIterators();
  };

  ZipBufferIterator.prototype.subscribe = function (value, index) {
    return (0, _subscribeToResult.subscribeToResult)(this, this.observable, this, index);
  };

  return ZipBufferIterator;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","./fromArray":"../../../../node_modules/rxjs/_esm5/internal/observable/fromArray.js","../util/isArray":"../../../../node_modules/rxjs/_esm5/internal/util/isArray.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js","../../internal/symbol/iterator":"../../../../node_modules/rxjs/_esm5/internal/symbol/iterator.js"}],"../../../../node_modules/rxjs/_esm5/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Observable", {
  enumerable: true,
  get: function () {
    return _Observable.Observable;
  }
});
Object.defineProperty(exports, "ConnectableObservable", {
  enumerable: true,
  get: function () {
    return _ConnectableObservable.ConnectableObservable;
  }
});
Object.defineProperty(exports, "GroupedObservable", {
  enumerable: true,
  get: function () {
    return _groupBy.GroupedObservable;
  }
});
Object.defineProperty(exports, "observable", {
  enumerable: true,
  get: function () {
    return _observable.observable;
  }
});
Object.defineProperty(exports, "Subject", {
  enumerable: true,
  get: function () {
    return _Subject.Subject;
  }
});
Object.defineProperty(exports, "BehaviorSubject", {
  enumerable: true,
  get: function () {
    return _BehaviorSubject.BehaviorSubject;
  }
});
Object.defineProperty(exports, "ReplaySubject", {
  enumerable: true,
  get: function () {
    return _ReplaySubject.ReplaySubject;
  }
});
Object.defineProperty(exports, "AsyncSubject", {
  enumerable: true,
  get: function () {
    return _AsyncSubject.AsyncSubject;
  }
});
Object.defineProperty(exports, "asapScheduler", {
  enumerable: true,
  get: function () {
    return _asap.asap;
  }
});
Object.defineProperty(exports, "asyncScheduler", {
  enumerable: true,
  get: function () {
    return _async.async;
  }
});
Object.defineProperty(exports, "queueScheduler", {
  enumerable: true,
  get: function () {
    return _queue.queue;
  }
});
Object.defineProperty(exports, "animationFrameScheduler", {
  enumerable: true,
  get: function () {
    return _animationFrame.animationFrame;
  }
});
Object.defineProperty(exports, "VirtualTimeScheduler", {
  enumerable: true,
  get: function () {
    return _VirtualTimeScheduler.VirtualTimeScheduler;
  }
});
Object.defineProperty(exports, "VirtualAction", {
  enumerable: true,
  get: function () {
    return _VirtualTimeScheduler.VirtualAction;
  }
});
Object.defineProperty(exports, "Scheduler", {
  enumerable: true,
  get: function () {
    return _Scheduler.Scheduler;
  }
});
Object.defineProperty(exports, "Subscription", {
  enumerable: true,
  get: function () {
    return _Subscription.Subscription;
  }
});
Object.defineProperty(exports, "Subscriber", {
  enumerable: true,
  get: function () {
    return _Subscriber.Subscriber;
  }
});
Object.defineProperty(exports, "Notification", {
  enumerable: true,
  get: function () {
    return _Notification.Notification;
  }
});
Object.defineProperty(exports, "NotificationKind", {
  enumerable: true,
  get: function () {
    return _Notification.NotificationKind;
  }
});
Object.defineProperty(exports, "pipe", {
  enumerable: true,
  get: function () {
    return _pipe.pipe;
  }
});
Object.defineProperty(exports, "noop", {
  enumerable: true,
  get: function () {
    return _noop.noop;
  }
});
Object.defineProperty(exports, "identity", {
  enumerable: true,
  get: function () {
    return _identity.identity;
  }
});
Object.defineProperty(exports, "isObservable", {
  enumerable: true,
  get: function () {
    return _isObservable.isObservable;
  }
});
Object.defineProperty(exports, "ArgumentOutOfRangeError", {
  enumerable: true,
  get: function () {
    return _ArgumentOutOfRangeError.ArgumentOutOfRangeError;
  }
});
Object.defineProperty(exports, "EmptyError", {
  enumerable: true,
  get: function () {
    return _EmptyError.EmptyError;
  }
});
Object.defineProperty(exports, "ObjectUnsubscribedError", {
  enumerable: true,
  get: function () {
    return _ObjectUnsubscribedError.ObjectUnsubscribedError;
  }
});
Object.defineProperty(exports, "UnsubscriptionError", {
  enumerable: true,
  get: function () {
    return _UnsubscriptionError.UnsubscriptionError;
  }
});
Object.defineProperty(exports, "TimeoutError", {
  enumerable: true,
  get: function () {
    return _TimeoutError.TimeoutError;
  }
});
Object.defineProperty(exports, "bindCallback", {
  enumerable: true,
  get: function () {
    return _bindCallback.bindCallback;
  }
});
Object.defineProperty(exports, "bindNodeCallback", {
  enumerable: true,
  get: function () {
    return _bindNodeCallback.bindNodeCallback;
  }
});
Object.defineProperty(exports, "combineLatest", {
  enumerable: true,
  get: function () {
    return _combineLatest.combineLatest;
  }
});
Object.defineProperty(exports, "concat", {
  enumerable: true,
  get: function () {
    return _concat.concat;
  }
});
Object.defineProperty(exports, "defer", {
  enumerable: true,
  get: function () {
    return _defer.defer;
  }
});
Object.defineProperty(exports, "empty", {
  enumerable: true,
  get: function () {
    return _empty.empty;
  }
});
Object.defineProperty(exports, "EMPTY", {
  enumerable: true,
  get: function () {
    return _empty.EMPTY;
  }
});
Object.defineProperty(exports, "forkJoin", {
  enumerable: true,
  get: function () {
    return _forkJoin.forkJoin;
  }
});
Object.defineProperty(exports, "from", {
  enumerable: true,
  get: function () {
    return _from.from;
  }
});
Object.defineProperty(exports, "fromEvent", {
  enumerable: true,
  get: function () {
    return _fromEvent.fromEvent;
  }
});
Object.defineProperty(exports, "fromEventPattern", {
  enumerable: true,
  get: function () {
    return _fromEventPattern.fromEventPattern;
  }
});
Object.defineProperty(exports, "generate", {
  enumerable: true,
  get: function () {
    return _generate.generate;
  }
});
Object.defineProperty(exports, "iif", {
  enumerable: true,
  get: function () {
    return _iif.iif;
  }
});
Object.defineProperty(exports, "interval", {
  enumerable: true,
  get: function () {
    return _interval.interval;
  }
});
Object.defineProperty(exports, "merge", {
  enumerable: true,
  get: function () {
    return _merge.merge;
  }
});
Object.defineProperty(exports, "never", {
  enumerable: true,
  get: function () {
    return _never.never;
  }
});
Object.defineProperty(exports, "NEVER", {
  enumerable: true,
  get: function () {
    return _never.NEVER;
  }
});
Object.defineProperty(exports, "of", {
  enumerable: true,
  get: function () {
    return _of.of;
  }
});
Object.defineProperty(exports, "onErrorResumeNext", {
  enumerable: true,
  get: function () {
    return _onErrorResumeNext.onErrorResumeNext;
  }
});
Object.defineProperty(exports, "pairs", {
  enumerable: true,
  get: function () {
    return _pairs.pairs;
  }
});
Object.defineProperty(exports, "partition", {
  enumerable: true,
  get: function () {
    return _partition.partition;
  }
});
Object.defineProperty(exports, "race", {
  enumerable: true,
  get: function () {
    return _race.race;
  }
});
Object.defineProperty(exports, "range", {
  enumerable: true,
  get: function () {
    return _range.range;
  }
});
Object.defineProperty(exports, "throwError", {
  enumerable: true,
  get: function () {
    return _throwError.throwError;
  }
});
Object.defineProperty(exports, "timer", {
  enumerable: true,
  get: function () {
    return _timer.timer;
  }
});
Object.defineProperty(exports, "using", {
  enumerable: true,
  get: function () {
    return _using.using;
  }
});
Object.defineProperty(exports, "zip", {
  enumerable: true,
  get: function () {
    return _zip.zip;
  }
});
Object.defineProperty(exports, "scheduled", {
  enumerable: true,
  get: function () {
    return _scheduled.scheduled;
  }
});
Object.defineProperty(exports, "config", {
  enumerable: true,
  get: function () {
    return _config.config;
  }
});

var _Observable = require("./internal/Observable");

var _ConnectableObservable = require("./internal/observable/ConnectableObservable");

var _groupBy = require("./internal/operators/groupBy");

var _observable = require("./internal/symbol/observable");

var _Subject = require("./internal/Subject");

var _BehaviorSubject = require("./internal/BehaviorSubject");

var _ReplaySubject = require("./internal/ReplaySubject");

var _AsyncSubject = require("./internal/AsyncSubject");

var _asap = require("./internal/scheduler/asap");

var _async = require("./internal/scheduler/async");

var _queue = require("./internal/scheduler/queue");

var _animationFrame = require("./internal/scheduler/animationFrame");

var _VirtualTimeScheduler = require("./internal/scheduler/VirtualTimeScheduler");

var _Scheduler = require("./internal/Scheduler");

var _Subscription = require("./internal/Subscription");

var _Subscriber = require("./internal/Subscriber");

var _Notification = require("./internal/Notification");

var _pipe = require("./internal/util/pipe");

var _noop = require("./internal/util/noop");

var _identity = require("./internal/util/identity");

var _isObservable = require("./internal/util/isObservable");

var _ArgumentOutOfRangeError = require("./internal/util/ArgumentOutOfRangeError");

var _EmptyError = require("./internal/util/EmptyError");

var _ObjectUnsubscribedError = require("./internal/util/ObjectUnsubscribedError");

var _UnsubscriptionError = require("./internal/util/UnsubscriptionError");

var _TimeoutError = require("./internal/util/TimeoutError");

var _bindCallback = require("./internal/observable/bindCallback");

var _bindNodeCallback = require("./internal/observable/bindNodeCallback");

var _combineLatest = require("./internal/observable/combineLatest");

var _concat = require("./internal/observable/concat");

var _defer = require("./internal/observable/defer");

var _empty = require("./internal/observable/empty");

var _forkJoin = require("./internal/observable/forkJoin");

var _from = require("./internal/observable/from");

var _fromEvent = require("./internal/observable/fromEvent");

var _fromEventPattern = require("./internal/observable/fromEventPattern");

var _generate = require("./internal/observable/generate");

var _iif = require("./internal/observable/iif");

var _interval = require("./internal/observable/interval");

var _merge = require("./internal/observable/merge");

var _never = require("./internal/observable/never");

var _of = require("./internal/observable/of");

var _onErrorResumeNext = require("./internal/observable/onErrorResumeNext");

var _pairs = require("./internal/observable/pairs");

var _partition = require("./internal/observable/partition");

var _race = require("./internal/observable/race");

var _range = require("./internal/observable/range");

var _throwError = require("./internal/observable/throwError");

var _timer = require("./internal/observable/timer");

var _using = require("./internal/observable/using");

var _zip = require("./internal/observable/zip");

var _scheduled = require("./internal/scheduled/scheduled");

var _config = require("./internal/config");
},{"./internal/Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","./internal/observable/ConnectableObservable":"../../../../node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js","./internal/operators/groupBy":"../../../../node_modules/rxjs/_esm5/internal/operators/groupBy.js","./internal/symbol/observable":"../../../../node_modules/rxjs/_esm5/internal/symbol/observable.js","./internal/Subject":"../../../../node_modules/rxjs/_esm5/internal/Subject.js","./internal/BehaviorSubject":"../../../../node_modules/rxjs/_esm5/internal/BehaviorSubject.js","./internal/ReplaySubject":"../../../../node_modules/rxjs/_esm5/internal/ReplaySubject.js","./internal/AsyncSubject":"../../../../node_modules/rxjs/_esm5/internal/AsyncSubject.js","./internal/scheduler/asap":"../../../../node_modules/rxjs/_esm5/internal/scheduler/asap.js","./internal/scheduler/async":"../../../../node_modules/rxjs/_esm5/internal/scheduler/async.js","./internal/scheduler/queue":"../../../../node_modules/rxjs/_esm5/internal/scheduler/queue.js","./internal/scheduler/animationFrame":"../../../../node_modules/rxjs/_esm5/internal/scheduler/animationFrame.js","./internal/scheduler/VirtualTimeScheduler":"../../../../node_modules/rxjs/_esm5/internal/scheduler/VirtualTimeScheduler.js","./internal/Scheduler":"../../../../node_modules/rxjs/_esm5/internal/Scheduler.js","./internal/Subscription":"../../../../node_modules/rxjs/_esm5/internal/Subscription.js","./internal/Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","./internal/Notification":"../../../../node_modules/rxjs/_esm5/internal/Notification.js","./internal/util/pipe":"../../../../node_modules/rxjs/_esm5/internal/util/pipe.js","./internal/util/noop":"../../../../node_modules/rxjs/_esm5/internal/util/noop.js","./internal/util/identity":"../../../../node_modules/rxjs/_esm5/internal/util/identity.js","./internal/util/isObservable":"../../../../node_modules/rxjs/_esm5/internal/util/isObservable.js","./internal/util/ArgumentOutOfRangeError":"../../../../node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js","./internal/util/EmptyError":"../../../../node_modules/rxjs/_esm5/internal/util/EmptyError.js","./internal/util/ObjectUnsubscribedError":"../../../../node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js","./internal/util/UnsubscriptionError":"../../../../node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js","./internal/util/TimeoutError":"../../../../node_modules/rxjs/_esm5/internal/util/TimeoutError.js","./internal/observable/bindCallback":"../../../../node_modules/rxjs/_esm5/internal/observable/bindCallback.js","./internal/observable/bindNodeCallback":"../../../../node_modules/rxjs/_esm5/internal/observable/bindNodeCallback.js","./internal/observable/combineLatest":"../../../../node_modules/rxjs/_esm5/internal/observable/combineLatest.js","./internal/observable/concat":"../../../../node_modules/rxjs/_esm5/internal/observable/concat.js","./internal/observable/defer":"../../../../node_modules/rxjs/_esm5/internal/observable/defer.js","./internal/observable/empty":"../../../../node_modules/rxjs/_esm5/internal/observable/empty.js","./internal/observable/forkJoin":"../../../../node_modules/rxjs/_esm5/internal/observable/forkJoin.js","./internal/observable/from":"../../../../node_modules/rxjs/_esm5/internal/observable/from.js","./internal/observable/fromEvent":"../../../../node_modules/rxjs/_esm5/internal/observable/fromEvent.js","./internal/observable/fromEventPattern":"../../../../node_modules/rxjs/_esm5/internal/observable/fromEventPattern.js","./internal/observable/generate":"../../../../node_modules/rxjs/_esm5/internal/observable/generate.js","./internal/observable/iif":"../../../../node_modules/rxjs/_esm5/internal/observable/iif.js","./internal/observable/interval":"../../../../node_modules/rxjs/_esm5/internal/observable/interval.js","./internal/observable/merge":"../../../../node_modules/rxjs/_esm5/internal/observable/merge.js","./internal/observable/never":"../../../../node_modules/rxjs/_esm5/internal/observable/never.js","./internal/observable/of":"../../../../node_modules/rxjs/_esm5/internal/observable/of.js","./internal/observable/onErrorResumeNext":"../../../../node_modules/rxjs/_esm5/internal/observable/onErrorResumeNext.js","./internal/observable/pairs":"../../../../node_modules/rxjs/_esm5/internal/observable/pairs.js","./internal/observable/partition":"../../../../node_modules/rxjs/_esm5/internal/observable/partition.js","./internal/observable/race":"../../../../node_modules/rxjs/_esm5/internal/observable/race.js","./internal/observable/range":"../../../../node_modules/rxjs/_esm5/internal/observable/range.js","./internal/observable/throwError":"../../../../node_modules/rxjs/_esm5/internal/observable/throwError.js","./internal/observable/timer":"../../../../node_modules/rxjs/_esm5/internal/observable/timer.js","./internal/observable/using":"../../../../node_modules/rxjs/_esm5/internal/observable/using.js","./internal/observable/zip":"../../../../node_modules/rxjs/_esm5/internal/observable/zip.js","./internal/scheduled/scheduled":"../../../../node_modules/rxjs/_esm5/internal/scheduled/scheduled.js","./internal/config":"../../../../node_modules/rxjs/_esm5/internal/config.js"}],"../../../utils/array_includes.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Array.prototype.includes ponyfill.
 * Returns ``true`` if the given array ``arr`` contains the element
 * ``searchElement``. false ``otherwise``.
 *
 * Inspired from MDN polyfill, but ponyfilled instead
 *
 * @example
 * ```js
 * arrayIncludes([1, 2, 3], 3);
 * // => true
 *
 * arrayIncludes([1, 2, 3], 7);
 * // => false
 *
 * const obj = { a: 4 };
 * arrayIncludes([obj, { b: 7 }, { a: 3 }, obj);
 * // => true
 *
 * // does not perform deep equality
 * arrayIncludes([{ a: 4 }, { b: 7 }, { a: 3 }, { a: 4 });
 * // => false
 *
 * // the third argument state the starting index. 0 if not set.
 *
 * arrayIncludes([1, 2, 3], 2, 1);
 * // => true
 *
 * arrayIncludes([1, 2, 3], 2, 2);
 * // => false
 * ```
 *
 * @param {Array} arr
 * @param {*} searchElement
 * @param {number} [fromIndex]
 * @returns {boolean}
 */

function arrayIncludes(arr, searchElement, fromIndex) {
  /* tslint:disable no-unbound-method */
  if (typeof Array.prototype.includes === "function") {
    /* tslint:enable no-unbound-method */

    /* tslint:disable ban */
    return arr.includes(searchElement, fromIndex);
    /* tslint:enable ban */
  }

  var len = arr.length >>> 0;

  if (len === 0) {
    return false;
  }

  var n = fromIndex | 0;
  var k = n >= 0 ? Math.min(n, len - 1) : Math.max(len + n, 0);

  var areTheSame = function areTheSame(x, y) {
    return x === y || // Viva las JavaScriptas!
    typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
  };

  while (k < len) {
    if (areTheSame(arr[k], searchElement)) {
      return true;
    }

    k++;
  }

  return false;
}

exports.default = arrayIncludes;
},{}],"utils.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2019 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var array_includes_1 = __importDefault(require("../../../utils/array_includes"));
/* tslint:disable */

/**
 * A utils class that extends Error object to have custom class errors
 */


var SegmentConstuctionError =
/*#__PURE__*/
function (_Error) {
  _inherits(SegmentConstuctionError, _Error);

  function SegmentConstuctionError(message) {
    var _this;

    _classCallCheck(this, SegmentConstuctionError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SegmentConstuctionError).call(this, message));
    Object.setPrototypeOf(_assertThisInitialized(_this), SegmentConstuctionError.prototype);
    _this.name = "SegmentConstructionError";
    return _this;
  }

  return SegmentConstuctionError;
}(_wrapNativeSuper(Error));

exports.SegmentConstuctionError = SegmentConstuctionError;

var ValidationArgsError =
/*#__PURE__*/
function (_Error2) {
  _inherits(ValidationArgsError, _Error2);

  function ValidationArgsError(message) {
    var _this2;

    _classCallCheck(this, ValidationArgsError);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(ValidationArgsError).call(this, message));
    Object.setPrototypeOf(_assertThisInitialized(_this2), ValidationArgsError.prototype);
    _this2.name = "ValidationArgsError";
    return _this2;
  }

  return ValidationArgsError;
}(_wrapNativeSuper(Error));

exports.ValidationArgsError = ValidationArgsError;

var RxPlayerError =
/*#__PURE__*/
function (_Error3) {
  _inherits(RxPlayerError, _Error3);

  function RxPlayerError(message) {
    var _this3;

    _classCallCheck(this, RxPlayerError);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(RxPlayerError).call(this, message));
    Object.setPrototypeOf(_assertThisInitialized(_this3), RxPlayerError.prototype);
    _this3.name = "RxPlayerError";
    return _this3;
  }

  return RxPlayerError;
}(_wrapNativeSuper(Error));

exports.RxPlayerError = RxPlayerError;

var IndexDBError =
/*#__PURE__*/
function (_Error4) {
  _inherits(IndexDBError, _Error4);

  function IndexDBError(message) {
    var _this4;

    _classCallCheck(this, IndexDBError);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(IndexDBError).call(this, message));
    Object.setPrototypeOf(_assertThisInitialized(_this4), IndexDBError.prototype);
    _this4.name = "IndexDBError";
    return _this4;
  }

  return IndexDBError;
}(_wrapNativeSuper(Error));

exports.IndexDBError = IndexDBError;
/* tslint:enable */

/**
 * Check the presence and validity of ISettingsDownloader arguments
 *
 * @param ISettingsDownloader - The arguments that the user of the lib provided
 * @returns void
 *
 */

function checkForSettingsAddMovie(_x, _x2, _x3) {
  return _checkForSettingsAddMovie.apply(this, arguments);
}

function _checkForSettingsAddMovie() {
  _checkForSettingsAddMovie = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee(settings, db, activeSubsDownloader) {
    var contentID, contentMovie;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (settings.url) {
              _context.next = 2;
              break;
            }

            throw new ValidationArgsError("URL of the MPD must be specified");

          case 2:
            contentID = settings.dbSettings.contentID;

            if (contentID) {
              _context.next = 5;
              break;
            }

            throw new ValidationArgsError("ContentID must be specified");

          case 5:
            if (!activeSubsDownloader[contentID]) {
              _context.next = 7;
              break;
            }

            throw new ValidationArgsError("The content must be resume instead of starting a new download");

          case 7:
            _context.next = 9;
            return db.get("manifests", contentID);

          case 9:
            contentMovie = _context.sent;

            if (!contentMovie) {
              _context.next = 12;
              break;
            }

            throw new ValidationArgsError("An entry with the same contentID is already present, contentID must be unique");

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _checkForSettingsAddMovie.apply(this, arguments);
}

exports.checkForSettingsAddMovie = checkForSettingsAddMovie;

function checkForResumeAPausedMovie(manifest, activeSubsDownloader) {
  if (!manifest) {
    throw new ValidationArgsError("No content has been found with the given contentID");
  }

  if (activeSubsDownloader[manifest.contentID]) {
    throw new ValidationArgsError("The content is already downloading");
  }

  if (manifest.progress === 100) {
    throw new ValidationArgsError("You can't resume a content that is already fully downloaded");
  }
}

exports.checkForResumeAPausedMovie = checkForResumeAPausedMovie;

function checkForPauseAMovie(contentID) {
  if (!contentID) {
    throw new ValidationArgsError("A valid contentID is mandatory in case of pause");
  }
}

exports.checkForPauseAMovie = checkForPauseAMovie;
/**
 * A progressBarBuilder, emit a eventName
 * 'progress' with the current progress of the download.
 *
 * @remarks
 * We can launch multiple Download function at the
 * same time so emit will also emit a contentID to know.
 *
 * @param emitter - The emitter object on we are emitting
 * @param contentID - The contentID unique by download
 * @param emitterLoaderBuilder - The id,totalSegments and
 * segmentDownladed for the current contentID movie download
 * @param IProgressBarBuilder - The object
 * where we stock the value to construct the progress bar
 * @returns number
 *
 */

function progressBuilder(_ref, progressBarBuilder) {
  var id = _ref.id,
      totalSegments = _ref.totalSegments,
      segmentDownloaded = _ref.segmentDownloaded;

  if (!array_includes_1.default(progressBarBuilder.downloadedID, id) && totalSegments) {
    progressBarBuilder.overall += totalSegments;
    progressBarBuilder.progress += segmentDownloaded;
    progressBarBuilder.downloadedID.push(id);
    return;
  }

  progressBarBuilder.progress += segmentDownloaded;
  return;
}

exports.progressBuilder = progressBuilder;
},{"../../../utils/array_includes":"../../../utils/array_includes.ts"}],"../../../../node_modules/rxjs/_esm5/internal/operators/audit.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.audit = audit;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function audit(durationSelector) {
  return function auditOperatorFunction(source) {
    return source.lift(new AuditOperator(durationSelector));
  };
}

var AuditOperator =
/*@__PURE__*/
function () {
  function AuditOperator(durationSelector) {
    this.durationSelector = durationSelector;
  }

  AuditOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
  };

  return AuditOperator;
}();

var AuditSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(AuditSubscriber, _super);

  function AuditSubscriber(destination, durationSelector) {
    var _this = _super.call(this, destination) || this;

    _this.durationSelector = durationSelector;
    _this.hasValue = false;
    return _this;
  }

  AuditSubscriber.prototype._next = function (value) {
    this.value = value;
    this.hasValue = true;

    if (!this.throttled) {
      var duration = void 0;

      try {
        var durationSelector = this.durationSelector;
        duration = durationSelector(value);
      } catch (err) {
        return this.destination.error(err);
      }

      var innerSubscription = (0, _subscribeToResult.subscribeToResult)(this, duration);

      if (!innerSubscription || innerSubscription.closed) {
        this.clearThrottle();
      } else {
        this.add(this.throttled = innerSubscription);
      }
    }
  };

  AuditSubscriber.prototype.clearThrottle = function () {
    var _a = this,
        value = _a.value,
        hasValue = _a.hasValue,
        throttled = _a.throttled;

    if (throttled) {
      this.remove(throttled);
      this.throttled = null;
      throttled.unsubscribe();
    }

    if (hasValue) {
      this.value = null;
      this.hasValue = false;
      this.destination.next(value);
    }
  };

  AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
    this.clearThrottle();
  };

  AuditSubscriber.prototype.notifyComplete = function () {
    this.clearThrottle();
  };

  return AuditSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/auditTime.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.auditTime = auditTime;

var _async = require("../scheduler/async");

var _audit = require("./audit");

var _timer = require("../observable/timer");

/** PURE_IMPORTS_START _scheduler_async,_audit,_observable_timer PURE_IMPORTS_END */
function auditTime(duration, scheduler) {
  if (scheduler === void 0) {
    scheduler = _async.async;
  }

  return (0, _audit.audit)(function () {
    return (0, _timer.timer)(duration, scheduler);
  });
}
},{"../scheduler/async":"../../../../node_modules/rxjs/_esm5/internal/scheduler/async.js","./audit":"../../../../node_modules/rxjs/_esm5/internal/operators/audit.js","../observable/timer":"../../../../node_modules/rxjs/_esm5/internal/observable/timer.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/buffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buffer = buffer;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function buffer(closingNotifier) {
  return function bufferOperatorFunction(source) {
    return source.lift(new BufferOperator(closingNotifier));
  };
}

var BufferOperator =
/*@__PURE__*/
function () {
  function BufferOperator(closingNotifier) {
    this.closingNotifier = closingNotifier;
  }

  BufferOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
  };

  return BufferOperator;
}();

var BufferSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(BufferSubscriber, _super);

  function BufferSubscriber(destination, closingNotifier) {
    var _this = _super.call(this, destination) || this;

    _this.buffer = [];

    _this.add((0, _subscribeToResult.subscribeToResult)(_this, closingNotifier));

    return _this;
  }

  BufferSubscriber.prototype._next = function (value) {
    this.buffer.push(value);
  };

  BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    var buffer = this.buffer;
    this.buffer = [];
    this.destination.next(buffer);
  };

  return BufferSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/bufferCount.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bufferCount = bufferCount;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function bufferCount(bufferSize, startBufferEvery) {
  if (startBufferEvery === void 0) {
    startBufferEvery = null;
  }

  return function bufferCountOperatorFunction(source) {
    return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
  };
}

var BufferCountOperator =
/*@__PURE__*/
function () {
  function BufferCountOperator(bufferSize, startBufferEvery) {
    this.bufferSize = bufferSize;
    this.startBufferEvery = startBufferEvery;

    if (!startBufferEvery || bufferSize === startBufferEvery) {
      this.subscriberClass = BufferCountSubscriber;
    } else {
      this.subscriberClass = BufferSkipCountSubscriber;
    }
  }

  BufferCountOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
  };

  return BufferCountOperator;
}();

var BufferCountSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(BufferCountSubscriber, _super);

  function BufferCountSubscriber(destination, bufferSize) {
    var _this = _super.call(this, destination) || this;

    _this.bufferSize = bufferSize;
    _this.buffer = [];
    return _this;
  }

  BufferCountSubscriber.prototype._next = function (value) {
    var buffer = this.buffer;
    buffer.push(value);

    if (buffer.length == this.bufferSize) {
      this.destination.next(buffer);
      this.buffer = [];
    }
  };

  BufferCountSubscriber.prototype._complete = function () {
    var buffer = this.buffer;

    if (buffer.length > 0) {
      this.destination.next(buffer);
    }

    _super.prototype._complete.call(this);
  };

  return BufferCountSubscriber;
}(_Subscriber.Subscriber);

var BufferSkipCountSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(BufferSkipCountSubscriber, _super);

  function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
    var _this = _super.call(this, destination) || this;

    _this.bufferSize = bufferSize;
    _this.startBufferEvery = startBufferEvery;
    _this.buffers = [];
    _this.count = 0;
    return _this;
  }

  BufferSkipCountSubscriber.prototype._next = function (value) {
    var _a = this,
        bufferSize = _a.bufferSize,
        startBufferEvery = _a.startBufferEvery,
        buffers = _a.buffers,
        count = _a.count;

    this.count++;

    if (count % startBufferEvery === 0) {
      buffers.push([]);
    }

    for (var i = buffers.length; i--;) {
      var buffer = buffers[i];
      buffer.push(value);

      if (buffer.length === bufferSize) {
        buffers.splice(i, 1);
        this.destination.next(buffer);
      }
    }
  };

  BufferSkipCountSubscriber.prototype._complete = function () {
    var _a = this,
        buffers = _a.buffers,
        destination = _a.destination;

    while (buffers.length > 0) {
      var buffer = buffers.shift();

      if (buffer.length > 0) {
        destination.next(buffer);
      }
    }

    _super.prototype._complete.call(this);
  };

  return BufferSkipCountSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/bufferTime.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bufferTime = bufferTime;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _async = require("../scheduler/async");

var _Subscriber = require("../Subscriber");

var _isScheduler = require("../util/isScheduler");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */
function bufferTime(bufferTimeSpan) {
  var length = arguments.length;
  var scheduler = _async.async;

  if ((0, _isScheduler.isScheduler)(arguments[arguments.length - 1])) {
    scheduler = arguments[arguments.length - 1];
    length--;
  }

  var bufferCreationInterval = null;

  if (length >= 2) {
    bufferCreationInterval = arguments[1];
  }

  var maxBufferSize = Number.POSITIVE_INFINITY;

  if (length >= 3) {
    maxBufferSize = arguments[2];
  }

  return function bufferTimeOperatorFunction(source) {
    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
  };
}

var BufferTimeOperator =
/*@__PURE__*/
function () {
  function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
    this.bufferTimeSpan = bufferTimeSpan;
    this.bufferCreationInterval = bufferCreationInterval;
    this.maxBufferSize = maxBufferSize;
    this.scheduler = scheduler;
  }

  BufferTimeOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
  };

  return BufferTimeOperator;
}();

var Context =
/*@__PURE__*/
function () {
  function Context() {
    this.buffer = [];
  }

  return Context;
}();

var BufferTimeSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(BufferTimeSubscriber, _super);

  function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
    var _this = _super.call(this, destination) || this;

    _this.bufferTimeSpan = bufferTimeSpan;
    _this.bufferCreationInterval = bufferCreationInterval;
    _this.maxBufferSize = maxBufferSize;
    _this.scheduler = scheduler;
    _this.contexts = [];

    var context = _this.openContext();

    _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;

    if (_this.timespanOnly) {
      var timeSpanOnlyState = {
        subscriber: _this,
        context: context,
        bufferTimeSpan: bufferTimeSpan
      };

      _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
    } else {
      var closeState = {
        subscriber: _this,
        context: context
      };
      var creationState = {
        bufferTimeSpan: bufferTimeSpan,
        bufferCreationInterval: bufferCreationInterval,
        subscriber: _this,
        scheduler: scheduler
      };

      _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));

      _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
    }

    return _this;
  }

  BufferTimeSubscriber.prototype._next = function (value) {
    var contexts = this.contexts;
    var len = contexts.length;
    var filledBufferContext;

    for (var i = 0; i < len; i++) {
      var context_1 = contexts[i];
      var buffer = context_1.buffer;
      buffer.push(value);

      if (buffer.length == this.maxBufferSize) {
        filledBufferContext = context_1;
      }
    }

    if (filledBufferContext) {
      this.onBufferFull(filledBufferContext);
    }
  };

  BufferTimeSubscriber.prototype._error = function (err) {
    this.contexts.length = 0;

    _super.prototype._error.call(this, err);
  };

  BufferTimeSubscriber.prototype._complete = function () {
    var _a = this,
        contexts = _a.contexts,
        destination = _a.destination;

    while (contexts.length > 0) {
      var context_2 = contexts.shift();
      destination.next(context_2.buffer);
    }

    _super.prototype._complete.call(this);
  };

  BufferTimeSubscriber.prototype._unsubscribe = function () {
    this.contexts = null;
  };

  BufferTimeSubscriber.prototype.onBufferFull = function (context) {
    this.closeContext(context);
    var closeAction = context.closeAction;
    closeAction.unsubscribe();
    this.remove(closeAction);

    if (!this.closed && this.timespanOnly) {
      context = this.openContext();
      var bufferTimeSpan = this.bufferTimeSpan;
      var timeSpanOnlyState = {
        subscriber: this,
        context: context,
        bufferTimeSpan: bufferTimeSpan
      };
      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
    }
  };

  BufferTimeSubscriber.prototype.openContext = function () {
    var context = new Context();
    this.contexts.push(context);
    return context;
  };

  BufferTimeSubscriber.prototype.closeContext = function (context) {
    this.destination.next(context.buffer);
    var contexts = this.contexts;
    var spliceIndex = contexts ? contexts.indexOf(context) : -1;

    if (spliceIndex >= 0) {
      contexts.splice(contexts.indexOf(context), 1);
    }
  };

  return BufferTimeSubscriber;
}(_Subscriber.Subscriber);

function dispatchBufferTimeSpanOnly(state) {
  var subscriber = state.subscriber;
  var prevContext = state.context;

  if (prevContext) {
    subscriber.closeContext(prevContext);
  }

  if (!subscriber.closed) {
    state.context = subscriber.openContext();
    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
  }
}

function dispatchBufferCreation(state) {
  var bufferCreationInterval = state.bufferCreationInterval,
      bufferTimeSpan = state.bufferTimeSpan,
      subscriber = state.subscriber,
      scheduler = state.scheduler;
  var context = subscriber.openContext();
  var action = this;

  if (!subscriber.closed) {
    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {
      subscriber: subscriber,
      context: context
    }));
    action.schedule(state, bufferCreationInterval);
  }
}

function dispatchBufferClose(arg) {
  var subscriber = arg.subscriber,
      context = arg.context;
  subscriber.closeContext(context);
}
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../scheduler/async":"../../../../node_modules/rxjs/_esm5/internal/scheduler/async.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../util/isScheduler":"../../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/bufferToggle.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bufferToggle = bufferToggle;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscription = require("../Subscription");

var _subscribeToResult = require("../util/subscribeToResult");

var _OuterSubscriber = require("../OuterSubscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscription,_util_subscribeToResult,_OuterSubscriber PURE_IMPORTS_END */
function bufferToggle(openings, closingSelector) {
  return function bufferToggleOperatorFunction(source) {
    return source.lift(new BufferToggleOperator(openings, closingSelector));
  };
}

var BufferToggleOperator =
/*@__PURE__*/
function () {
  function BufferToggleOperator(openings, closingSelector) {
    this.openings = openings;
    this.closingSelector = closingSelector;
  }

  BufferToggleOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
  };

  return BufferToggleOperator;
}();

var BufferToggleSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(BufferToggleSubscriber, _super);

  function BufferToggleSubscriber(destination, openings, closingSelector) {
    var _this = _super.call(this, destination) || this;

    _this.openings = openings;
    _this.closingSelector = closingSelector;
    _this.contexts = [];

    _this.add((0, _subscribeToResult.subscribeToResult)(_this, openings));

    return _this;
  }

  BufferToggleSubscriber.prototype._next = function (value) {
    var contexts = this.contexts;
    var len = contexts.length;

    for (var i = 0; i < len; i++) {
      contexts[i].buffer.push(value);
    }
  };

  BufferToggleSubscriber.prototype._error = function (err) {
    var contexts = this.contexts;

    while (contexts.length > 0) {
      var context_1 = contexts.shift();
      context_1.subscription.unsubscribe();
      context_1.buffer = null;
      context_1.subscription = null;
    }

    this.contexts = null;

    _super.prototype._error.call(this, err);
  };

  BufferToggleSubscriber.prototype._complete = function () {
    var contexts = this.contexts;

    while (contexts.length > 0) {
      var context_2 = contexts.shift();
      this.destination.next(context_2.buffer);
      context_2.subscription.unsubscribe();
      context_2.buffer = null;
      context_2.subscription = null;
    }

    this.contexts = null;

    _super.prototype._complete.call(this);
  };

  BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
  };

  BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
    this.closeBuffer(innerSub.context);
  };

  BufferToggleSubscriber.prototype.openBuffer = function (value) {
    try {
      var closingSelector = this.closingSelector;
      var closingNotifier = closingSelector.call(this, value);

      if (closingNotifier) {
        this.trySubscribe(closingNotifier);
      }
    } catch (err) {
      this._error(err);
    }
  };

  BufferToggleSubscriber.prototype.closeBuffer = function (context) {
    var contexts = this.contexts;

    if (contexts && context) {
      var buffer = context.buffer,
          subscription = context.subscription;
      this.destination.next(buffer);
      contexts.splice(contexts.indexOf(context), 1);
      this.remove(subscription);
      subscription.unsubscribe();
    }
  };

  BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
    var contexts = this.contexts;
    var buffer = [];
    var subscription = new _Subscription.Subscription();
    var context = {
      buffer: buffer,
      subscription: subscription
    };
    contexts.push(context);
    var innerSubscription = (0, _subscribeToResult.subscribeToResult)(this, closingNotifier, context);

    if (!innerSubscription || innerSubscription.closed) {
      this.closeBuffer(context);
    } else {
      innerSubscription.context = context;
      this.add(innerSubscription);
      subscription.add(innerSubscription);
    }
  };

  return BufferToggleSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscription":"../../../../node_modules/rxjs/_esm5/internal/Subscription.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/bufferWhen.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bufferWhen = bufferWhen;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscription = require("../Subscription");

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscription,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function bufferWhen(closingSelector) {
  return function (source) {
    return source.lift(new BufferWhenOperator(closingSelector));
  };
}

var BufferWhenOperator =
/*@__PURE__*/
function () {
  function BufferWhenOperator(closingSelector) {
    this.closingSelector = closingSelector;
  }

  BufferWhenOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
  };

  return BufferWhenOperator;
}();

var BufferWhenSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(BufferWhenSubscriber, _super);

  function BufferWhenSubscriber(destination, closingSelector) {
    var _this = _super.call(this, destination) || this;

    _this.closingSelector = closingSelector;
    _this.subscribing = false;

    _this.openBuffer();

    return _this;
  }

  BufferWhenSubscriber.prototype._next = function (value) {
    this.buffer.push(value);
  };

  BufferWhenSubscriber.prototype._complete = function () {
    var buffer = this.buffer;

    if (buffer) {
      this.destination.next(buffer);
    }

    _super.prototype._complete.call(this);
  };

  BufferWhenSubscriber.prototype._unsubscribe = function () {
    this.buffer = null;
    this.subscribing = false;
  };

  BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.openBuffer();
  };

  BufferWhenSubscriber.prototype.notifyComplete = function () {
    if (this.subscribing) {
      this.complete();
    } else {
      this.openBuffer();
    }
  };

  BufferWhenSubscriber.prototype.openBuffer = function () {
    var closingSubscription = this.closingSubscription;

    if (closingSubscription) {
      this.remove(closingSubscription);
      closingSubscription.unsubscribe();
    }

    var buffer = this.buffer;

    if (this.buffer) {
      this.destination.next(buffer);
    }

    this.buffer = [];
    var closingNotifier;

    try {
      var closingSelector = this.closingSelector;
      closingNotifier = closingSelector();
    } catch (err) {
      return this.error(err);
    }

    closingSubscription = new _Subscription.Subscription();
    this.closingSubscription = closingSubscription;
    this.add(closingSubscription);
    this.subscribing = true;
    closingSubscription.add((0, _subscribeToResult.subscribeToResult)(this, closingNotifier));
    this.subscribing = false;
  };

  return BufferWhenSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscription":"../../../../node_modules/rxjs/_esm5/internal/Subscription.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/catchError.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.catchError = catchError;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _OuterSubscriber = require("../OuterSubscriber");

var _InnerSubscriber = require("../InnerSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function catchError(selector) {
  return function catchErrorOperatorFunction(source) {
    var operator = new CatchOperator(selector);
    var caught = source.lift(operator);
    return operator.caught = caught;
  };
}

var CatchOperator =
/*@__PURE__*/
function () {
  function CatchOperator(selector) {
    this.selector = selector;
  }

  CatchOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
  };

  return CatchOperator;
}();

var CatchSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(CatchSubscriber, _super);

  function CatchSubscriber(destination, selector, caught) {
    var _this = _super.call(this, destination) || this;

    _this.selector = selector;
    _this.caught = caught;
    return _this;
  }

  CatchSubscriber.prototype.error = function (err) {
    if (!this.isStopped) {
      var result = void 0;

      try {
        result = this.selector(err, this.caught);
      } catch (err2) {
        _super.prototype.error.call(this, err2);

        return;
      }

      this._unsubscribeAndRecycle();

      var innerSubscriber = new _InnerSubscriber.InnerSubscriber(this, undefined, undefined);
      this.add(innerSubscriber);
      (0, _subscribeToResult.subscribeToResult)(this, result, undefined, undefined, innerSubscriber);
    }
  };

  return CatchSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../InnerSubscriber":"../../../../node_modules/rxjs/_esm5/internal/InnerSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/combineAll.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.combineAll = combineAll;

var _combineLatest = require("../observable/combineLatest");

/** PURE_IMPORTS_START _observable_combineLatest PURE_IMPORTS_END */
function combineAll(project) {
  return function (source) {
    return source.lift(new _combineLatest.CombineLatestOperator(project));
  };
}
},{"../observable/combineLatest":"../../../../node_modules/rxjs/_esm5/internal/observable/combineLatest.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/combineLatest.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.combineLatest = combineLatest;

var _isArray = require("../util/isArray");

var _combineLatest = require("../observable/combineLatest");

var _from = require("../observable/from");

/** PURE_IMPORTS_START _util_isArray,_observable_combineLatest,_observable_from PURE_IMPORTS_END */
var none = {};

function combineLatest() {
  var observables = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }

  var project = null;

  if (typeof observables[observables.length - 1] === 'function') {
    project = observables.pop();
  }

  if (observables.length === 1 && (0, _isArray.isArray)(observables[0])) {
    observables = observables[0].slice();
  }

  return function (source) {
    return source.lift.call((0, _from.from)([source].concat(observables)), new _combineLatest.CombineLatestOperator(project));
  };
}
},{"../util/isArray":"../../../../node_modules/rxjs/_esm5/internal/util/isArray.js","../observable/combineLatest":"../../../../node_modules/rxjs/_esm5/internal/observable/combineLatest.js","../observable/from":"../../../../node_modules/rxjs/_esm5/internal/observable/from.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/concat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.concat = concat;

var _concat = require("../observable/concat");

/** PURE_IMPORTS_START _observable_concat PURE_IMPORTS_END */
function concat() {
  var observables = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }

  return function (source) {
    return source.lift.call(_concat.concat.apply(void 0, [source].concat(observables)));
  };
}
},{"../observable/concat":"../../../../node_modules/rxjs/_esm5/internal/observable/concat.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/concatMap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.concatMap = concatMap;

var _mergeMap = require("./mergeMap");

/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */
function concatMap(project, resultSelector) {
  return (0, _mergeMap.mergeMap)(project, resultSelector, 1);
}
},{"./mergeMap":"../../../../node_modules/rxjs/_esm5/internal/operators/mergeMap.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/concatMapTo.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.concatMapTo = concatMapTo;

var _concatMap = require("./concatMap");

/** PURE_IMPORTS_START _concatMap PURE_IMPORTS_END */
function concatMapTo(innerObservable, resultSelector) {
  return (0, _concatMap.concatMap)(function () {
    return innerObservable;
  }, resultSelector);
}
},{"./concatMap":"../../../../node_modules/rxjs/_esm5/internal/operators/concatMap.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/count.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.count = count;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function count(predicate) {
  return function (source) {
    return source.lift(new CountOperator(predicate, source));
  };
}

var CountOperator =
/*@__PURE__*/
function () {
  function CountOperator(predicate, source) {
    this.predicate = predicate;
    this.source = source;
  }

  CountOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
  };

  return CountOperator;
}();

var CountSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(CountSubscriber, _super);

  function CountSubscriber(destination, predicate, source) {
    var _this = _super.call(this, destination) || this;

    _this.predicate = predicate;
    _this.source = source;
    _this.count = 0;
    _this.index = 0;
    return _this;
  }

  CountSubscriber.prototype._next = function (value) {
    if (this.predicate) {
      this._tryPredicate(value);
    } else {
      this.count++;
    }
  };

  CountSubscriber.prototype._tryPredicate = function (value) {
    var result;

    try {
      result = this.predicate(value, this.index++, this.source);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    if (result) {
      this.count++;
    }
  };

  CountSubscriber.prototype._complete = function () {
    this.destination.next(this.count);
    this.destination.complete();
  };

  return CountSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/debounce.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.debounce = debounce;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function debounce(durationSelector) {
  return function (source) {
    return source.lift(new DebounceOperator(durationSelector));
  };
}

var DebounceOperator =
/*@__PURE__*/
function () {
  function DebounceOperator(durationSelector) {
    this.durationSelector = durationSelector;
  }

  DebounceOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
  };

  return DebounceOperator;
}();

var DebounceSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(DebounceSubscriber, _super);

  function DebounceSubscriber(destination, durationSelector) {
    var _this = _super.call(this, destination) || this;

    _this.durationSelector = durationSelector;
    _this.hasValue = false;
    _this.durationSubscription = null;
    return _this;
  }

  DebounceSubscriber.prototype._next = function (value) {
    try {
      var result = this.durationSelector.call(this, value);

      if (result) {
        this._tryNext(value, result);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };

  DebounceSubscriber.prototype._complete = function () {
    this.emitValue();
    this.destination.complete();
  };

  DebounceSubscriber.prototype._tryNext = function (value, duration) {
    var subscription = this.durationSubscription;
    this.value = value;
    this.hasValue = true;

    if (subscription) {
      subscription.unsubscribe();
      this.remove(subscription);
    }

    subscription = (0, _subscribeToResult.subscribeToResult)(this, duration);

    if (subscription && !subscription.closed) {
      this.add(this.durationSubscription = subscription);
    }
  };

  DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.emitValue();
  };

  DebounceSubscriber.prototype.notifyComplete = function () {
    this.emitValue();
  };

  DebounceSubscriber.prototype.emitValue = function () {
    if (this.hasValue) {
      var value = this.value;
      var subscription = this.durationSubscription;

      if (subscription) {
        this.durationSubscription = null;
        subscription.unsubscribe();
        this.remove(subscription);
      }

      this.value = null;
      this.hasValue = false;

      _super.prototype._next.call(this, value);
    }
  };

  return DebounceSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/debounceTime.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.debounceTime = debounceTime;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

var _async = require("../scheduler/async");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = _async.async;
  }

  return function (source) {
    return source.lift(new DebounceTimeOperator(dueTime, scheduler));
  };
}

var DebounceTimeOperator =
/*@__PURE__*/
function () {
  function DebounceTimeOperator(dueTime, scheduler) {
    this.dueTime = dueTime;
    this.scheduler = scheduler;
  }

  DebounceTimeOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
  };

  return DebounceTimeOperator;
}();

var DebounceTimeSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(DebounceTimeSubscriber, _super);

  function DebounceTimeSubscriber(destination, dueTime, scheduler) {
    var _this = _super.call(this, destination) || this;

    _this.dueTime = dueTime;
    _this.scheduler = scheduler;
    _this.debouncedSubscription = null;
    _this.lastValue = null;
    _this.hasValue = false;
    return _this;
  }

  DebounceTimeSubscriber.prototype._next = function (value) {
    this.clearDebounce();
    this.lastValue = value;
    this.hasValue = true;
    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
  };

  DebounceTimeSubscriber.prototype._complete = function () {
    this.debouncedNext();
    this.destination.complete();
  };

  DebounceTimeSubscriber.prototype.debouncedNext = function () {
    this.clearDebounce();

    if (this.hasValue) {
      var lastValue = this.lastValue;
      this.lastValue = null;
      this.hasValue = false;
      this.destination.next(lastValue);
    }
  };

  DebounceTimeSubscriber.prototype.clearDebounce = function () {
    var debouncedSubscription = this.debouncedSubscription;

    if (debouncedSubscription !== null) {
      this.remove(debouncedSubscription);
      debouncedSubscription.unsubscribe();
      this.debouncedSubscription = null;
    }
  };

  return DebounceTimeSubscriber;
}(_Subscriber.Subscriber);

function dispatchNext(subscriber) {
  subscriber.debouncedNext();
}
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../scheduler/async":"../../../../node_modules/rxjs/_esm5/internal/scheduler/async.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultIfEmpty = defaultIfEmpty;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function defaultIfEmpty(defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = null;
  }

  return function (source) {
    return source.lift(new DefaultIfEmptyOperator(defaultValue));
  };
}

var DefaultIfEmptyOperator =
/*@__PURE__*/
function () {
  function DefaultIfEmptyOperator(defaultValue) {
    this.defaultValue = defaultValue;
  }

  DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
  };

  return DefaultIfEmptyOperator;
}();

var DefaultIfEmptySubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(DefaultIfEmptySubscriber, _super);

  function DefaultIfEmptySubscriber(destination, defaultValue) {
    var _this = _super.call(this, destination) || this;

    _this.defaultValue = defaultValue;
    _this.isEmpty = true;
    return _this;
  }

  DefaultIfEmptySubscriber.prototype._next = function (value) {
    this.isEmpty = false;
    this.destination.next(value);
  };

  DefaultIfEmptySubscriber.prototype._complete = function () {
    if (this.isEmpty) {
      this.destination.next(this.defaultValue);
    }

    this.destination.complete();
  };

  return DefaultIfEmptySubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/util/isDate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDate = isDate;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isDate(value) {
  return value instanceof Date && !isNaN(+value);
}
},{}],"../../../../node_modules/rxjs/_esm5/internal/operators/delay.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.delay = delay;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _async = require("../scheduler/async");

var _isDate = require("../util/isDate");

var _Subscriber = require("../Subscriber");

var _Notification = require("../Notification");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */
function delay(delay, scheduler) {
  if (scheduler === void 0) {
    scheduler = _async.async;
  }

  var absoluteDelay = (0, _isDate.isDate)(delay);
  var delayFor = absoluteDelay ? +delay - scheduler.now() : Math.abs(delay);
  return function (source) {
    return source.lift(new DelayOperator(delayFor, scheduler));
  };
}

var DelayOperator =
/*@__PURE__*/
function () {
  function DelayOperator(delay, scheduler) {
    this.delay = delay;
    this.scheduler = scheduler;
  }

  DelayOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
  };

  return DelayOperator;
}();

var DelaySubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(DelaySubscriber, _super);

  function DelaySubscriber(destination, delay, scheduler) {
    var _this = _super.call(this, destination) || this;

    _this.delay = delay;
    _this.scheduler = scheduler;
    _this.queue = [];
    _this.active = false;
    _this.errored = false;
    return _this;
  }

  DelaySubscriber.dispatch = function (state) {
    var source = state.source;
    var queue = source.queue;
    var scheduler = state.scheduler;
    var destination = state.destination;

    while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
      queue.shift().notification.observe(destination);
    }

    if (queue.length > 0) {
      var delay_1 = Math.max(0, queue[0].time - scheduler.now());
      this.schedule(state, delay_1);
    } else {
      this.unsubscribe();
      source.active = false;
    }
  };

  DelaySubscriber.prototype._schedule = function (scheduler) {
    this.active = true;
    var destination = this.destination;
    destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
      source: this,
      destination: this.destination,
      scheduler: scheduler
    }));
  };

  DelaySubscriber.prototype.scheduleNotification = function (notification) {
    if (this.errored === true) {
      return;
    }

    var scheduler = this.scheduler;
    var message = new DelayMessage(scheduler.now() + this.delay, notification);
    this.queue.push(message);

    if (this.active === false) {
      this._schedule(scheduler);
    }
  };

  DelaySubscriber.prototype._next = function (value) {
    this.scheduleNotification(_Notification.Notification.createNext(value));
  };

  DelaySubscriber.prototype._error = function (err) {
    this.errored = true;
    this.queue = [];
    this.destination.error(err);
    this.unsubscribe();
  };

  DelaySubscriber.prototype._complete = function () {
    this.scheduleNotification(_Notification.Notification.createComplete());
    this.unsubscribe();
  };

  return DelaySubscriber;
}(_Subscriber.Subscriber);

var DelayMessage =
/*@__PURE__*/
function () {
  function DelayMessage(time, notification) {
    this.time = time;
    this.notification = notification;
  }

  return DelayMessage;
}();
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../scheduler/async":"../../../../node_modules/rxjs/_esm5/internal/scheduler/async.js","../util/isDate":"../../../../node_modules/rxjs/_esm5/internal/util/isDate.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../Notification":"../../../../node_modules/rxjs/_esm5/internal/Notification.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/delayWhen.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.delayWhen = delayWhen;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

var _Observable = require("../Observable");

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function (source) {
      return new SubscriptionDelayObservable(source, subscriptionDelay).lift(new DelayWhenOperator(delayDurationSelector));
    };
  }

  return function (source) {
    return source.lift(new DelayWhenOperator(delayDurationSelector));
  };
}

var DelayWhenOperator =
/*@__PURE__*/
function () {
  function DelayWhenOperator(delayDurationSelector) {
    this.delayDurationSelector = delayDurationSelector;
  }

  DelayWhenOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
  };

  return DelayWhenOperator;
}();

var DelayWhenSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(DelayWhenSubscriber, _super);

  function DelayWhenSubscriber(destination, delayDurationSelector) {
    var _this = _super.call(this, destination) || this;

    _this.delayDurationSelector = delayDurationSelector;
    _this.completed = false;
    _this.delayNotifierSubscriptions = [];
    _this.index = 0;
    return _this;
  }

  DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(outerValue);
    this.removeSubscription(innerSub);
    this.tryComplete();
  };

  DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
    this._error(error);
  };

  DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
    var value = this.removeSubscription(innerSub);

    if (value) {
      this.destination.next(value);
    }

    this.tryComplete();
  };

  DelayWhenSubscriber.prototype._next = function (value) {
    var index = this.index++;

    try {
      var delayNotifier = this.delayDurationSelector(value, index);

      if (delayNotifier) {
        this.tryDelay(delayNotifier, value);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };

  DelayWhenSubscriber.prototype._complete = function () {
    this.completed = true;
    this.tryComplete();
    this.unsubscribe();
  };

  DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
    subscription.unsubscribe();
    var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);

    if (subscriptionIdx !== -1) {
      this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
    }

    return subscription.outerValue;
  };

  DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
    var notifierSubscription = (0, _subscribeToResult.subscribeToResult)(this, delayNotifier, value);

    if (notifierSubscription && !notifierSubscription.closed) {
      var destination = this.destination;
      destination.add(notifierSubscription);
      this.delayNotifierSubscriptions.push(notifierSubscription);
    }
  };

  DelayWhenSubscriber.prototype.tryComplete = function () {
    if (this.completed && this.delayNotifierSubscriptions.length === 0) {
      this.destination.complete();
    }
  };

  return DelayWhenSubscriber;
}(_OuterSubscriber.OuterSubscriber);

var SubscriptionDelayObservable =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(SubscriptionDelayObservable, _super);

  function SubscriptionDelayObservable(source, subscriptionDelay) {
    var _this = _super.call(this) || this;

    _this.source = source;
    _this.subscriptionDelay = subscriptionDelay;
    return _this;
  }

  SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
  };

  return SubscriptionDelayObservable;
}(_Observable.Observable);

var SubscriptionDelaySubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(SubscriptionDelaySubscriber, _super);

  function SubscriptionDelaySubscriber(parent, source) {
    var _this = _super.call(this) || this;

    _this.parent = parent;
    _this.source = source;
    _this.sourceSubscribed = false;
    return _this;
  }

  SubscriptionDelaySubscriber.prototype._next = function (unused) {
    this.subscribeToSource();
  };

  SubscriptionDelaySubscriber.prototype._error = function (err) {
    this.unsubscribe();
    this.parent.error(err);
  };

  SubscriptionDelaySubscriber.prototype._complete = function () {
    this.unsubscribe();
    this.subscribeToSource();
  };

  SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
    if (!this.sourceSubscribed) {
      this.sourceSubscribed = true;
      this.unsubscribe();
      this.source.subscribe(this.parent);
    }
  };

  return SubscriptionDelaySubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/dematerialize.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dematerialize = dematerialize;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function dematerialize() {
  return function dematerializeOperatorFunction(source) {
    return source.lift(new DeMaterializeOperator());
  };
}

var DeMaterializeOperator =
/*@__PURE__*/
function () {
  function DeMaterializeOperator() {}

  DeMaterializeOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new DeMaterializeSubscriber(subscriber));
  };

  return DeMaterializeOperator;
}();

var DeMaterializeSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(DeMaterializeSubscriber, _super);

  function DeMaterializeSubscriber(destination) {
    return _super.call(this, destination) || this;
  }

  DeMaterializeSubscriber.prototype._next = function (value) {
    value.observe(this.destination);
  };

  return DeMaterializeSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/distinct.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.distinct = distinct;
exports.DistinctSubscriber = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function distinct(keySelector, flushes) {
  return function (source) {
    return source.lift(new DistinctOperator(keySelector, flushes));
  };
}

var DistinctOperator =
/*@__PURE__*/
function () {
  function DistinctOperator(keySelector, flushes) {
    this.keySelector = keySelector;
    this.flushes = flushes;
  }

  DistinctOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
  };

  return DistinctOperator;
}();

var DistinctSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(DistinctSubscriber, _super);

  function DistinctSubscriber(destination, keySelector, flushes) {
    var _this = _super.call(this, destination) || this;

    _this.keySelector = keySelector;
    _this.values = new Set();

    if (flushes) {
      _this.add((0, _subscribeToResult.subscribeToResult)(_this, flushes));
    }

    return _this;
  }

  DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.values.clear();
  };

  DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
    this._error(error);
  };

  DistinctSubscriber.prototype._next = function (value) {
    if (this.keySelector) {
      this._useKeySelector(value);
    } else {
      this._finalizeNext(value, value);
    }
  };

  DistinctSubscriber.prototype._useKeySelector = function (value) {
    var key;
    var destination = this.destination;

    try {
      key = this.keySelector(value);
    } catch (err) {
      destination.error(err);
      return;
    }

    this._finalizeNext(key, value);
  };

  DistinctSubscriber.prototype._finalizeNext = function (key, value) {
    var values = this.values;

    if (!values.has(key)) {
      values.add(key);
      this.destination.next(value);
    }
  };

  return DistinctSubscriber;
}(_OuterSubscriber.OuterSubscriber);

exports.DistinctSubscriber = DistinctSubscriber;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.distinctUntilChanged = distinctUntilChanged;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function distinctUntilChanged(compare, keySelector) {
  return function (source) {
    return source.lift(new DistinctUntilChangedOperator(compare, keySelector));
  };
}

var DistinctUntilChangedOperator =
/*@__PURE__*/
function () {
  function DistinctUntilChangedOperator(compare, keySelector) {
    this.compare = compare;
    this.keySelector = keySelector;
  }

  DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
  };

  return DistinctUntilChangedOperator;
}();

var DistinctUntilChangedSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(DistinctUntilChangedSubscriber, _super);

  function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
    var _this = _super.call(this, destination) || this;

    _this.keySelector = keySelector;
    _this.hasKey = false;

    if (typeof compare === 'function') {
      _this.compare = compare;
    }

    return _this;
  }

  DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
    return x === y;
  };

  DistinctUntilChangedSubscriber.prototype._next = function (value) {
    var key;

    try {
      var keySelector = this.keySelector;
      key = keySelector ? keySelector(value) : value;
    } catch (err) {
      return this.destination.error(err);
    }

    var result = false;

    if (this.hasKey) {
      try {
        var compare = this.compare;
        result = compare(this.key, key);
      } catch (err) {
        return this.destination.error(err);
      }
    } else {
      this.hasKey = true;
    }

    if (!result) {
      this.key = key;
      this.destination.next(value);
    }
  };

  return DistinctUntilChangedSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/distinctUntilKeyChanged.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.distinctUntilKeyChanged = distinctUntilKeyChanged;

var _distinctUntilChanged = require("./distinctUntilChanged");

/** PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END */
function distinctUntilKeyChanged(key, compare) {
  return (0, _distinctUntilChanged.distinctUntilChanged)(function (x, y) {
    return compare ? compare(x[key], y[key]) : x[key] === y[key];
  });
}
},{"./distinctUntilChanged":"../../../../node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.throwIfEmpty = throwIfEmpty;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _EmptyError = require("../util/EmptyError");

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_util_EmptyError,_Subscriber PURE_IMPORTS_END */
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }

  return function (source) {
    return source.lift(new ThrowIfEmptyOperator(errorFactory));
  };
}

var ThrowIfEmptyOperator =
/*@__PURE__*/
function () {
  function ThrowIfEmptyOperator(errorFactory) {
    this.errorFactory = errorFactory;
  }

  ThrowIfEmptyOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
  };

  return ThrowIfEmptyOperator;
}();

var ThrowIfEmptySubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(ThrowIfEmptySubscriber, _super);

  function ThrowIfEmptySubscriber(destination, errorFactory) {
    var _this = _super.call(this, destination) || this;

    _this.errorFactory = errorFactory;
    _this.hasValue = false;
    return _this;
  }

  ThrowIfEmptySubscriber.prototype._next = function (value) {
    this.hasValue = true;
    this.destination.next(value);
  };

  ThrowIfEmptySubscriber.prototype._complete = function () {
    if (!this.hasValue) {
      var err = void 0;

      try {
        err = this.errorFactory();
      } catch (e) {
        err = e;
      }

      this.destination.error(err);
    } else {
      return this.destination.complete();
    }
  };

  return ThrowIfEmptySubscriber;
}(_Subscriber.Subscriber);

function defaultErrorFactory() {
  return new _EmptyError.EmptyError();
}
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../util/EmptyError":"../../../../node_modules/rxjs/_esm5/internal/util/EmptyError.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/take.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.take = take;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

var _ArgumentOutOfRangeError = require("../util/ArgumentOutOfRangeError");

var _empty = require("../observable/empty");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
function take(count) {
  return function (source) {
    if (count === 0) {
      return (0, _empty.empty)();
    } else {
      return source.lift(new TakeOperator(count));
    }
  };
}

var TakeOperator =
/*@__PURE__*/
function () {
  function TakeOperator(total) {
    this.total = total;

    if (this.total < 0) {
      throw new _ArgumentOutOfRangeError.ArgumentOutOfRangeError();
    }
  }

  TakeOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new TakeSubscriber(subscriber, this.total));
  };

  return TakeOperator;
}();

var TakeSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(TakeSubscriber, _super);

  function TakeSubscriber(destination, total) {
    var _this = _super.call(this, destination) || this;

    _this.total = total;
    _this.count = 0;
    return _this;
  }

  TakeSubscriber.prototype._next = function (value) {
    var total = this.total;
    var count = ++this.count;

    if (count <= total) {
      this.destination.next(value);

      if (count === total) {
        this.destination.complete();
        this.unsubscribe();
      }
    }
  };

  return TakeSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../util/ArgumentOutOfRangeError":"../../../../node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js","../observable/empty":"../../../../node_modules/rxjs/_esm5/internal/observable/empty.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/elementAt.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.elementAt = elementAt;

var _ArgumentOutOfRangeError = require("../util/ArgumentOutOfRangeError");

var _filter = require("./filter");

var _throwIfEmpty = require("./throwIfEmpty");

var _defaultIfEmpty = require("./defaultIfEmpty");

var _take = require("./take");

/** PURE_IMPORTS_START _util_ArgumentOutOfRangeError,_filter,_throwIfEmpty,_defaultIfEmpty,_take PURE_IMPORTS_END */
function elementAt(index, defaultValue) {
  if (index < 0) {
    throw new _ArgumentOutOfRangeError.ArgumentOutOfRangeError();
  }

  var hasDefaultValue = arguments.length >= 2;
  return function (source) {
    return source.pipe((0, _filter.filter)(function (v, i) {
      return i === index;
    }), (0, _take.take)(1), hasDefaultValue ? (0, _defaultIfEmpty.defaultIfEmpty)(defaultValue) : (0, _throwIfEmpty.throwIfEmpty)(function () {
      return new _ArgumentOutOfRangeError.ArgumentOutOfRangeError();
    }));
  };
}
},{"../util/ArgumentOutOfRangeError":"../../../../node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js","./filter":"../../../../node_modules/rxjs/_esm5/internal/operators/filter.js","./throwIfEmpty":"../../../../node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js","./defaultIfEmpty":"../../../../node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js","./take":"../../../../node_modules/rxjs/_esm5/internal/operators/take.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/endWith.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.endWith = endWith;

var _concat = require("../observable/concat");

var _of = require("../observable/of");

/** PURE_IMPORTS_START _observable_concat,_observable_of PURE_IMPORTS_END */
function endWith() {
  var array = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    array[_i] = arguments[_i];
  }

  return function (source) {
    return (0, _concat.concat)(source, _of.of.apply(void 0, array));
  };
}
},{"../observable/concat":"../../../../node_modules/rxjs/_esm5/internal/observable/concat.js","../observable/of":"../../../../node_modules/rxjs/_esm5/internal/observable/of.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/every.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.every = every;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function every(predicate, thisArg) {
  return function (source) {
    return source.lift(new EveryOperator(predicate, thisArg, source));
  };
}

var EveryOperator =
/*@__PURE__*/
function () {
  function EveryOperator(predicate, thisArg, source) {
    this.predicate = predicate;
    this.thisArg = thisArg;
    this.source = source;
  }

  EveryOperator.prototype.call = function (observer, source) {
    return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
  };

  return EveryOperator;
}();

var EverySubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(EverySubscriber, _super);

  function EverySubscriber(destination, predicate, thisArg, source) {
    var _this = _super.call(this, destination) || this;

    _this.predicate = predicate;
    _this.thisArg = thisArg;
    _this.source = source;
    _this.index = 0;
    _this.thisArg = thisArg || _this;
    return _this;
  }

  EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
    this.destination.next(everyValueMatch);
    this.destination.complete();
  };

  EverySubscriber.prototype._next = function (value) {
    var result = false;

    try {
      result = this.predicate.call(this.thisArg, value, this.index++, this.source);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    if (!result) {
      this.notifyComplete(false);
    }
  };

  EverySubscriber.prototype._complete = function () {
    this.notifyComplete(true);
  };

  return EverySubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/exhaust.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.exhaust = exhaust;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function exhaust() {
  return function (source) {
    return source.lift(new SwitchFirstOperator());
  };
}

var SwitchFirstOperator =
/*@__PURE__*/
function () {
  function SwitchFirstOperator() {}

  SwitchFirstOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new SwitchFirstSubscriber(subscriber));
  };

  return SwitchFirstOperator;
}();

var SwitchFirstSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(SwitchFirstSubscriber, _super);

  function SwitchFirstSubscriber(destination) {
    var _this = _super.call(this, destination) || this;

    _this.hasCompleted = false;
    _this.hasSubscription = false;
    return _this;
  }

  SwitchFirstSubscriber.prototype._next = function (value) {
    if (!this.hasSubscription) {
      this.hasSubscription = true;
      this.add((0, _subscribeToResult.subscribeToResult)(this, value));
    }
  };

  SwitchFirstSubscriber.prototype._complete = function () {
    this.hasCompleted = true;

    if (!this.hasSubscription) {
      this.destination.complete();
    }
  };

  SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
    this.remove(innerSub);
    this.hasSubscription = false;

    if (this.hasCompleted) {
      this.destination.complete();
    }
  };

  return SwitchFirstSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/exhaustMap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.exhaustMap = exhaustMap;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _OuterSubscriber = require("../OuterSubscriber");

var _InnerSubscriber = require("../InnerSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

var _map = require("./map");

var _from = require("../observable/from");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function (source) {
      return source.pipe(exhaustMap(function (a, i) {
        return (0, _from.from)(project(a, i)).pipe((0, _map.map)(function (b, ii) {
          return resultSelector(a, b, i, ii);
        }));
      }));
    };
  }

  return function (source) {
    return source.lift(new ExhaustMapOperator(project));
  };
}

var ExhaustMapOperator =
/*@__PURE__*/
function () {
  function ExhaustMapOperator(project) {
    this.project = project;
  }

  ExhaustMapOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
  };

  return ExhaustMapOperator;
}();

var ExhaustMapSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(ExhaustMapSubscriber, _super);

  function ExhaustMapSubscriber(destination, project) {
    var _this = _super.call(this, destination) || this;

    _this.project = project;
    _this.hasSubscription = false;
    _this.hasCompleted = false;
    _this.index = 0;
    return _this;
  }

  ExhaustMapSubscriber.prototype._next = function (value) {
    if (!this.hasSubscription) {
      this.tryNext(value);
    }
  };

  ExhaustMapSubscriber.prototype.tryNext = function (value) {
    var result;
    var index = this.index++;

    try {
      result = this.project(value, index);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    this.hasSubscription = true;

    this._innerSub(result, value, index);
  };

  ExhaustMapSubscriber.prototype._innerSub = function (result, value, index) {
    var innerSubscriber = new _InnerSubscriber.InnerSubscriber(this, undefined, undefined);
    var destination = this.destination;
    destination.add(innerSubscriber);
    (0, _subscribeToResult.subscribeToResult)(this, result, value, index, innerSubscriber);
  };

  ExhaustMapSubscriber.prototype._complete = function () {
    this.hasCompleted = true;

    if (!this.hasSubscription) {
      this.destination.complete();
    }

    this.unsubscribe();
  };

  ExhaustMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  };

  ExhaustMapSubscriber.prototype.notifyError = function (err) {
    this.destination.error(err);
  };

  ExhaustMapSubscriber.prototype.notifyComplete = function (innerSub) {
    var destination = this.destination;
    destination.remove(innerSub);
    this.hasSubscription = false;

    if (this.hasCompleted) {
      this.destination.complete();
    }
  };

  return ExhaustMapSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../InnerSubscriber":"../../../../node_modules/rxjs/_esm5/internal/InnerSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js","./map":"../../../../node_modules/rxjs/_esm5/internal/operators/map.js","../observable/from":"../../../../node_modules/rxjs/_esm5/internal/observable/from.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/expand.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.expand = expand;
exports.ExpandSubscriber = exports.ExpandOperator = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function expand(project, concurrent, scheduler) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }

  if (scheduler === void 0) {
    scheduler = undefined;
  }

  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
  return function (source) {
    return source.lift(new ExpandOperator(project, concurrent, scheduler));
  };
}

var ExpandOperator =
/*@__PURE__*/
function () {
  function ExpandOperator(project, concurrent, scheduler) {
    this.project = project;
    this.concurrent = concurrent;
    this.scheduler = scheduler;
  }

  ExpandOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
  };

  return ExpandOperator;
}();

exports.ExpandOperator = ExpandOperator;

var ExpandSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(ExpandSubscriber, _super);

  function ExpandSubscriber(destination, project, concurrent, scheduler) {
    var _this = _super.call(this, destination) || this;

    _this.project = project;
    _this.concurrent = concurrent;
    _this.scheduler = scheduler;
    _this.index = 0;
    _this.active = 0;
    _this.hasCompleted = false;

    if (concurrent < Number.POSITIVE_INFINITY) {
      _this.buffer = [];
    }

    return _this;
  }

  ExpandSubscriber.dispatch = function (arg) {
    var subscriber = arg.subscriber,
        result = arg.result,
        value = arg.value,
        index = arg.index;
    subscriber.subscribeToProjection(result, value, index);
  };

  ExpandSubscriber.prototype._next = function (value) {
    var destination = this.destination;

    if (destination.closed) {
      this._complete();

      return;
    }

    var index = this.index++;

    if (this.active < this.concurrent) {
      destination.next(value);

      try {
        var project = this.project;
        var result = project(value, index);

        if (!this.scheduler) {
          this.subscribeToProjection(result, value, index);
        } else {
          var state = {
            subscriber: this,
            result: result,
            value: value,
            index: index
          };
          var destination_1 = this.destination;
          destination_1.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
        }
      } catch (e) {
        destination.error(e);
      }
    } else {
      this.buffer.push(value);
    }
  };

  ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
    this.active++;
    var destination = this.destination;
    destination.add((0, _subscribeToResult.subscribeToResult)(this, result, value, index));
  };

  ExpandSubscriber.prototype._complete = function () {
    this.hasCompleted = true;

    if (this.hasCompleted && this.active === 0) {
      this.destination.complete();
    }

    this.unsubscribe();
  };

  ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this._next(innerValue);
  };

  ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
    var buffer = this.buffer;
    var destination = this.destination;
    destination.remove(innerSub);
    this.active--;

    if (buffer && buffer.length > 0) {
      this._next(buffer.shift());
    }

    if (this.hasCompleted && this.active === 0) {
      this.destination.complete();
    }
  };

  return ExpandSubscriber;
}(_OuterSubscriber.OuterSubscriber);

exports.ExpandSubscriber = ExpandSubscriber;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/finalize.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.finalize = finalize;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

var _Subscription = require("../Subscription");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */
function finalize(callback) {
  return function (source) {
    return source.lift(new FinallyOperator(callback));
  };
}

var FinallyOperator =
/*@__PURE__*/
function () {
  function FinallyOperator(callback) {
    this.callback = callback;
  }

  FinallyOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new FinallySubscriber(subscriber, this.callback));
  };

  return FinallyOperator;
}();

var FinallySubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(FinallySubscriber, _super);

  function FinallySubscriber(destination, callback) {
    var _this = _super.call(this, destination) || this;

    _this.add(new _Subscription.Subscription(callback));

    return _this;
  }

  return FinallySubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../Subscription":"../../../../node_modules/rxjs/_esm5/internal/Subscription.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/find.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.find = find;
exports.FindValueSubscriber = exports.FindValueOperator = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function find(predicate, thisArg) {
  if (typeof predicate !== 'function') {
    throw new TypeError('predicate is not a function');
  }

  return function (source) {
    return source.lift(new FindValueOperator(predicate, source, false, thisArg));
  };
}

var FindValueOperator =
/*@__PURE__*/
function () {
  function FindValueOperator(predicate, source, yieldIndex, thisArg) {
    this.predicate = predicate;
    this.source = source;
    this.yieldIndex = yieldIndex;
    this.thisArg = thisArg;
  }

  FindValueOperator.prototype.call = function (observer, source) {
    return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
  };

  return FindValueOperator;
}();

exports.FindValueOperator = FindValueOperator;

var FindValueSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(FindValueSubscriber, _super);

  function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
    var _this = _super.call(this, destination) || this;

    _this.predicate = predicate;
    _this.source = source;
    _this.yieldIndex = yieldIndex;
    _this.thisArg = thisArg;
    _this.index = 0;
    return _this;
  }

  FindValueSubscriber.prototype.notifyComplete = function (value) {
    var destination = this.destination;
    destination.next(value);
    destination.complete();
    this.unsubscribe();
  };

  FindValueSubscriber.prototype._next = function (value) {
    var _a = this,
        predicate = _a.predicate,
        thisArg = _a.thisArg;

    var index = this.index++;

    try {
      var result = predicate.call(thisArg || this, value, index, this.source);

      if (result) {
        this.notifyComplete(this.yieldIndex ? index : value);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };

  FindValueSubscriber.prototype._complete = function () {
    this.notifyComplete(this.yieldIndex ? -1 : undefined);
  };

  return FindValueSubscriber;
}(_Subscriber.Subscriber);

exports.FindValueSubscriber = FindValueSubscriber;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/findIndex.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findIndex = findIndex;

var _find = require("../operators/find");

/** PURE_IMPORTS_START _operators_find PURE_IMPORTS_END */
function findIndex(predicate, thisArg) {
  return function (source) {
    return source.lift(new _find.FindValueOperator(predicate, source, true, thisArg));
  };
}
},{"../operators/find":"../../../../node_modules/rxjs/_esm5/internal/operators/find.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/first.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.first = first;

var _EmptyError = require("../util/EmptyError");

var _filter = require("./filter");

var _take = require("./take");

var _defaultIfEmpty = require("./defaultIfEmpty");

var _throwIfEmpty = require("./throwIfEmpty");

var _identity = require("../util/identity");

/** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function (source) {
    return source.pipe(predicate ? (0, _filter.filter)(function (v, i) {
      return predicate(v, i, source);
    }) : _identity.identity, (0, _take.take)(1), hasDefaultValue ? (0, _defaultIfEmpty.defaultIfEmpty)(defaultValue) : (0, _throwIfEmpty.throwIfEmpty)(function () {
      return new _EmptyError.EmptyError();
    }));
  };
}
},{"../util/EmptyError":"../../../../node_modules/rxjs/_esm5/internal/util/EmptyError.js","./filter":"../../../../node_modules/rxjs/_esm5/internal/operators/filter.js","./take":"../../../../node_modules/rxjs/_esm5/internal/operators/take.js","./defaultIfEmpty":"../../../../node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js","./throwIfEmpty":"../../../../node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js","../util/identity":"../../../../node_modules/rxjs/_esm5/internal/util/identity.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/ignoreElements.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ignoreElements = ignoreElements;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function ignoreElements() {
  return function ignoreElementsOperatorFunction(source) {
    return source.lift(new IgnoreElementsOperator());
  };
}

var IgnoreElementsOperator =
/*@__PURE__*/
function () {
  function IgnoreElementsOperator() {}

  IgnoreElementsOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new IgnoreElementsSubscriber(subscriber));
  };

  return IgnoreElementsOperator;
}();

var IgnoreElementsSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(IgnoreElementsSubscriber, _super);

  function IgnoreElementsSubscriber() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  IgnoreElementsSubscriber.prototype._next = function (unused) {};

  return IgnoreElementsSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/isEmpty.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isEmpty = isEmpty;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function isEmpty() {
  return function (source) {
    return source.lift(new IsEmptyOperator());
  };
}

var IsEmptyOperator =
/*@__PURE__*/
function () {
  function IsEmptyOperator() {}

  IsEmptyOperator.prototype.call = function (observer, source) {
    return source.subscribe(new IsEmptySubscriber(observer));
  };

  return IsEmptyOperator;
}();

var IsEmptySubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(IsEmptySubscriber, _super);

  function IsEmptySubscriber(destination) {
    return _super.call(this, destination) || this;
  }

  IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
    var destination = this.destination;
    destination.next(isEmpty);
    destination.complete();
  };

  IsEmptySubscriber.prototype._next = function (value) {
    this.notifyComplete(false);
  };

  IsEmptySubscriber.prototype._complete = function () {
    this.notifyComplete(true);
  };

  return IsEmptySubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/takeLast.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.takeLast = takeLast;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

var _ArgumentOutOfRangeError = require("../util/ArgumentOutOfRangeError");

var _empty = require("../observable/empty");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
function takeLast(count) {
  return function takeLastOperatorFunction(source) {
    if (count === 0) {
      return (0, _empty.empty)();
    } else {
      return source.lift(new TakeLastOperator(count));
    }
  };
}

var TakeLastOperator =
/*@__PURE__*/
function () {
  function TakeLastOperator(total) {
    this.total = total;

    if (this.total < 0) {
      throw new _ArgumentOutOfRangeError.ArgumentOutOfRangeError();
    }
  }

  TakeLastOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
  };

  return TakeLastOperator;
}();

var TakeLastSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(TakeLastSubscriber, _super);

  function TakeLastSubscriber(destination, total) {
    var _this = _super.call(this, destination) || this;

    _this.total = total;
    _this.ring = new Array();
    _this.count = 0;
    return _this;
  }

  TakeLastSubscriber.prototype._next = function (value) {
    var ring = this.ring;
    var total = this.total;
    var count = this.count++;

    if (ring.length < total) {
      ring.push(value);
    } else {
      var index = count % total;
      ring[index] = value;
    }
  };

  TakeLastSubscriber.prototype._complete = function () {
    var destination = this.destination;
    var count = this.count;

    if (count > 0) {
      var total = this.count >= this.total ? this.total : this.count;
      var ring = this.ring;

      for (var i = 0; i < total; i++) {
        var idx = count++ % total;
        destination.next(ring[idx]);
      }
    }

    destination.complete();
  };

  return TakeLastSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../util/ArgumentOutOfRangeError":"../../../../node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js","../observable/empty":"../../../../node_modules/rxjs/_esm5/internal/observable/empty.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/last.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.last = last;

var _EmptyError = require("../util/EmptyError");

var _filter = require("./filter");

var _takeLast = require("./takeLast");

var _throwIfEmpty = require("./throwIfEmpty");

var _defaultIfEmpty = require("./defaultIfEmpty");

var _identity = require("../util/identity");

/** PURE_IMPORTS_START _util_EmptyError,_filter,_takeLast,_throwIfEmpty,_defaultIfEmpty,_util_identity PURE_IMPORTS_END */
function last(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function (source) {
    return source.pipe(predicate ? (0, _filter.filter)(function (v, i) {
      return predicate(v, i, source);
    }) : _identity.identity, (0, _takeLast.takeLast)(1), hasDefaultValue ? (0, _defaultIfEmpty.defaultIfEmpty)(defaultValue) : (0, _throwIfEmpty.throwIfEmpty)(function () {
      return new _EmptyError.EmptyError();
    }));
  };
}
},{"../util/EmptyError":"../../../../node_modules/rxjs/_esm5/internal/util/EmptyError.js","./filter":"../../../../node_modules/rxjs/_esm5/internal/operators/filter.js","./takeLast":"../../../../node_modules/rxjs/_esm5/internal/operators/takeLast.js","./throwIfEmpty":"../../../../node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js","./defaultIfEmpty":"../../../../node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js","../util/identity":"../../../../node_modules/rxjs/_esm5/internal/util/identity.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/mapTo.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapTo = mapTo;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function mapTo(value) {
  return function (source) {
    return source.lift(new MapToOperator(value));
  };
}

var MapToOperator =
/*@__PURE__*/
function () {
  function MapToOperator(value) {
    this.value = value;
  }

  MapToOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new MapToSubscriber(subscriber, this.value));
  };

  return MapToOperator;
}();

var MapToSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(MapToSubscriber, _super);

  function MapToSubscriber(destination, value) {
    var _this = _super.call(this, destination) || this;

    _this.value = value;
    return _this;
  }

  MapToSubscriber.prototype._next = function (x) {
    this.destination.next(this.value);
  };

  return MapToSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/materialize.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.materialize = materialize;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

var _Notification = require("../Notification");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */
function materialize() {
  return function materializeOperatorFunction(source) {
    return source.lift(new MaterializeOperator());
  };
}

var MaterializeOperator =
/*@__PURE__*/
function () {
  function MaterializeOperator() {}

  MaterializeOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new MaterializeSubscriber(subscriber));
  };

  return MaterializeOperator;
}();

var MaterializeSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(MaterializeSubscriber, _super);

  function MaterializeSubscriber(destination) {
    return _super.call(this, destination) || this;
  }

  MaterializeSubscriber.prototype._next = function (value) {
    this.destination.next(_Notification.Notification.createNext(value));
  };

  MaterializeSubscriber.prototype._error = function (err) {
    var destination = this.destination;
    destination.next(_Notification.Notification.createError(err));
    destination.complete();
  };

  MaterializeSubscriber.prototype._complete = function () {
    var destination = this.destination;
    destination.next(_Notification.Notification.createComplete());
    destination.complete();
  };

  return MaterializeSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../Notification":"../../../../node_modules/rxjs/_esm5/internal/Notification.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/scan.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scan = scan;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function scan(accumulator, seed) {
  var hasSeed = false;

  if (arguments.length >= 2) {
    hasSeed = true;
  }

  return function scanOperatorFunction(source) {
    return source.lift(new ScanOperator(accumulator, seed, hasSeed));
  };
}

var ScanOperator =
/*@__PURE__*/
function () {
  function ScanOperator(accumulator, seed, hasSeed) {
    if (hasSeed === void 0) {
      hasSeed = false;
    }

    this.accumulator = accumulator;
    this.seed = seed;
    this.hasSeed = hasSeed;
  }

  ScanOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
  };

  return ScanOperator;
}();

var ScanSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(ScanSubscriber, _super);

  function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
    var _this = _super.call(this, destination) || this;

    _this.accumulator = accumulator;
    _this._seed = _seed;
    _this.hasSeed = hasSeed;
    _this.index = 0;
    return _this;
  }

  Object.defineProperty(ScanSubscriber.prototype, "seed", {
    get: function () {
      return this._seed;
    },
    set: function (value) {
      this.hasSeed = true;
      this._seed = value;
    },
    enumerable: true,
    configurable: true
  });

  ScanSubscriber.prototype._next = function (value) {
    if (!this.hasSeed) {
      this.seed = value;
      this.destination.next(value);
    } else {
      return this._tryNext(value);
    }
  };

  ScanSubscriber.prototype._tryNext = function (value) {
    var index = this.index++;
    var result;

    try {
      result = this.accumulator(this.seed, value, index);
    } catch (err) {
      this.destination.error(err);
    }

    this.seed = result;
    this.destination.next(result);
  };

  return ScanSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/reduce.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reduce = reduce;

var _scan = require("./scan");

var _takeLast = require("./takeLast");

var _defaultIfEmpty = require("./defaultIfEmpty");

var _pipe = require("../util/pipe");

/** PURE_IMPORTS_START _scan,_takeLast,_defaultIfEmpty,_util_pipe PURE_IMPORTS_END */
function reduce(accumulator, seed) {
  if (arguments.length >= 2) {
    return function reduceOperatorFunctionWithSeed(source) {
      return (0, _pipe.pipe)((0, _scan.scan)(accumulator, seed), (0, _takeLast.takeLast)(1), (0, _defaultIfEmpty.defaultIfEmpty)(seed))(source);
    };
  }

  return function reduceOperatorFunction(source) {
    return (0, _pipe.pipe)((0, _scan.scan)(function (acc, value, index) {
      return accumulator(acc, value, index + 1);
    }), (0, _takeLast.takeLast)(1))(source);
  };
}
},{"./scan":"../../../../node_modules/rxjs/_esm5/internal/operators/scan.js","./takeLast":"../../../../node_modules/rxjs/_esm5/internal/operators/takeLast.js","./defaultIfEmpty":"../../../../node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js","../util/pipe":"../../../../node_modules/rxjs/_esm5/internal/util/pipe.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/max.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.max = max;

var _reduce = require("./reduce");

/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */
function max(comparer) {
  var max = typeof comparer === 'function' ? function (x, y) {
    return comparer(x, y) > 0 ? x : y;
  } : function (x, y) {
    return x > y ? x : y;
  };
  return (0, _reduce.reduce)(max);
}
},{"./reduce":"../../../../node_modules/rxjs/_esm5/internal/operators/reduce.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/merge.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.merge = merge;

var _merge = require("../observable/merge");

/** PURE_IMPORTS_START _observable_merge PURE_IMPORTS_END */
function merge() {
  var observables = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }

  return function (source) {
    return source.lift.call(_merge.merge.apply(void 0, [source].concat(observables)));
  };
}
},{"../observable/merge":"../../../../node_modules/rxjs/_esm5/internal/observable/merge.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeMapTo = mergeMapTo;

var _mergeMap = require("./mergeMap");

/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */
function mergeMapTo(innerObservable, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }

  if (typeof resultSelector === 'function') {
    return (0, _mergeMap.mergeMap)(function () {
      return innerObservable;
    }, resultSelector, concurrent);
  }

  if (typeof resultSelector === 'number') {
    concurrent = resultSelector;
  }

  return (0, _mergeMap.mergeMap)(function () {
    return innerObservable;
  }, concurrent);
}
},{"./mergeMap":"../../../../node_modules/rxjs/_esm5/internal/operators/mergeMap.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/mergeScan.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeScan = mergeScan;
exports.MergeScanSubscriber = exports.MergeScanOperator = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _subscribeToResult = require("../util/subscribeToResult");

var _OuterSubscriber = require("../OuterSubscriber");

var _InnerSubscriber = require("../InnerSubscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber PURE_IMPORTS_END */
function mergeScan(accumulator, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }

  return function (source) {
    return source.lift(new MergeScanOperator(accumulator, seed, concurrent));
  };
}

var MergeScanOperator =
/*@__PURE__*/
function () {
  function MergeScanOperator(accumulator, seed, concurrent) {
    this.accumulator = accumulator;
    this.seed = seed;
    this.concurrent = concurrent;
  }

  MergeScanOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
  };

  return MergeScanOperator;
}();

exports.MergeScanOperator = MergeScanOperator;

var MergeScanSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(MergeScanSubscriber, _super);

  function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
    var _this = _super.call(this, destination) || this;

    _this.accumulator = accumulator;
    _this.acc = acc;
    _this.concurrent = concurrent;
    _this.hasValue = false;
    _this.hasCompleted = false;
    _this.buffer = [];
    _this.active = 0;
    _this.index = 0;
    return _this;
  }

  MergeScanSubscriber.prototype._next = function (value) {
    if (this.active < this.concurrent) {
      var index = this.index++;
      var destination = this.destination;
      var ish = void 0;

      try {
        var accumulator = this.accumulator;
        ish = accumulator(this.acc, value, index);
      } catch (e) {
        return destination.error(e);
      }

      this.active++;

      this._innerSub(ish, value, index);
    } else {
      this.buffer.push(value);
    }
  };

  MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
    var innerSubscriber = new _InnerSubscriber.InnerSubscriber(this, undefined, undefined);
    var destination = this.destination;
    destination.add(innerSubscriber);
    (0, _subscribeToResult.subscribeToResult)(this, ish, value, index, innerSubscriber);
  };

  MergeScanSubscriber.prototype._complete = function () {
    this.hasCompleted = true;

    if (this.active === 0 && this.buffer.length === 0) {
      if (this.hasValue === false) {
        this.destination.next(this.acc);
      }

      this.destination.complete();
    }

    this.unsubscribe();
  };

  MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    var destination = this.destination;
    this.acc = innerValue;
    this.hasValue = true;
    destination.next(innerValue);
  };

  MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
    var buffer = this.buffer;
    var destination = this.destination;
    destination.remove(innerSub);
    this.active--;

    if (buffer.length > 0) {
      this._next(buffer.shift());
    } else if (this.active === 0 && this.hasCompleted) {
      if (this.hasValue === false) {
        this.destination.next(this.acc);
      }

      this.destination.complete();
    }
  };

  return MergeScanSubscriber;
}(_OuterSubscriber.OuterSubscriber);

exports.MergeScanSubscriber = MergeScanSubscriber;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../InnerSubscriber":"../../../../node_modules/rxjs/_esm5/internal/InnerSubscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/min.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.min = min;

var _reduce = require("./reduce");

/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */
function min(comparer) {
  var min = typeof comparer === 'function' ? function (x, y) {
    return comparer(x, y) < 0 ? x : y;
  } : function (x, y) {
    return x < y ? x : y;
  };
  return (0, _reduce.reduce)(min);
}
},{"./reduce":"../../../../node_modules/rxjs/_esm5/internal/operators/reduce.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/multicast.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.multicast = multicast;
exports.MulticastOperator = void 0;

var _ConnectableObservable = require("../observable/ConnectableObservable");

/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */
function multicast(subjectOrSubjectFactory, selector) {
  return function multicastOperatorFunction(source) {
    var subjectFactory;

    if (typeof subjectOrSubjectFactory === 'function') {
      subjectFactory = subjectOrSubjectFactory;
    } else {
      subjectFactory = function subjectFactory() {
        return subjectOrSubjectFactory;
      };
    }

    if (typeof selector === 'function') {
      return source.lift(new MulticastOperator(subjectFactory, selector));
    }

    var connectable = Object.create(source, _ConnectableObservable.connectableObservableDescriptor);
    connectable.source = source;
    connectable.subjectFactory = subjectFactory;
    return connectable;
  };
}

var MulticastOperator =
/*@__PURE__*/
function () {
  function MulticastOperator(subjectFactory, selector) {
    this.subjectFactory = subjectFactory;
    this.selector = selector;
  }

  MulticastOperator.prototype.call = function (subscriber, source) {
    var selector = this.selector;
    var subject = this.subjectFactory();
    var subscription = selector(subject).subscribe(subscriber);
    subscription.add(source.subscribe(subject));
    return subscription;
  };

  return MulticastOperator;
}();

exports.MulticastOperator = MulticastOperator;
},{"../observable/ConnectableObservable":"../../../../node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/onErrorResumeNext.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onErrorResumeNext = onErrorResumeNext;
exports.onErrorResumeNextStatic = onErrorResumeNextStatic;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _from = require("../observable/from");

var _isArray = require("../util/isArray");

var _OuterSubscriber = require("../OuterSubscriber");

var _InnerSubscriber = require("../InnerSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_observable_from,_util_isArray,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function onErrorResumeNext() {
  var nextSources = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    nextSources[_i] = arguments[_i];
  }

  if (nextSources.length === 1 && (0, _isArray.isArray)(nextSources[0])) {
    nextSources = nextSources[0];
  }

  return function (source) {
    return source.lift(new OnErrorResumeNextOperator(nextSources));
  };
}

function onErrorResumeNextStatic() {
  var nextSources = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    nextSources[_i] = arguments[_i];
  }

  var source = null;

  if (nextSources.length === 1 && (0, _isArray.isArray)(nextSources[0])) {
    nextSources = nextSources[0];
  }

  source = nextSources.shift();
  return (0, _from.from)(source, null).lift(new OnErrorResumeNextOperator(nextSources));
}

var OnErrorResumeNextOperator =
/*@__PURE__*/
function () {
  function OnErrorResumeNextOperator(nextSources) {
    this.nextSources = nextSources;
  }

  OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
  };

  return OnErrorResumeNextOperator;
}();

var OnErrorResumeNextSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(OnErrorResumeNextSubscriber, _super);

  function OnErrorResumeNextSubscriber(destination, nextSources) {
    var _this = _super.call(this, destination) || this;

    _this.destination = destination;
    _this.nextSources = nextSources;
    return _this;
  }

  OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
    this.subscribeToNextSource();
  };

  OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
    this.subscribeToNextSource();
  };

  OnErrorResumeNextSubscriber.prototype._error = function (err) {
    this.subscribeToNextSource();
    this.unsubscribe();
  };

  OnErrorResumeNextSubscriber.prototype._complete = function () {
    this.subscribeToNextSource();
    this.unsubscribe();
  };

  OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
    var next = this.nextSources.shift();

    if (!!next) {
      var innerSubscriber = new _InnerSubscriber.InnerSubscriber(this, undefined, undefined);
      var destination = this.destination;
      destination.add(innerSubscriber);
      (0, _subscribeToResult.subscribeToResult)(this, next, undefined, undefined, innerSubscriber);
    } else {
      this.destination.complete();
    }
  };

  return OnErrorResumeNextSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../observable/from":"../../../../node_modules/rxjs/_esm5/internal/observable/from.js","../util/isArray":"../../../../node_modules/rxjs/_esm5/internal/util/isArray.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../InnerSubscriber":"../../../../node_modules/rxjs/_esm5/internal/InnerSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/pairwise.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pairwise = pairwise;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function pairwise() {
  return function (source) {
    return source.lift(new PairwiseOperator());
  };
}

var PairwiseOperator =
/*@__PURE__*/
function () {
  function PairwiseOperator() {}

  PairwiseOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new PairwiseSubscriber(subscriber));
  };

  return PairwiseOperator;
}();

var PairwiseSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(PairwiseSubscriber, _super);

  function PairwiseSubscriber(destination) {
    var _this = _super.call(this, destination) || this;

    _this.hasPrev = false;
    return _this;
  }

  PairwiseSubscriber.prototype._next = function (value) {
    var pair;

    if (this.hasPrev) {
      pair = [this.prev, value];
    } else {
      this.hasPrev = true;
    }

    this.prev = value;

    if (pair) {
      this.destination.next(pair);
    }
  };

  return PairwiseSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/partition.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.partition = partition;

var _not = require("../util/not");

var _filter = require("./filter");

/** PURE_IMPORTS_START _util_not,_filter PURE_IMPORTS_END */
function partition(predicate, thisArg) {
  return function (source) {
    return [(0, _filter.filter)(predicate, thisArg)(source), (0, _filter.filter)((0, _not.not)(predicate, thisArg))(source)];
  };
}
},{"../util/not":"../../../../node_modules/rxjs/_esm5/internal/util/not.js","./filter":"../../../../node_modules/rxjs/_esm5/internal/operators/filter.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/pluck.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pluck = pluck;

var _map = require("./map");

/** PURE_IMPORTS_START _map PURE_IMPORTS_END */
function pluck() {
  var properties = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    properties[_i] = arguments[_i];
  }

  var length = properties.length;

  if (length === 0) {
    throw new Error('list of properties cannot be empty.');
  }

  return function (source) {
    return (0, _map.map)(plucker(properties, length))(source);
  };
}

function plucker(props, length) {
  var mapper = function (x) {
    var currentProp = x;

    for (var i = 0; i < length; i++) {
      var p = currentProp[props[i]];

      if (typeof p !== 'undefined') {
        currentProp = p;
      } else {
        return undefined;
      }
    }

    return currentProp;
  };

  return mapper;
}
},{"./map":"../../../../node_modules/rxjs/_esm5/internal/operators/map.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/publish.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.publish = publish;

var _Subject = require("../Subject");

var _multicast = require("./multicast");

/** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */
function publish(selector) {
  return selector ? (0, _multicast.multicast)(function () {
    return new _Subject.Subject();
  }, selector) : (0, _multicast.multicast)(new _Subject.Subject());
}
},{"../Subject":"../../../../node_modules/rxjs/_esm5/internal/Subject.js","./multicast":"../../../../node_modules/rxjs/_esm5/internal/operators/multicast.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/publishBehavior.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.publishBehavior = publishBehavior;

var _BehaviorSubject = require("../BehaviorSubject");

var _multicast = require("./multicast");

/** PURE_IMPORTS_START _BehaviorSubject,_multicast PURE_IMPORTS_END */
function publishBehavior(value) {
  return function (source) {
    return (0, _multicast.multicast)(new _BehaviorSubject.BehaviorSubject(value))(source);
  };
}
},{"../BehaviorSubject":"../../../../node_modules/rxjs/_esm5/internal/BehaviorSubject.js","./multicast":"../../../../node_modules/rxjs/_esm5/internal/operators/multicast.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/publishLast.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.publishLast = publishLast;

var _AsyncSubject = require("../AsyncSubject");

var _multicast = require("./multicast");

/** PURE_IMPORTS_START _AsyncSubject,_multicast PURE_IMPORTS_END */
function publishLast() {
  return function (source) {
    return (0, _multicast.multicast)(new _AsyncSubject.AsyncSubject())(source);
  };
}
},{"../AsyncSubject":"../../../../node_modules/rxjs/_esm5/internal/AsyncSubject.js","./multicast":"../../../../node_modules/rxjs/_esm5/internal/operators/multicast.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/publishReplay.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.publishReplay = publishReplay;

var _ReplaySubject = require("../ReplaySubject");

var _multicast = require("./multicast");

/** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */
function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
  if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {
    scheduler = selectorOrScheduler;
  }

  var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;
  var subject = new _ReplaySubject.ReplaySubject(bufferSize, windowTime, scheduler);
  return function (source) {
    return (0, _multicast.multicast)(function () {
      return subject;
    }, selector)(source);
  };
}
},{"../ReplaySubject":"../../../../node_modules/rxjs/_esm5/internal/ReplaySubject.js","./multicast":"../../../../node_modules/rxjs/_esm5/internal/operators/multicast.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/race.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.race = race;

var _isArray = require("../util/isArray");

var _race = require("../observable/race");

/** PURE_IMPORTS_START _util_isArray,_observable_race PURE_IMPORTS_END */
function race() {
  var observables = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }

  return function raceOperatorFunction(source) {
    if (observables.length === 1 && (0, _isArray.isArray)(observables[0])) {
      observables = observables[0];
    }

    return source.lift.call(_race.race.apply(void 0, [source].concat(observables)));
  };
}
},{"../util/isArray":"../../../../node_modules/rxjs/_esm5/internal/util/isArray.js","../observable/race":"../../../../node_modules/rxjs/_esm5/internal/observable/race.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/repeat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.repeat = repeat;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

var _empty = require("../observable/empty");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber,_observable_empty PURE_IMPORTS_END */
function repeat(count) {
  if (count === void 0) {
    count = -1;
  }

  return function (source) {
    if (count === 0) {
      return (0, _empty.empty)();
    } else if (count < 0) {
      return source.lift(new RepeatOperator(-1, source));
    } else {
      return source.lift(new RepeatOperator(count - 1, source));
    }
  };
}

var RepeatOperator =
/*@__PURE__*/
function () {
  function RepeatOperator(count, source) {
    this.count = count;
    this.source = source;
  }

  RepeatOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
  };

  return RepeatOperator;
}();

var RepeatSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(RepeatSubscriber, _super);

  function RepeatSubscriber(destination, count, source) {
    var _this = _super.call(this, destination) || this;

    _this.count = count;
    _this.source = source;
    return _this;
  }

  RepeatSubscriber.prototype.complete = function () {
    if (!this.isStopped) {
      var _a = this,
          source = _a.source,
          count = _a.count;

      if (count === 0) {
        return _super.prototype.complete.call(this);
      } else if (count > -1) {
        this.count = count - 1;
      }

      source.subscribe(this._unsubscribeAndRecycle());
    }
  };

  return RepeatSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../observable/empty":"../../../../node_modules/rxjs/_esm5/internal/observable/empty.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/repeatWhen.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.repeatWhen = repeatWhen;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subject = require("../Subject");

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function repeatWhen(notifier) {
  return function (source) {
    return source.lift(new RepeatWhenOperator(notifier));
  };
}

var RepeatWhenOperator =
/*@__PURE__*/
function () {
  function RepeatWhenOperator(notifier) {
    this.notifier = notifier;
  }

  RepeatWhenOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
  };

  return RepeatWhenOperator;
}();

var RepeatWhenSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(RepeatWhenSubscriber, _super);

  function RepeatWhenSubscriber(destination, notifier, source) {
    var _this = _super.call(this, destination) || this;

    _this.notifier = notifier;
    _this.source = source;
    _this.sourceIsBeingSubscribedTo = true;
    return _this;
  }

  RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.sourceIsBeingSubscribedTo = true;
    this.source.subscribe(this);
  };

  RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
    if (this.sourceIsBeingSubscribedTo === false) {
      return _super.prototype.complete.call(this);
    }
  };

  RepeatWhenSubscriber.prototype.complete = function () {
    this.sourceIsBeingSubscribedTo = false;

    if (!this.isStopped) {
      if (!this.retries) {
        this.subscribeToRetries();
      }

      if (!this.retriesSubscription || this.retriesSubscription.closed) {
        return _super.prototype.complete.call(this);
      }

      this._unsubscribeAndRecycle();

      this.notifications.next();
    }
  };

  RepeatWhenSubscriber.prototype._unsubscribe = function () {
    var _a = this,
        notifications = _a.notifications,
        retriesSubscription = _a.retriesSubscription;

    if (notifications) {
      notifications.unsubscribe();
      this.notifications = null;
    }

    if (retriesSubscription) {
      retriesSubscription.unsubscribe();
      this.retriesSubscription = null;
    }

    this.retries = null;
  };

  RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
    var _unsubscribe = this._unsubscribe;
    this._unsubscribe = null;

    _super.prototype._unsubscribeAndRecycle.call(this);

    this._unsubscribe = _unsubscribe;
    return this;
  };

  RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
    this.notifications = new _Subject.Subject();
    var retries;

    try {
      var notifier = this.notifier;
      retries = notifier(this.notifications);
    } catch (e) {
      return _super.prototype.complete.call(this);
    }

    this.retries = retries;
    this.retriesSubscription = (0, _subscribeToResult.subscribeToResult)(this, retries);
  };

  return RepeatWhenSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subject":"../../../../node_modules/rxjs/_esm5/internal/Subject.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/retry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.retry = retry;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function retry(count) {
  if (count === void 0) {
    count = -1;
  }

  return function (source) {
    return source.lift(new RetryOperator(count, source));
  };
}

var RetryOperator =
/*@__PURE__*/
function () {
  function RetryOperator(count, source) {
    this.count = count;
    this.source = source;
  }

  RetryOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
  };

  return RetryOperator;
}();

var RetrySubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(RetrySubscriber, _super);

  function RetrySubscriber(destination, count, source) {
    var _this = _super.call(this, destination) || this;

    _this.count = count;
    _this.source = source;
    return _this;
  }

  RetrySubscriber.prototype.error = function (err) {
    if (!this.isStopped) {
      var _a = this,
          source = _a.source,
          count = _a.count;

      if (count === 0) {
        return _super.prototype.error.call(this, err);
      } else if (count > -1) {
        this.count = count - 1;
      }

      source.subscribe(this._unsubscribeAndRecycle());
    }
  };

  return RetrySubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/retryWhen.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.retryWhen = retryWhen;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subject = require("../Subject");

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function retryWhen(notifier) {
  return function (source) {
    return source.lift(new RetryWhenOperator(notifier, source));
  };
}

var RetryWhenOperator =
/*@__PURE__*/
function () {
  function RetryWhenOperator(notifier, source) {
    this.notifier = notifier;
    this.source = source;
  }

  RetryWhenOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
  };

  return RetryWhenOperator;
}();

var RetryWhenSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(RetryWhenSubscriber, _super);

  function RetryWhenSubscriber(destination, notifier, source) {
    var _this = _super.call(this, destination) || this;

    _this.notifier = notifier;
    _this.source = source;
    return _this;
  }

  RetryWhenSubscriber.prototype.error = function (err) {
    if (!this.isStopped) {
      var errors = this.errors;
      var retries = this.retries;
      var retriesSubscription = this.retriesSubscription;

      if (!retries) {
        errors = new _Subject.Subject();

        try {
          var notifier = this.notifier;
          retries = notifier(errors);
        } catch (e) {
          return _super.prototype.error.call(this, e);
        }

        retriesSubscription = (0, _subscribeToResult.subscribeToResult)(this, retries);
      } else {
        this.errors = null;
        this.retriesSubscription = null;
      }

      this._unsubscribeAndRecycle();

      this.errors = errors;
      this.retries = retries;
      this.retriesSubscription = retriesSubscription;
      errors.next(err);
    }
  };

  RetryWhenSubscriber.prototype._unsubscribe = function () {
    var _a = this,
        errors = _a.errors,
        retriesSubscription = _a.retriesSubscription;

    if (errors) {
      errors.unsubscribe();
      this.errors = null;
    }

    if (retriesSubscription) {
      retriesSubscription.unsubscribe();
      this.retriesSubscription = null;
    }

    this.retries = null;
  };

  RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    var _unsubscribe = this._unsubscribe;
    this._unsubscribe = null;

    this._unsubscribeAndRecycle();

    this._unsubscribe = _unsubscribe;
    this.source.subscribe(this);
  };

  return RetryWhenSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subject":"../../../../node_modules/rxjs/_esm5/internal/Subject.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/sample.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sample = sample;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function sample(notifier) {
  return function (source) {
    return source.lift(new SampleOperator(notifier));
  };
}

var SampleOperator =
/*@__PURE__*/
function () {
  function SampleOperator(notifier) {
    this.notifier = notifier;
  }

  SampleOperator.prototype.call = function (subscriber, source) {
    var sampleSubscriber = new SampleSubscriber(subscriber);
    var subscription = source.subscribe(sampleSubscriber);
    subscription.add((0, _subscribeToResult.subscribeToResult)(sampleSubscriber, this.notifier));
    return subscription;
  };

  return SampleOperator;
}();

var SampleSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(SampleSubscriber, _super);

  function SampleSubscriber() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.hasValue = false;
    return _this;
  }

  SampleSubscriber.prototype._next = function (value) {
    this.value = value;
    this.hasValue = true;
  };

  SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.emitValue();
  };

  SampleSubscriber.prototype.notifyComplete = function () {
    this.emitValue();
  };

  SampleSubscriber.prototype.emitValue = function () {
    if (this.hasValue) {
      this.hasValue = false;
      this.destination.next(this.value);
    }
  };

  return SampleSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/sampleTime.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sampleTime = sampleTime;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

var _async = require("../scheduler/async");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
function sampleTime(period, scheduler) {
  if (scheduler === void 0) {
    scheduler = _async.async;
  }

  return function (source) {
    return source.lift(new SampleTimeOperator(period, scheduler));
  };
}

var SampleTimeOperator =
/*@__PURE__*/
function () {
  function SampleTimeOperator(period, scheduler) {
    this.period = period;
    this.scheduler = scheduler;
  }

  SampleTimeOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
  };

  return SampleTimeOperator;
}();

var SampleTimeSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(SampleTimeSubscriber, _super);

  function SampleTimeSubscriber(destination, period, scheduler) {
    var _this = _super.call(this, destination) || this;

    _this.period = period;
    _this.scheduler = scheduler;
    _this.hasValue = false;

    _this.add(scheduler.schedule(dispatchNotification, period, {
      subscriber: _this,
      period: period
    }));

    return _this;
  }

  SampleTimeSubscriber.prototype._next = function (value) {
    this.lastValue = value;
    this.hasValue = true;
  };

  SampleTimeSubscriber.prototype.notifyNext = function () {
    if (this.hasValue) {
      this.hasValue = false;
      this.destination.next(this.lastValue);
    }
  };

  return SampleTimeSubscriber;
}(_Subscriber.Subscriber);

function dispatchNotification(state) {
  var subscriber = state.subscriber,
      period = state.period;
  subscriber.notifyNext();
  this.schedule(state, period);
}
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../scheduler/async":"../../../../node_modules/rxjs/_esm5/internal/scheduler/async.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/sequenceEqual.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sequenceEqual = sequenceEqual;
exports.SequenceEqualSubscriber = exports.SequenceEqualOperator = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function sequenceEqual(compareTo, comparator) {
  return function (source) {
    return source.lift(new SequenceEqualOperator(compareTo, comparator));
  };
}

var SequenceEqualOperator =
/*@__PURE__*/
function () {
  function SequenceEqualOperator(compareTo, comparator) {
    this.compareTo = compareTo;
    this.comparator = comparator;
  }

  SequenceEqualOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
  };

  return SequenceEqualOperator;
}();

exports.SequenceEqualOperator = SequenceEqualOperator;

var SequenceEqualSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(SequenceEqualSubscriber, _super);

  function SequenceEqualSubscriber(destination, compareTo, comparator) {
    var _this = _super.call(this, destination) || this;

    _this.compareTo = compareTo;
    _this.comparator = comparator;
    _this._a = [];
    _this._b = [];
    _this._oneComplete = false;

    _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));

    return _this;
  }

  SequenceEqualSubscriber.prototype._next = function (value) {
    if (this._oneComplete && this._b.length === 0) {
      this.emit(false);
    } else {
      this._a.push(value);

      this.checkValues();
    }
  };

  SequenceEqualSubscriber.prototype._complete = function () {
    if (this._oneComplete) {
      this.emit(this._a.length === 0 && this._b.length === 0);
    } else {
      this._oneComplete = true;
    }

    this.unsubscribe();
  };

  SequenceEqualSubscriber.prototype.checkValues = function () {
    var _c = this,
        _a = _c._a,
        _b = _c._b,
        comparator = _c.comparator;

    while (_a.length > 0 && _b.length > 0) {
      var a = _a.shift();

      var b = _b.shift();

      var areEqual = false;

      try {
        areEqual = comparator ? comparator(a, b) : a === b;
      } catch (e) {
        this.destination.error(e);
      }

      if (!areEqual) {
        this.emit(false);
      }
    }
  };

  SequenceEqualSubscriber.prototype.emit = function (value) {
    var destination = this.destination;
    destination.next(value);
    destination.complete();
  };

  SequenceEqualSubscriber.prototype.nextB = function (value) {
    if (this._oneComplete && this._a.length === 0) {
      this.emit(false);
    } else {
      this._b.push(value);

      this.checkValues();
    }
  };

  SequenceEqualSubscriber.prototype.completeB = function () {
    if (this._oneComplete) {
      this.emit(this._a.length === 0 && this._b.length === 0);
    } else {
      this._oneComplete = true;
    }
  };

  return SequenceEqualSubscriber;
}(_Subscriber.Subscriber);

exports.SequenceEqualSubscriber = SequenceEqualSubscriber;

var SequenceEqualCompareToSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(SequenceEqualCompareToSubscriber, _super);

  function SequenceEqualCompareToSubscriber(destination, parent) {
    var _this = _super.call(this, destination) || this;

    _this.parent = parent;
    return _this;
  }

  SequenceEqualCompareToSubscriber.prototype._next = function (value) {
    this.parent.nextB(value);
  };

  SequenceEqualCompareToSubscriber.prototype._error = function (err) {
    this.parent.error(err);
    this.unsubscribe();
  };

  SequenceEqualCompareToSubscriber.prototype._complete = function () {
    this.parent.completeB();
    this.unsubscribe();
  };

  return SequenceEqualCompareToSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/share.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.share = share;

var _multicast = require("./multicast");

var _refCount = require("./refCount");

var _Subject = require("../Subject");

/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */
function shareSubjectFactory() {
  return new _Subject.Subject();
}

function share() {
  return function (source) {
    return (0, _refCount.refCount)()((0, _multicast.multicast)(shareSubjectFactory)(source));
  };
}
},{"./multicast":"../../../../node_modules/rxjs/_esm5/internal/operators/multicast.js","./refCount":"../../../../node_modules/rxjs/_esm5/internal/operators/refCount.js","../Subject":"../../../../node_modules/rxjs/_esm5/internal/Subject.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/shareReplay.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shareReplay = shareReplay;

var _ReplaySubject = require("../ReplaySubject");

/** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */
function shareReplay(configOrBufferSize, windowTime, scheduler) {
  var config;

  if (configOrBufferSize && typeof configOrBufferSize === 'object') {
    config = configOrBufferSize;
  } else {
    config = {
      bufferSize: configOrBufferSize,
      windowTime: windowTime,
      refCount: false,
      scheduler: scheduler
    };
  }

  return function (source) {
    return source.lift(shareReplayOperator(config));
  };
}

function shareReplayOperator(_a) {
  var _b = _a.bufferSize,
      bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b,
      _c = _a.windowTime,
      windowTime = _c === void 0 ? Number.POSITIVE_INFINITY : _c,
      useRefCount = _a.refCount,
      scheduler = _a.scheduler;
  var subject;
  var refCount = 0;
  var subscription;
  var hasError = false;
  var isComplete = false;
  return function shareReplayOperation(source) {
    refCount++;

    if (!subject || hasError) {
      hasError = false;
      subject = new _ReplaySubject.ReplaySubject(bufferSize, windowTime, scheduler);
      subscription = source.subscribe({
        next: function (value) {
          subject.next(value);
        },
        error: function (err) {
          hasError = true;
          subject.error(err);
        },
        complete: function () {
          isComplete = true;
          subject.complete();
        }
      });
    }

    var innerSub = subject.subscribe(this);
    this.add(function () {
      refCount--;
      innerSub.unsubscribe();

      if (subscription && !isComplete && useRefCount && refCount === 0) {
        subscription.unsubscribe();
        subscription = undefined;
        subject = undefined;
      }
    });
  };
}
},{"../ReplaySubject":"../../../../node_modules/rxjs/_esm5/internal/ReplaySubject.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/single.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.single = single;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

var _EmptyError = require("../util/EmptyError");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber,_util_EmptyError PURE_IMPORTS_END */
function single(predicate) {
  return function (source) {
    return source.lift(new SingleOperator(predicate, source));
  };
}

var SingleOperator =
/*@__PURE__*/
function () {
  function SingleOperator(predicate, source) {
    this.predicate = predicate;
    this.source = source;
  }

  SingleOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
  };

  return SingleOperator;
}();

var SingleSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(SingleSubscriber, _super);

  function SingleSubscriber(destination, predicate, source) {
    var _this = _super.call(this, destination) || this;

    _this.predicate = predicate;
    _this.source = source;
    _this.seenValue = false;
    _this.index = 0;
    return _this;
  }

  SingleSubscriber.prototype.applySingleValue = function (value) {
    if (this.seenValue) {
      this.destination.error('Sequence contains more than one element');
    } else {
      this.seenValue = true;
      this.singleValue = value;
    }
  };

  SingleSubscriber.prototype._next = function (value) {
    var index = this.index++;

    if (this.predicate) {
      this.tryNext(value, index);
    } else {
      this.applySingleValue(value);
    }
  };

  SingleSubscriber.prototype.tryNext = function (value, index) {
    try {
      if (this.predicate(value, index, this.source)) {
        this.applySingleValue(value);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };

  SingleSubscriber.prototype._complete = function () {
    var destination = this.destination;

    if (this.index > 0) {
      destination.next(this.seenValue ? this.singleValue : undefined);
      destination.complete();
    } else {
      destination.error(new _EmptyError.EmptyError());
    }
  };

  return SingleSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../util/EmptyError":"../../../../node_modules/rxjs/_esm5/internal/util/EmptyError.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/skip.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.skip = skip;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function skip(count) {
  return function (source) {
    return source.lift(new SkipOperator(count));
  };
}

var SkipOperator =
/*@__PURE__*/
function () {
  function SkipOperator(total) {
    this.total = total;
  }

  SkipOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new SkipSubscriber(subscriber, this.total));
  };

  return SkipOperator;
}();

var SkipSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(SkipSubscriber, _super);

  function SkipSubscriber(destination, total) {
    var _this = _super.call(this, destination) || this;

    _this.total = total;
    _this.count = 0;
    return _this;
  }

  SkipSubscriber.prototype._next = function (x) {
    if (++this.count > this.total) {
      this.destination.next(x);
    }
  };

  return SkipSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/skipLast.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.skipLast = skipLast;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

var _ArgumentOutOfRangeError = require("../util/ArgumentOutOfRangeError");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError PURE_IMPORTS_END */
function skipLast(count) {
  return function (source) {
    return source.lift(new SkipLastOperator(count));
  };
}

var SkipLastOperator =
/*@__PURE__*/
function () {
  function SkipLastOperator(_skipCount) {
    this._skipCount = _skipCount;

    if (this._skipCount < 0) {
      throw new _ArgumentOutOfRangeError.ArgumentOutOfRangeError();
    }
  }

  SkipLastOperator.prototype.call = function (subscriber, source) {
    if (this._skipCount === 0) {
      return source.subscribe(new _Subscriber.Subscriber(subscriber));
    } else {
      return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
    }
  };

  return SkipLastOperator;
}();

var SkipLastSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(SkipLastSubscriber, _super);

  function SkipLastSubscriber(destination, _skipCount) {
    var _this = _super.call(this, destination) || this;

    _this._skipCount = _skipCount;
    _this._count = 0;
    _this._ring = new Array(_skipCount);
    return _this;
  }

  SkipLastSubscriber.prototype._next = function (value) {
    var skipCount = this._skipCount;
    var count = this._count++;

    if (count < skipCount) {
      this._ring[count] = value;
    } else {
      var currentIndex = count % skipCount;
      var ring = this._ring;
      var oldValue = ring[currentIndex];
      ring[currentIndex] = value;
      this.destination.next(oldValue);
    }
  };

  return SkipLastSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../util/ArgumentOutOfRangeError":"../../../../node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/skipUntil.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.skipUntil = skipUntil;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _OuterSubscriber = require("../OuterSubscriber");

var _InnerSubscriber = require("../InnerSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function skipUntil(notifier) {
  return function (source) {
    return source.lift(new SkipUntilOperator(notifier));
  };
}

var SkipUntilOperator =
/*@__PURE__*/
function () {
  function SkipUntilOperator(notifier) {
    this.notifier = notifier;
  }

  SkipUntilOperator.prototype.call = function (destination, source) {
    return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
  };

  return SkipUntilOperator;
}();

var SkipUntilSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(SkipUntilSubscriber, _super);

  function SkipUntilSubscriber(destination, notifier) {
    var _this = _super.call(this, destination) || this;

    _this.hasValue = false;
    var innerSubscriber = new _InnerSubscriber.InnerSubscriber(_this, undefined, undefined);

    _this.add(innerSubscriber);

    _this.innerSubscription = innerSubscriber;
    (0, _subscribeToResult.subscribeToResult)(_this, notifier, undefined, undefined, innerSubscriber);
    return _this;
  }

  SkipUntilSubscriber.prototype._next = function (value) {
    if (this.hasValue) {
      _super.prototype._next.call(this, value);
    }
  };

  SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.hasValue = true;

    if (this.innerSubscription) {
      this.innerSubscription.unsubscribe();
    }
  };

  SkipUntilSubscriber.prototype.notifyComplete = function () {};

  return SkipUntilSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../InnerSubscriber":"../../../../node_modules/rxjs/_esm5/internal/InnerSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/skipWhile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.skipWhile = skipWhile;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function skipWhile(predicate) {
  return function (source) {
    return source.lift(new SkipWhileOperator(predicate));
  };
}

var SkipWhileOperator =
/*@__PURE__*/
function () {
  function SkipWhileOperator(predicate) {
    this.predicate = predicate;
  }

  SkipWhileOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
  };

  return SkipWhileOperator;
}();

var SkipWhileSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(SkipWhileSubscriber, _super);

  function SkipWhileSubscriber(destination, predicate) {
    var _this = _super.call(this, destination) || this;

    _this.predicate = predicate;
    _this.skipping = true;
    _this.index = 0;
    return _this;
  }

  SkipWhileSubscriber.prototype._next = function (value) {
    var destination = this.destination;

    if (this.skipping) {
      this.tryCallPredicate(value);
    }

    if (!this.skipping) {
      destination.next(value);
    }
  };

  SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
    try {
      var result = this.predicate(value, this.index++);
      this.skipping = Boolean(result);
    } catch (err) {
      this.destination.error(err);
    }
  };

  return SkipWhileSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/startWith.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.startWith = startWith;

var _concat = require("../observable/concat");

var _isScheduler = require("../util/isScheduler");

/** PURE_IMPORTS_START _observable_concat,_util_isScheduler PURE_IMPORTS_END */
function startWith() {
  var array = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    array[_i] = arguments[_i];
  }

  var scheduler = array[array.length - 1];

  if ((0, _isScheduler.isScheduler)(scheduler)) {
    array.pop();
    return function (source) {
      return (0, _concat.concat)(array, source, scheduler);
    };
  } else {
    return function (source) {
      return (0, _concat.concat)(array, source);
    };
  }
}
},{"../observable/concat":"../../../../node_modules/rxjs/_esm5/internal/observable/concat.js","../util/isScheduler":"../../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js"}],"../../../../node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SubscribeOnObservable = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Observable = require("../Observable");

var _asap = require("../scheduler/asap");

var _isNumeric = require("../util/isNumeric");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */
var SubscribeOnObservable =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(SubscribeOnObservable, _super);

  function SubscribeOnObservable(source, delayTime, scheduler) {
    if (delayTime === void 0) {
      delayTime = 0;
    }

    if (scheduler === void 0) {
      scheduler = _asap.asap;
    }

    var _this = _super.call(this) || this;

    _this.source = source;
    _this.delayTime = delayTime;
    _this.scheduler = scheduler;

    if (!(0, _isNumeric.isNumeric)(delayTime) || delayTime < 0) {
      _this.delayTime = 0;
    }

    if (!scheduler || typeof scheduler.schedule !== 'function') {
      _this.scheduler = _asap.asap;
    }

    return _this;
  }

  SubscribeOnObservable.create = function (source, delay, scheduler) {
    if (delay === void 0) {
      delay = 0;
    }

    if (scheduler === void 0) {
      scheduler = _asap.asap;
    }

    return new SubscribeOnObservable(source, delay, scheduler);
  };

  SubscribeOnObservable.dispatch = function (arg) {
    var source = arg.source,
        subscriber = arg.subscriber;
    return this.add(source.subscribe(subscriber));
  };

  SubscribeOnObservable.prototype._subscribe = function (subscriber) {
    var delay = this.delayTime;
    var source = this.source;
    var scheduler = this.scheduler;
    return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
      source: source,
      subscriber: subscriber
    });
  };

  return SubscribeOnObservable;
}(_Observable.Observable);

exports.SubscribeOnObservable = SubscribeOnObservable;
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Observable":"../../../../node_modules/rxjs/_esm5/internal/Observable.js","../scheduler/asap":"../../../../node_modules/rxjs/_esm5/internal/scheduler/asap.js","../util/isNumeric":"../../../../node_modules/rxjs/_esm5/internal/util/isNumeric.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/subscribeOn.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.subscribeOn = subscribeOn;

var _SubscribeOnObservable = require("../observable/SubscribeOnObservable");

/** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */
function subscribeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }

  return function subscribeOnOperatorFunction(source) {
    return source.lift(new SubscribeOnOperator(scheduler, delay));
  };
}

var SubscribeOnOperator =
/*@__PURE__*/
function () {
  function SubscribeOnOperator(scheduler, delay) {
    this.scheduler = scheduler;
    this.delay = delay;
  }

  SubscribeOnOperator.prototype.call = function (subscriber, source) {
    return new _SubscribeOnObservable.SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
  };

  return SubscribeOnOperator;
}();
},{"../observable/SubscribeOnObservable":"../../../../node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/switchMap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.switchMap = switchMap;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _OuterSubscriber = require("../OuterSubscriber");

var _InnerSubscriber = require("../InnerSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

var _map = require("./map");

var _from = require("../observable/from");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
function switchMap(project, resultSelector) {
  if (typeof resultSelector === 'function') {
    return function (source) {
      return source.pipe(switchMap(function (a, i) {
        return (0, _from.from)(project(a, i)).pipe((0, _map.map)(function (b, ii) {
          return resultSelector(a, b, i, ii);
        }));
      }));
    };
  }

  return function (source) {
    return source.lift(new SwitchMapOperator(project));
  };
}

var SwitchMapOperator =
/*@__PURE__*/
function () {
  function SwitchMapOperator(project) {
    this.project = project;
  }

  SwitchMapOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
  };

  return SwitchMapOperator;
}();

var SwitchMapSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(SwitchMapSubscriber, _super);

  function SwitchMapSubscriber(destination, project) {
    var _this = _super.call(this, destination) || this;

    _this.project = project;
    _this.index = 0;
    return _this;
  }

  SwitchMapSubscriber.prototype._next = function (value) {
    var result;
    var index = this.index++;

    try {
      result = this.project(value, index);
    } catch (error) {
      this.destination.error(error);
      return;
    }

    this._innerSub(result, value, index);
  };

  SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
    var innerSubscription = this.innerSubscription;

    if (innerSubscription) {
      innerSubscription.unsubscribe();
    }

    var innerSubscriber = new _InnerSubscriber.InnerSubscriber(this, undefined, undefined);
    var destination = this.destination;
    destination.add(innerSubscriber);
    this.innerSubscription = (0, _subscribeToResult.subscribeToResult)(this, result, value, index, innerSubscriber);
  };

  SwitchMapSubscriber.prototype._complete = function () {
    var innerSubscription = this.innerSubscription;

    if (!innerSubscription || innerSubscription.closed) {
      _super.prototype._complete.call(this);
    }

    this.unsubscribe();
  };

  SwitchMapSubscriber.prototype._unsubscribe = function () {
    this.innerSubscription = null;
  };

  SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
    var destination = this.destination;
    destination.remove(innerSub);
    this.innerSubscription = null;

    if (this.isStopped) {
      _super.prototype._complete.call(this);
    }
  };

  SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  };

  return SwitchMapSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../InnerSubscriber":"../../../../node_modules/rxjs/_esm5/internal/InnerSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js","./map":"../../../../node_modules/rxjs/_esm5/internal/operators/map.js","../observable/from":"../../../../node_modules/rxjs/_esm5/internal/observable/from.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/switchAll.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.switchAll = switchAll;

var _switchMap = require("./switchMap");

var _identity = require("../util/identity");

/** PURE_IMPORTS_START _switchMap,_util_identity PURE_IMPORTS_END */
function switchAll() {
  return (0, _switchMap.switchMap)(_identity.identity);
}
},{"./switchMap":"../../../../node_modules/rxjs/_esm5/internal/operators/switchMap.js","../util/identity":"../../../../node_modules/rxjs/_esm5/internal/util/identity.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/switchMapTo.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.switchMapTo = switchMapTo;

var _switchMap = require("./switchMap");

/** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */
function switchMapTo(innerObservable, resultSelector) {
  return resultSelector ? (0, _switchMap.switchMap)(function () {
    return innerObservable;
  }, resultSelector) : (0, _switchMap.switchMap)(function () {
    return innerObservable;
  });
}
},{"./switchMap":"../../../../node_modules/rxjs/_esm5/internal/operators/switchMap.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/takeUntil.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.takeUntil = takeUntil;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function takeUntil(notifier) {
  return function (source) {
    return source.lift(new TakeUntilOperator(notifier));
  };
}

var TakeUntilOperator =
/*@__PURE__*/
function () {
  function TakeUntilOperator(notifier) {
    this.notifier = notifier;
  }

  TakeUntilOperator.prototype.call = function (subscriber, source) {
    var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
    var notifierSubscription = (0, _subscribeToResult.subscribeToResult)(takeUntilSubscriber, this.notifier);

    if (notifierSubscription && !takeUntilSubscriber.seenValue) {
      takeUntilSubscriber.add(notifierSubscription);
      return source.subscribe(takeUntilSubscriber);
    }

    return takeUntilSubscriber;
  };

  return TakeUntilOperator;
}();

var TakeUntilSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(TakeUntilSubscriber, _super);

  function TakeUntilSubscriber(destination) {
    var _this = _super.call(this, destination) || this;

    _this.seenValue = false;
    return _this;
  }

  TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.seenValue = true;
    this.complete();
  };

  TakeUntilSubscriber.prototype.notifyComplete = function () {};

  return TakeUntilSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/takeWhile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.takeWhile = takeWhile;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }

  return function (source) {
    return source.lift(new TakeWhileOperator(predicate, inclusive));
  };
}

var TakeWhileOperator =
/*@__PURE__*/
function () {
  function TakeWhileOperator(predicate, inclusive) {
    this.predicate = predicate;
    this.inclusive = inclusive;
  }

  TakeWhileOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
  };

  return TakeWhileOperator;
}();

var TakeWhileSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(TakeWhileSubscriber, _super);

  function TakeWhileSubscriber(destination, predicate, inclusive) {
    var _this = _super.call(this, destination) || this;

    _this.predicate = predicate;
    _this.inclusive = inclusive;
    _this.index = 0;
    return _this;
  }

  TakeWhileSubscriber.prototype._next = function (value) {
    var destination = this.destination;
    var result;

    try {
      result = this.predicate(value, this.index++);
    } catch (err) {
      destination.error(err);
      return;
    }

    this.nextOrComplete(value, result);
  };

  TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
    var destination = this.destination;

    if (Boolean(predicateResult)) {
      destination.next(value);
    } else {
      if (this.inclusive) {
        destination.next(value);
      }

      destination.complete();
    }
  };

  return TakeWhileSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/tap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tap = tap;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

var _noop = require("../util/noop");

var _isFunction = require("../util/isFunction");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */
function tap(nextOrObserver, error, complete) {
  return function tapOperatorFunction(source) {
    return source.lift(new DoOperator(nextOrObserver, error, complete));
  };
}

var DoOperator =
/*@__PURE__*/
function () {
  function DoOperator(nextOrObserver, error, complete) {
    this.nextOrObserver = nextOrObserver;
    this.error = error;
    this.complete = complete;
  }

  DoOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
  };

  return DoOperator;
}();

var TapSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(TapSubscriber, _super);

  function TapSubscriber(destination, observerOrNext, error, complete) {
    var _this = _super.call(this, destination) || this;

    _this._tapNext = _noop.noop;
    _this._tapError = _noop.noop;
    _this._tapComplete = _noop.noop;
    _this._tapError = error || _noop.noop;
    _this._tapComplete = complete || _noop.noop;

    if ((0, _isFunction.isFunction)(observerOrNext)) {
      _this._context = _this;
      _this._tapNext = observerOrNext;
    } else if (observerOrNext) {
      _this._context = observerOrNext;
      _this._tapNext = observerOrNext.next || _noop.noop;
      _this._tapError = observerOrNext.error || _noop.noop;
      _this._tapComplete = observerOrNext.complete || _noop.noop;
    }

    return _this;
  }

  TapSubscriber.prototype._next = function (value) {
    try {
      this._tapNext.call(this._context, value);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    this.destination.next(value);
  };

  TapSubscriber.prototype._error = function (err) {
    try {
      this._tapError.call(this._context, err);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    this.destination.error(err);
  };

  TapSubscriber.prototype._complete = function () {
    try {
      this._tapComplete.call(this._context);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    return this.destination.complete();
  };

  return TapSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../util/noop":"../../../../node_modules/rxjs/_esm5/internal/util/noop.js","../util/isFunction":"../../../../node_modules/rxjs/_esm5/internal/util/isFunction.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/throttle.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.throttle = throttle;
exports.defaultThrottleConfig = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var defaultThrottleConfig = {
  leading: true,
  trailing: false
};
exports.defaultThrottleConfig = defaultThrottleConfig;

function throttle(durationSelector, config) {
  if (config === void 0) {
    config = defaultThrottleConfig;
  }

  return function (source) {
    return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing));
  };
}

var ThrottleOperator =
/*@__PURE__*/
function () {
  function ThrottleOperator(durationSelector, leading, trailing) {
    this.durationSelector = durationSelector;
    this.leading = leading;
    this.trailing = trailing;
  }

  ThrottleOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
  };

  return ThrottleOperator;
}();

var ThrottleSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(ThrottleSubscriber, _super);

  function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
    var _this = _super.call(this, destination) || this;

    _this.destination = destination;
    _this.durationSelector = durationSelector;
    _this._leading = _leading;
    _this._trailing = _trailing;
    _this._hasValue = false;
    return _this;
  }

  ThrottleSubscriber.prototype._next = function (value) {
    this._hasValue = true;
    this._sendValue = value;

    if (!this._throttled) {
      if (this._leading) {
        this.send();
      } else {
        this.throttle(value);
      }
    }
  };

  ThrottleSubscriber.prototype.send = function () {
    var _a = this,
        _hasValue = _a._hasValue,
        _sendValue = _a._sendValue;

    if (_hasValue) {
      this.destination.next(_sendValue);
      this.throttle(_sendValue);
    }

    this._hasValue = false;
    this._sendValue = null;
  };

  ThrottleSubscriber.prototype.throttle = function (value) {
    var duration = this.tryDurationSelector(value);

    if (!!duration) {
      this.add(this._throttled = (0, _subscribeToResult.subscribeToResult)(this, duration));
    }
  };

  ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
    try {
      return this.durationSelector(value);
    } catch (err) {
      this.destination.error(err);
      return null;
    }
  };

  ThrottleSubscriber.prototype.throttlingDone = function () {
    var _a = this,
        _throttled = _a._throttled,
        _trailing = _a._trailing;

    if (_throttled) {
      _throttled.unsubscribe();
    }

    this._throttled = null;

    if (_trailing) {
      this.send();
    }
  };

  ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.throttlingDone();
  };

  ThrottleSubscriber.prototype.notifyComplete = function () {
    this.throttlingDone();
  };

  return ThrottleSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/throttleTime.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.throttleTime = throttleTime;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

var _async = require("../scheduler/async");

var _throttle = require("./throttle");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */
function throttleTime(duration, scheduler, config) {
  if (scheduler === void 0) {
    scheduler = _async.async;
  }

  if (config === void 0) {
    config = _throttle.defaultThrottleConfig;
  }

  return function (source) {
    return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));
  };
}

var ThrottleTimeOperator =
/*@__PURE__*/
function () {
  function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
    this.duration = duration;
    this.scheduler = scheduler;
    this.leading = leading;
    this.trailing = trailing;
  }

  ThrottleTimeOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
  };

  return ThrottleTimeOperator;
}();

var ThrottleTimeSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(ThrottleTimeSubscriber, _super);

  function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
    var _this = _super.call(this, destination) || this;

    _this.duration = duration;
    _this.scheduler = scheduler;
    _this.leading = leading;
    _this.trailing = trailing;
    _this._hasTrailingValue = false;
    _this._trailingValue = null;
    return _this;
  }

  ThrottleTimeSubscriber.prototype._next = function (value) {
    if (this.throttled) {
      if (this.trailing) {
        this._trailingValue = value;
        this._hasTrailingValue = true;
      }
    } else {
      this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, {
        subscriber: this
      }));

      if (this.leading) {
        this.destination.next(value);
      } else if (this.trailing) {
        this._trailingValue = value;
        this._hasTrailingValue = true;
      }
    }
  };

  ThrottleTimeSubscriber.prototype._complete = function () {
    if (this._hasTrailingValue) {
      this.destination.next(this._trailingValue);
      this.destination.complete();
    } else {
      this.destination.complete();
    }
  };

  ThrottleTimeSubscriber.prototype.clearThrottle = function () {
    var throttled = this.throttled;

    if (throttled) {
      if (this.trailing && this._hasTrailingValue) {
        this.destination.next(this._trailingValue);
        this._trailingValue = null;
        this._hasTrailingValue = false;
      }

      throttled.unsubscribe();
      this.remove(throttled);
      this.throttled = null;
    }
  };

  return ThrottleTimeSubscriber;
}(_Subscriber.Subscriber);

function dispatchNext(arg) {
  var subscriber = arg.subscriber;
  subscriber.clearThrottle();
}
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../scheduler/async":"../../../../node_modules/rxjs/_esm5/internal/scheduler/async.js","./throttle":"../../../../node_modules/rxjs/_esm5/internal/operators/throttle.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/timeInterval.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.timeInterval = timeInterval;
exports.TimeInterval = void 0;

var _async = require("../scheduler/async");

var _scan = require("./scan");

var _defer = require("../observable/defer");

var _map = require("./map");

/** PURE_IMPORTS_START _scheduler_async,_scan,_observable_defer,_map PURE_IMPORTS_END */
function timeInterval(scheduler) {
  if (scheduler === void 0) {
    scheduler = _async.async;
  }

  return function (source) {
    return (0, _defer.defer)(function () {
      return source.pipe((0, _scan.scan)(function (_a, value) {
        var current = _a.current;
        return {
          value: value,
          current: scheduler.now(),
          last: current
        };
      }, {
        current: scheduler.now(),
        value: undefined,
        last: undefined
      }), (0, _map.map)(function (_a) {
        var current = _a.current,
            last = _a.last,
            value = _a.value;
        return new TimeInterval(value, current - last);
      }));
    });
  };
}

var TimeInterval =
/*@__PURE__*/
function () {
  function TimeInterval(value, interval) {
    this.value = value;
    this.interval = interval;
  }

  return TimeInterval;
}();

exports.TimeInterval = TimeInterval;
},{"../scheduler/async":"../../../../node_modules/rxjs/_esm5/internal/scheduler/async.js","./scan":"../../../../node_modules/rxjs/_esm5/internal/operators/scan.js","../observable/defer":"../../../../node_modules/rxjs/_esm5/internal/observable/defer.js","./map":"../../../../node_modules/rxjs/_esm5/internal/operators/map.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/timeoutWith.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.timeoutWith = timeoutWith;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _async = require("../scheduler/async");

var _isDate = require("../util/isDate");

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function timeoutWith(due, withObservable, scheduler) {
  if (scheduler === void 0) {
    scheduler = _async.async;
  }

  return function (source) {
    var absoluteTimeout = (0, _isDate.isDate)(due);
    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
  };
}

var TimeoutWithOperator =
/*@__PURE__*/
function () {
  function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
    this.waitFor = waitFor;
    this.absoluteTimeout = absoluteTimeout;
    this.withObservable = withObservable;
    this.scheduler = scheduler;
  }

  TimeoutWithOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
  };

  return TimeoutWithOperator;
}();

var TimeoutWithSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(TimeoutWithSubscriber, _super);

  function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
    var _this = _super.call(this, destination) || this;

    _this.absoluteTimeout = absoluteTimeout;
    _this.waitFor = waitFor;
    _this.withObservable = withObservable;
    _this.scheduler = scheduler;
    _this.action = null;

    _this.scheduleTimeout();

    return _this;
  }

  TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
    var withObservable = subscriber.withObservable;

    subscriber._unsubscribeAndRecycle();

    subscriber.add((0, _subscribeToResult.subscribeToResult)(subscriber, withObservable));
  };

  TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
    var action = this.action;

    if (action) {
      this.action = action.schedule(this, this.waitFor);
    } else {
      this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
    }
  };

  TimeoutWithSubscriber.prototype._next = function (value) {
    if (!this.absoluteTimeout) {
      this.scheduleTimeout();
    }

    _super.prototype._next.call(this, value);
  };

  TimeoutWithSubscriber.prototype._unsubscribe = function () {
    this.action = null;
    this.scheduler = null;
    this.withObservable = null;
  };

  return TimeoutWithSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../scheduler/async":"../../../../node_modules/rxjs/_esm5/internal/scheduler/async.js","../util/isDate":"../../../../node_modules/rxjs/_esm5/internal/util/isDate.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/timeout.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.timeout = timeout;

var _async = require("../scheduler/async");

var _TimeoutError = require("../util/TimeoutError");

var _timeoutWith = require("./timeoutWith");

var _throwError = require("../observable/throwError");

/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */
function timeout(due, scheduler) {
  if (scheduler === void 0) {
    scheduler = _async.async;
  }

  return (0, _timeoutWith.timeoutWith)(due, (0, _throwError.throwError)(new _TimeoutError.TimeoutError()), scheduler);
}
},{"../scheduler/async":"../../../../node_modules/rxjs/_esm5/internal/scheduler/async.js","../util/TimeoutError":"../../../../node_modules/rxjs/_esm5/internal/util/TimeoutError.js","./timeoutWith":"../../../../node_modules/rxjs/_esm5/internal/operators/timeoutWith.js","../observable/throwError":"../../../../node_modules/rxjs/_esm5/internal/observable/throwError.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/timestamp.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.timestamp = timestamp;
exports.Timestamp = void 0;

var _async = require("../scheduler/async");

var _map = require("./map");

/** PURE_IMPORTS_START _scheduler_async,_map PURE_IMPORTS_END */
function timestamp(scheduler) {
  if (scheduler === void 0) {
    scheduler = _async.async;
  }

  return (0, _map.map)(function (value) {
    return new Timestamp(value, scheduler.now());
  });
}

var Timestamp =
/*@__PURE__*/
function () {
  function Timestamp(value, timestamp) {
    this.value = value;
    this.timestamp = timestamp;
  }

  return Timestamp;
}();

exports.Timestamp = Timestamp;
},{"../scheduler/async":"../../../../node_modules/rxjs/_esm5/internal/scheduler/async.js","./map":"../../../../node_modules/rxjs/_esm5/internal/operators/map.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/toArray.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toArray = toArray;

var _reduce = require("./reduce");

/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */
function toArrayReducer(arr, item, index) {
  if (index === 0) {
    return [item];
  }

  arr.push(item);
  return arr;
}

function toArray() {
  return (0, _reduce.reduce)(toArrayReducer, []);
}
},{"./reduce":"../../../../node_modules/rxjs/_esm5/internal/operators/reduce.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/window.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.window = window;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subject = require("../Subject");

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function window(windowBoundaries) {
  return function windowOperatorFunction(source) {
    return source.lift(new WindowOperator(windowBoundaries));
  };
}

var WindowOperator =
/*@__PURE__*/
function () {
  function WindowOperator(windowBoundaries) {
    this.windowBoundaries = windowBoundaries;
  }

  WindowOperator.prototype.call = function (subscriber, source) {
    var windowSubscriber = new WindowSubscriber(subscriber);
    var sourceSubscription = source.subscribe(windowSubscriber);

    if (!sourceSubscription.closed) {
      windowSubscriber.add((0, _subscribeToResult.subscribeToResult)(windowSubscriber, this.windowBoundaries));
    }

    return sourceSubscription;
  };

  return WindowOperator;
}();

var WindowSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(WindowSubscriber, _super);

  function WindowSubscriber(destination) {
    var _this = _super.call(this, destination) || this;

    _this.window = new _Subject.Subject();
    destination.next(_this.window);
    return _this;
  }

  WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.openWindow();
  };

  WindowSubscriber.prototype.notifyError = function (error, innerSub) {
    this._error(error);
  };

  WindowSubscriber.prototype.notifyComplete = function (innerSub) {
    this._complete();
  };

  WindowSubscriber.prototype._next = function (value) {
    this.window.next(value);
  };

  WindowSubscriber.prototype._error = function (err) {
    this.window.error(err);
    this.destination.error(err);
  };

  WindowSubscriber.prototype._complete = function () {
    this.window.complete();
    this.destination.complete();
  };

  WindowSubscriber.prototype._unsubscribe = function () {
    this.window = null;
  };

  WindowSubscriber.prototype.openWindow = function () {
    var prevWindow = this.window;

    if (prevWindow) {
      prevWindow.complete();
    }

    var destination = this.destination;
    var newWindow = this.window = new _Subject.Subject();
    destination.next(newWindow);
  };

  return WindowSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subject":"../../../../node_modules/rxjs/_esm5/internal/Subject.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/windowCount.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.windowCount = windowCount;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

var _Subject = require("../Subject");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subscriber,_Subject PURE_IMPORTS_END */
function windowCount(windowSize, startWindowEvery) {
  if (startWindowEvery === void 0) {
    startWindowEvery = 0;
  }

  return function windowCountOperatorFunction(source) {
    return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
  };
}

var WindowCountOperator =
/*@__PURE__*/
function () {
  function WindowCountOperator(windowSize, startWindowEvery) {
    this.windowSize = windowSize;
    this.startWindowEvery = startWindowEvery;
  }

  WindowCountOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
  };

  return WindowCountOperator;
}();

var WindowCountSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(WindowCountSubscriber, _super);

  function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
    var _this = _super.call(this, destination) || this;

    _this.destination = destination;
    _this.windowSize = windowSize;
    _this.startWindowEvery = startWindowEvery;
    _this.windows = [new _Subject.Subject()];
    _this.count = 0;
    destination.next(_this.windows[0]);
    return _this;
  }

  WindowCountSubscriber.prototype._next = function (value) {
    var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
    var destination = this.destination;
    var windowSize = this.windowSize;
    var windows = this.windows;
    var len = windows.length;

    for (var i = 0; i < len && !this.closed; i++) {
      windows[i].next(value);
    }

    var c = this.count - windowSize + 1;

    if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
      windows.shift().complete();
    }

    if (++this.count % startWindowEvery === 0 && !this.closed) {
      var window_1 = new _Subject.Subject();
      windows.push(window_1);
      destination.next(window_1);
    }
  };

  WindowCountSubscriber.prototype._error = function (err) {
    var windows = this.windows;

    if (windows) {
      while (windows.length > 0 && !this.closed) {
        windows.shift().error(err);
      }
    }

    this.destination.error(err);
  };

  WindowCountSubscriber.prototype._complete = function () {
    var windows = this.windows;

    if (windows) {
      while (windows.length > 0 && !this.closed) {
        windows.shift().complete();
      }
    }

    this.destination.complete();
  };

  WindowCountSubscriber.prototype._unsubscribe = function () {
    this.count = 0;
    this.windows = null;
  };

  return WindowCountSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../Subject":"../../../../node_modules/rxjs/_esm5/internal/Subject.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/windowTime.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.windowTime = windowTime;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subject = require("../Subject");

var _async = require("../scheduler/async");

var _Subscriber = require("../Subscriber");

var _isNumeric = require("../util/isNumeric");

var _isScheduler = require("../util/isScheduler");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
function windowTime(windowTimeSpan) {
  var scheduler = _async.async;
  var windowCreationInterval = null;
  var maxWindowSize = Number.POSITIVE_INFINITY;

  if ((0, _isScheduler.isScheduler)(arguments[3])) {
    scheduler = arguments[3];
  }

  if ((0, _isScheduler.isScheduler)(arguments[2])) {
    scheduler = arguments[2];
  } else if ((0, _isNumeric.isNumeric)(arguments[2])) {
    maxWindowSize = arguments[2];
  }

  if ((0, _isScheduler.isScheduler)(arguments[1])) {
    scheduler = arguments[1];
  } else if ((0, _isNumeric.isNumeric)(arguments[1])) {
    windowCreationInterval = arguments[1];
  }

  return function windowTimeOperatorFunction(source) {
    return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
  };
}

var WindowTimeOperator =
/*@__PURE__*/
function () {
  function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
    this.windowTimeSpan = windowTimeSpan;
    this.windowCreationInterval = windowCreationInterval;
    this.maxWindowSize = maxWindowSize;
    this.scheduler = scheduler;
  }

  WindowTimeOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
  };

  return WindowTimeOperator;
}();

var CountedSubject =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(CountedSubject, _super);

  function CountedSubject() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this._numberOfNextedValues = 0;
    return _this;
  }

  CountedSubject.prototype.next = function (value) {
    this._numberOfNextedValues++;

    _super.prototype.next.call(this, value);
  };

  Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
    get: function () {
      return this._numberOfNextedValues;
    },
    enumerable: true,
    configurable: true
  });
  return CountedSubject;
}(_Subject.Subject);

var WindowTimeSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(WindowTimeSubscriber, _super);

  function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
    var _this = _super.call(this, destination) || this;

    _this.destination = destination;
    _this.windowTimeSpan = windowTimeSpan;
    _this.windowCreationInterval = windowCreationInterval;
    _this.maxWindowSize = maxWindowSize;
    _this.scheduler = scheduler;
    _this.windows = [];

    var window = _this.openWindow();

    if (windowCreationInterval !== null && windowCreationInterval >= 0) {
      var closeState = {
        subscriber: _this,
        window: window,
        context: null
      };
      var creationState = {
        windowTimeSpan: windowTimeSpan,
        windowCreationInterval: windowCreationInterval,
        subscriber: _this,
        scheduler: scheduler
      };

      _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));

      _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
    } else {
      var timeSpanOnlyState = {
        subscriber: _this,
        window: window,
        windowTimeSpan: windowTimeSpan
      };

      _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
    }

    return _this;
  }

  WindowTimeSubscriber.prototype._next = function (value) {
    var windows = this.windows;
    var len = windows.length;

    for (var i = 0; i < len; i++) {
      var window_1 = windows[i];

      if (!window_1.closed) {
        window_1.next(value);

        if (window_1.numberOfNextedValues >= this.maxWindowSize) {
          this.closeWindow(window_1);
        }
      }
    }
  };

  WindowTimeSubscriber.prototype._error = function (err) {
    var windows = this.windows;

    while (windows.length > 0) {
      windows.shift().error(err);
    }

    this.destination.error(err);
  };

  WindowTimeSubscriber.prototype._complete = function () {
    var windows = this.windows;

    while (windows.length > 0) {
      var window_2 = windows.shift();

      if (!window_2.closed) {
        window_2.complete();
      }
    }

    this.destination.complete();
  };

  WindowTimeSubscriber.prototype.openWindow = function () {
    var window = new CountedSubject();
    this.windows.push(window);
    var destination = this.destination;
    destination.next(window);
    return window;
  };

  WindowTimeSubscriber.prototype.closeWindow = function (window) {
    window.complete();
    var windows = this.windows;
    windows.splice(windows.indexOf(window), 1);
  };

  return WindowTimeSubscriber;
}(_Subscriber.Subscriber);

function dispatchWindowTimeSpanOnly(state) {
  var subscriber = state.subscriber,
      windowTimeSpan = state.windowTimeSpan,
      window = state.window;

  if (window) {
    subscriber.closeWindow(window);
  }

  state.window = subscriber.openWindow();
  this.schedule(state, windowTimeSpan);
}

function dispatchWindowCreation(state) {
  var windowTimeSpan = state.windowTimeSpan,
      subscriber = state.subscriber,
      scheduler = state.scheduler,
      windowCreationInterval = state.windowCreationInterval;
  var window = subscriber.openWindow();
  var action = this;
  var context = {
    action: action,
    subscription: null
  };
  var timeSpanState = {
    subscriber: subscriber,
    window: window,
    context: context
  };
  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
  action.add(context.subscription);
  action.schedule(state, windowCreationInterval);
}

function dispatchWindowClose(state) {
  var subscriber = state.subscriber,
      window = state.window,
      context = state.context;

  if (context && context.action && context.subscription) {
    context.action.remove(context.subscription);
  }

  subscriber.closeWindow(window);
}
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subject":"../../../../node_modules/rxjs/_esm5/internal/Subject.js","../scheduler/async":"../../../../node_modules/rxjs/_esm5/internal/scheduler/async.js","../Subscriber":"../../../../node_modules/rxjs/_esm5/internal/Subscriber.js","../util/isNumeric":"../../../../node_modules/rxjs/_esm5/internal/util/isNumeric.js","../util/isScheduler":"../../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/windowToggle.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.windowToggle = windowToggle;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subject = require("../Subject");

var _Subscription = require("../Subscription");

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subject,_Subscription,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function windowToggle(openings, closingSelector) {
  return function (source) {
    return source.lift(new WindowToggleOperator(openings, closingSelector));
  };
}

var WindowToggleOperator =
/*@__PURE__*/
function () {
  function WindowToggleOperator(openings, closingSelector) {
    this.openings = openings;
    this.closingSelector = closingSelector;
  }

  WindowToggleOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
  };

  return WindowToggleOperator;
}();

var WindowToggleSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(WindowToggleSubscriber, _super);

  function WindowToggleSubscriber(destination, openings, closingSelector) {
    var _this = _super.call(this, destination) || this;

    _this.openings = openings;
    _this.closingSelector = closingSelector;
    _this.contexts = [];

    _this.add(_this.openSubscription = (0, _subscribeToResult.subscribeToResult)(_this, openings, openings));

    return _this;
  }

  WindowToggleSubscriber.prototype._next = function (value) {
    var contexts = this.contexts;

    if (contexts) {
      var len = contexts.length;

      for (var i = 0; i < len; i++) {
        contexts[i].window.next(value);
      }
    }
  };

  WindowToggleSubscriber.prototype._error = function (err) {
    var contexts = this.contexts;
    this.contexts = null;

    if (contexts) {
      var len = contexts.length;
      var index = -1;

      while (++index < len) {
        var context_1 = contexts[index];
        context_1.window.error(err);
        context_1.subscription.unsubscribe();
      }
    }

    _super.prototype._error.call(this, err);
  };

  WindowToggleSubscriber.prototype._complete = function () {
    var contexts = this.contexts;
    this.contexts = null;

    if (contexts) {
      var len = contexts.length;
      var index = -1;

      while (++index < len) {
        var context_2 = contexts[index];
        context_2.window.complete();
        context_2.subscription.unsubscribe();
      }
    }

    _super.prototype._complete.call(this);
  };

  WindowToggleSubscriber.prototype._unsubscribe = function () {
    var contexts = this.contexts;
    this.contexts = null;

    if (contexts) {
      var len = contexts.length;
      var index = -1;

      while (++index < len) {
        var context_3 = contexts[index];
        context_3.window.unsubscribe();
        context_3.subscription.unsubscribe();
      }
    }
  };

  WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    if (outerValue === this.openings) {
      var closingNotifier = void 0;

      try {
        var closingSelector = this.closingSelector;
        closingNotifier = closingSelector(innerValue);
      } catch (e) {
        return this.error(e);
      }

      var window_1 = new _Subject.Subject();
      var subscription = new _Subscription.Subscription();
      var context_4 = {
        window: window_1,
        subscription: subscription
      };
      this.contexts.push(context_4);
      var innerSubscription = (0, _subscribeToResult.subscribeToResult)(this, closingNotifier, context_4);

      if (innerSubscription.closed) {
        this.closeWindow(this.contexts.length - 1);
      } else {
        innerSubscription.context = context_4;
        subscription.add(innerSubscription);
      }

      this.destination.next(window_1);
    } else {
      this.closeWindow(this.contexts.indexOf(outerValue));
    }
  };

  WindowToggleSubscriber.prototype.notifyError = function (err) {
    this.error(err);
  };

  WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
    if (inner !== this.openSubscription) {
      this.closeWindow(this.contexts.indexOf(inner.context));
    }
  };

  WindowToggleSubscriber.prototype.closeWindow = function (index) {
    if (index === -1) {
      return;
    }

    var contexts = this.contexts;
    var context = contexts[index];
    var window = context.window,
        subscription = context.subscription;
    contexts.splice(index, 1);
    window.complete();
    subscription.unsubscribe();
  };

  return WindowToggleSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subject":"../../../../node_modules/rxjs/_esm5/internal/Subject.js","../Subscription":"../../../../node_modules/rxjs/_esm5/internal/Subscription.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/windowWhen.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.windowWhen = windowWhen;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subject = require("../Subject");

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function windowWhen(closingSelector) {
  return function windowWhenOperatorFunction(source) {
    return source.lift(new WindowOperator(closingSelector));
  };
}

var WindowOperator =
/*@__PURE__*/
function () {
  function WindowOperator(closingSelector) {
    this.closingSelector = closingSelector;
  }

  WindowOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
  };

  return WindowOperator;
}();

var WindowSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(WindowSubscriber, _super);

  function WindowSubscriber(destination, closingSelector) {
    var _this = _super.call(this, destination) || this;

    _this.destination = destination;
    _this.closingSelector = closingSelector;

    _this.openWindow();

    return _this;
  }

  WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.openWindow(innerSub);
  };

  WindowSubscriber.prototype.notifyError = function (error, innerSub) {
    this._error(error);
  };

  WindowSubscriber.prototype.notifyComplete = function (innerSub) {
    this.openWindow(innerSub);
  };

  WindowSubscriber.prototype._next = function (value) {
    this.window.next(value);
  };

  WindowSubscriber.prototype._error = function (err) {
    this.window.error(err);
    this.destination.error(err);
    this.unsubscribeClosingNotification();
  };

  WindowSubscriber.prototype._complete = function () {
    this.window.complete();
    this.destination.complete();
    this.unsubscribeClosingNotification();
  };

  WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
    if (this.closingNotification) {
      this.closingNotification.unsubscribe();
    }
  };

  WindowSubscriber.prototype.openWindow = function (innerSub) {
    if (innerSub === void 0) {
      innerSub = null;
    }

    if (innerSub) {
      this.remove(innerSub);
      innerSub.unsubscribe();
    }

    var prevWindow = this.window;

    if (prevWindow) {
      prevWindow.complete();
    }

    var window = this.window = new _Subject.Subject();
    this.destination.next(window);
    var closingNotifier;

    try {
      var closingSelector = this.closingSelector;
      closingNotifier = closingSelector();
    } catch (e) {
      this.destination.error(e);
      this.window.error(e);
      return;
    }

    this.add(this.closingNotification = (0, _subscribeToResult.subscribeToResult)(this, closingNotifier));
  };

  return WindowSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../Subject":"../../../../node_modules/rxjs/_esm5/internal/Subject.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withLatestFrom = withLatestFrom;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function withLatestFrom() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  return function (source) {
    var project;

    if (typeof args[args.length - 1] === 'function') {
      project = args.pop();
    }

    var observables = args;
    return source.lift(new WithLatestFromOperator(observables, project));
  };
}

var WithLatestFromOperator =
/*@__PURE__*/
function () {
  function WithLatestFromOperator(observables, project) {
    this.observables = observables;
    this.project = project;
  }

  WithLatestFromOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
  };

  return WithLatestFromOperator;
}();

var WithLatestFromSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(WithLatestFromSubscriber, _super);

  function WithLatestFromSubscriber(destination, observables, project) {
    var _this = _super.call(this, destination) || this;

    _this.observables = observables;
    _this.project = project;
    _this.toRespond = [];
    var len = observables.length;
    _this.values = new Array(len);

    for (var i = 0; i < len; i++) {
      _this.toRespond.push(i);
    }

    for (var i = 0; i < len; i++) {
      var observable = observables[i];

      _this.add((0, _subscribeToResult.subscribeToResult)(_this, observable, observable, i));
    }

    return _this;
  }

  WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.values[outerIndex] = innerValue;
    var toRespond = this.toRespond;

    if (toRespond.length > 0) {
      var found = toRespond.indexOf(outerIndex);

      if (found !== -1) {
        toRespond.splice(found, 1);
      }
    }
  };

  WithLatestFromSubscriber.prototype.notifyComplete = function () {};

  WithLatestFromSubscriber.prototype._next = function (value) {
    if (this.toRespond.length === 0) {
      var args = [value].concat(this.values);

      if (this.project) {
        this._tryProject(args);
      } else {
        this.destination.next(args);
      }
    }
  };

  WithLatestFromSubscriber.prototype._tryProject = function (args) {
    var result;

    try {
      result = this.project.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    this.destination.next(result);
  };

  return WithLatestFromSubscriber;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"../../../../node_modules/tslib/tslib.es6.js","../OuterSubscriber":"../../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js","../util/subscribeToResult":"../../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/zip.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zip = zip;

var _zip = require("../observable/zip");

/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */
function zip() {
  var observables = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }

  return function zipOperatorFunction(source) {
    return source.lift.call(_zip.zip.apply(void 0, [source].concat(observables)));
  };
}
},{"../observable/zip":"../../../../node_modules/rxjs/_esm5/internal/observable/zip.js"}],"../../../../node_modules/rxjs/_esm5/internal/operators/zipAll.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zipAll = zipAll;

var _zip = require("../observable/zip");

/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */
function zipAll(project) {
  return function (source) {
    return source.lift(new _zip.ZipOperator(project));
  };
}
},{"../observable/zip":"../../../../node_modules/rxjs/_esm5/internal/observable/zip.js"}],"../../../../node_modules/rxjs/_esm5/operators/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "audit", {
  enumerable: true,
  get: function () {
    return _audit.audit;
  }
});
Object.defineProperty(exports, "auditTime", {
  enumerable: true,
  get: function () {
    return _auditTime.auditTime;
  }
});
Object.defineProperty(exports, "buffer", {
  enumerable: true,
  get: function () {
    return _buffer.buffer;
  }
});
Object.defineProperty(exports, "bufferCount", {
  enumerable: true,
  get: function () {
    return _bufferCount.bufferCount;
  }
});
Object.defineProperty(exports, "bufferTime", {
  enumerable: true,
  get: function () {
    return _bufferTime.bufferTime;
  }
});
Object.defineProperty(exports, "bufferToggle", {
  enumerable: true,
  get: function () {
    return _bufferToggle.bufferToggle;
  }
});
Object.defineProperty(exports, "bufferWhen", {
  enumerable: true,
  get: function () {
    return _bufferWhen.bufferWhen;
  }
});
Object.defineProperty(exports, "catchError", {
  enumerable: true,
  get: function () {
    return _catchError.catchError;
  }
});
Object.defineProperty(exports, "combineAll", {
  enumerable: true,
  get: function () {
    return _combineAll.combineAll;
  }
});
Object.defineProperty(exports, "combineLatest", {
  enumerable: true,
  get: function () {
    return _combineLatest.combineLatest;
  }
});
Object.defineProperty(exports, "concat", {
  enumerable: true,
  get: function () {
    return _concat.concat;
  }
});
Object.defineProperty(exports, "concatAll", {
  enumerable: true,
  get: function () {
    return _concatAll.concatAll;
  }
});
Object.defineProperty(exports, "concatMap", {
  enumerable: true,
  get: function () {
    return _concatMap.concatMap;
  }
});
Object.defineProperty(exports, "concatMapTo", {
  enumerable: true,
  get: function () {
    return _concatMapTo.concatMapTo;
  }
});
Object.defineProperty(exports, "count", {
  enumerable: true,
  get: function () {
    return _count.count;
  }
});
Object.defineProperty(exports, "debounce", {
  enumerable: true,
  get: function () {
    return _debounce.debounce;
  }
});
Object.defineProperty(exports, "debounceTime", {
  enumerable: true,
  get: function () {
    return _debounceTime.debounceTime;
  }
});
Object.defineProperty(exports, "defaultIfEmpty", {
  enumerable: true,
  get: function () {
    return _defaultIfEmpty.defaultIfEmpty;
  }
});
Object.defineProperty(exports, "delay", {
  enumerable: true,
  get: function () {
    return _delay.delay;
  }
});
Object.defineProperty(exports, "delayWhen", {
  enumerable: true,
  get: function () {
    return _delayWhen.delayWhen;
  }
});
Object.defineProperty(exports, "dematerialize", {
  enumerable: true,
  get: function () {
    return _dematerialize.dematerialize;
  }
});
Object.defineProperty(exports, "distinct", {
  enumerable: true,
  get: function () {
    return _distinct.distinct;
  }
});
Object.defineProperty(exports, "distinctUntilChanged", {
  enumerable: true,
  get: function () {
    return _distinctUntilChanged.distinctUntilChanged;
  }
});
Object.defineProperty(exports, "distinctUntilKeyChanged", {
  enumerable: true,
  get: function () {
    return _distinctUntilKeyChanged.distinctUntilKeyChanged;
  }
});
Object.defineProperty(exports, "elementAt", {
  enumerable: true,
  get: function () {
    return _elementAt.elementAt;
  }
});
Object.defineProperty(exports, "endWith", {
  enumerable: true,
  get: function () {
    return _endWith.endWith;
  }
});
Object.defineProperty(exports, "every", {
  enumerable: true,
  get: function () {
    return _every.every;
  }
});
Object.defineProperty(exports, "exhaust", {
  enumerable: true,
  get: function () {
    return _exhaust.exhaust;
  }
});
Object.defineProperty(exports, "exhaustMap", {
  enumerable: true,
  get: function () {
    return _exhaustMap.exhaustMap;
  }
});
Object.defineProperty(exports, "expand", {
  enumerable: true,
  get: function () {
    return _expand.expand;
  }
});
Object.defineProperty(exports, "filter", {
  enumerable: true,
  get: function () {
    return _filter.filter;
  }
});
Object.defineProperty(exports, "finalize", {
  enumerable: true,
  get: function () {
    return _finalize.finalize;
  }
});
Object.defineProperty(exports, "find", {
  enumerable: true,
  get: function () {
    return _find.find;
  }
});
Object.defineProperty(exports, "findIndex", {
  enumerable: true,
  get: function () {
    return _findIndex.findIndex;
  }
});
Object.defineProperty(exports, "first", {
  enumerable: true,
  get: function () {
    return _first.first;
  }
});
Object.defineProperty(exports, "groupBy", {
  enumerable: true,
  get: function () {
    return _groupBy.groupBy;
  }
});
Object.defineProperty(exports, "ignoreElements", {
  enumerable: true,
  get: function () {
    return _ignoreElements.ignoreElements;
  }
});
Object.defineProperty(exports, "isEmpty", {
  enumerable: true,
  get: function () {
    return _isEmpty.isEmpty;
  }
});
Object.defineProperty(exports, "last", {
  enumerable: true,
  get: function () {
    return _last.last;
  }
});
Object.defineProperty(exports, "map", {
  enumerable: true,
  get: function () {
    return _map.map;
  }
});
Object.defineProperty(exports, "mapTo", {
  enumerable: true,
  get: function () {
    return _mapTo.mapTo;
  }
});
Object.defineProperty(exports, "materialize", {
  enumerable: true,
  get: function () {
    return _materialize.materialize;
  }
});
Object.defineProperty(exports, "max", {
  enumerable: true,
  get: function () {
    return _max.max;
  }
});
Object.defineProperty(exports, "merge", {
  enumerable: true,
  get: function () {
    return _merge.merge;
  }
});
Object.defineProperty(exports, "mergeAll", {
  enumerable: true,
  get: function () {
    return _mergeAll.mergeAll;
  }
});
Object.defineProperty(exports, "mergeMap", {
  enumerable: true,
  get: function () {
    return _mergeMap.mergeMap;
  }
});
Object.defineProperty(exports, "flatMap", {
  enumerable: true,
  get: function () {
    return _mergeMap.mergeMap;
  }
});
Object.defineProperty(exports, "mergeMapTo", {
  enumerable: true,
  get: function () {
    return _mergeMapTo.mergeMapTo;
  }
});
Object.defineProperty(exports, "mergeScan", {
  enumerable: true,
  get: function () {
    return _mergeScan.mergeScan;
  }
});
Object.defineProperty(exports, "min", {
  enumerable: true,
  get: function () {
    return _min.min;
  }
});
Object.defineProperty(exports, "multicast", {
  enumerable: true,
  get: function () {
    return _multicast.multicast;
  }
});
Object.defineProperty(exports, "observeOn", {
  enumerable: true,
  get: function () {
    return _observeOn.observeOn;
  }
});
Object.defineProperty(exports, "onErrorResumeNext", {
  enumerable: true,
  get: function () {
    return _onErrorResumeNext.onErrorResumeNext;
  }
});
Object.defineProperty(exports, "pairwise", {
  enumerable: true,
  get: function () {
    return _pairwise.pairwise;
  }
});
Object.defineProperty(exports, "partition", {
  enumerable: true,
  get: function () {
    return _partition.partition;
  }
});
Object.defineProperty(exports, "pluck", {
  enumerable: true,
  get: function () {
    return _pluck.pluck;
  }
});
Object.defineProperty(exports, "publish", {
  enumerable: true,
  get: function () {
    return _publish.publish;
  }
});
Object.defineProperty(exports, "publishBehavior", {
  enumerable: true,
  get: function () {
    return _publishBehavior.publishBehavior;
  }
});
Object.defineProperty(exports, "publishLast", {
  enumerable: true,
  get: function () {
    return _publishLast.publishLast;
  }
});
Object.defineProperty(exports, "publishReplay", {
  enumerable: true,
  get: function () {
    return _publishReplay.publishReplay;
  }
});
Object.defineProperty(exports, "race", {
  enumerable: true,
  get: function () {
    return _race.race;
  }
});
Object.defineProperty(exports, "reduce", {
  enumerable: true,
  get: function () {
    return _reduce.reduce;
  }
});
Object.defineProperty(exports, "repeat", {
  enumerable: true,
  get: function () {
    return _repeat.repeat;
  }
});
Object.defineProperty(exports, "repeatWhen", {
  enumerable: true,
  get: function () {
    return _repeatWhen.repeatWhen;
  }
});
Object.defineProperty(exports, "retry", {
  enumerable: true,
  get: function () {
    return _retry.retry;
  }
});
Object.defineProperty(exports, "retryWhen", {
  enumerable: true,
  get: function () {
    return _retryWhen.retryWhen;
  }
});
Object.defineProperty(exports, "refCount", {
  enumerable: true,
  get: function () {
    return _refCount.refCount;
  }
});
Object.defineProperty(exports, "sample", {
  enumerable: true,
  get: function () {
    return _sample.sample;
  }
});
Object.defineProperty(exports, "sampleTime", {
  enumerable: true,
  get: function () {
    return _sampleTime.sampleTime;
  }
});
Object.defineProperty(exports, "scan", {
  enumerable: true,
  get: function () {
    return _scan.scan;
  }
});
Object.defineProperty(exports, "sequenceEqual", {
  enumerable: true,
  get: function () {
    return _sequenceEqual.sequenceEqual;
  }
});
Object.defineProperty(exports, "share", {
  enumerable: true,
  get: function () {
    return _share.share;
  }
});
Object.defineProperty(exports, "shareReplay", {
  enumerable: true,
  get: function () {
    return _shareReplay.shareReplay;
  }
});
Object.defineProperty(exports, "single", {
  enumerable: true,
  get: function () {
    return _single.single;
  }
});
Object.defineProperty(exports, "skip", {
  enumerable: true,
  get: function () {
    return _skip.skip;
  }
});
Object.defineProperty(exports, "skipLast", {
  enumerable: true,
  get: function () {
    return _skipLast.skipLast;
  }
});
Object.defineProperty(exports, "skipUntil", {
  enumerable: true,
  get: function () {
    return _skipUntil.skipUntil;
  }
});
Object.defineProperty(exports, "skipWhile", {
  enumerable: true,
  get: function () {
    return _skipWhile.skipWhile;
  }
});
Object.defineProperty(exports, "startWith", {
  enumerable: true,
  get: function () {
    return _startWith.startWith;
  }
});
Object.defineProperty(exports, "subscribeOn", {
  enumerable: true,
  get: function () {
    return _subscribeOn.subscribeOn;
  }
});
Object.defineProperty(exports, "switchAll", {
  enumerable: true,
  get: function () {
    return _switchAll.switchAll;
  }
});
Object.defineProperty(exports, "switchMap", {
  enumerable: true,
  get: function () {
    return _switchMap.switchMap;
  }
});
Object.defineProperty(exports, "switchMapTo", {
  enumerable: true,
  get: function () {
    return _switchMapTo.switchMapTo;
  }
});
Object.defineProperty(exports, "take", {
  enumerable: true,
  get: function () {
    return _take.take;
  }
});
Object.defineProperty(exports, "takeLast", {
  enumerable: true,
  get: function () {
    return _takeLast.takeLast;
  }
});
Object.defineProperty(exports, "takeUntil", {
  enumerable: true,
  get: function () {
    return _takeUntil.takeUntil;
  }
});
Object.defineProperty(exports, "takeWhile", {
  enumerable: true,
  get: function () {
    return _takeWhile.takeWhile;
  }
});
Object.defineProperty(exports, "tap", {
  enumerable: true,
  get: function () {
    return _tap.tap;
  }
});
Object.defineProperty(exports, "throttle", {
  enumerable: true,
  get: function () {
    return _throttle.throttle;
  }
});
Object.defineProperty(exports, "throttleTime", {
  enumerable: true,
  get: function () {
    return _throttleTime.throttleTime;
  }
});
Object.defineProperty(exports, "throwIfEmpty", {
  enumerable: true,
  get: function () {
    return _throwIfEmpty.throwIfEmpty;
  }
});
Object.defineProperty(exports, "timeInterval", {
  enumerable: true,
  get: function () {
    return _timeInterval.timeInterval;
  }
});
Object.defineProperty(exports, "timeout", {
  enumerable: true,
  get: function () {
    return _timeout.timeout;
  }
});
Object.defineProperty(exports, "timeoutWith", {
  enumerable: true,
  get: function () {
    return _timeoutWith.timeoutWith;
  }
});
Object.defineProperty(exports, "timestamp", {
  enumerable: true,
  get: function () {
    return _timestamp.timestamp;
  }
});
Object.defineProperty(exports, "toArray", {
  enumerable: true,
  get: function () {
    return _toArray.toArray;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _window.window;
  }
});
Object.defineProperty(exports, "windowCount", {
  enumerable: true,
  get: function () {
    return _windowCount.windowCount;
  }
});
Object.defineProperty(exports, "windowTime", {
  enumerable: true,
  get: function () {
    return _windowTime.windowTime;
  }
});
Object.defineProperty(exports, "windowToggle", {
  enumerable: true,
  get: function () {
    return _windowToggle.windowToggle;
  }
});
Object.defineProperty(exports, "windowWhen", {
  enumerable: true,
  get: function () {
    return _windowWhen.windowWhen;
  }
});
Object.defineProperty(exports, "withLatestFrom", {
  enumerable: true,
  get: function () {
    return _withLatestFrom.withLatestFrom;
  }
});
Object.defineProperty(exports, "zip", {
  enumerable: true,
  get: function () {
    return _zip.zip;
  }
});
Object.defineProperty(exports, "zipAll", {
  enumerable: true,
  get: function () {
    return _zipAll.zipAll;
  }
});

var _audit = require("../internal/operators/audit");

var _auditTime = require("../internal/operators/auditTime");

var _buffer = require("../internal/operators/buffer");

var _bufferCount = require("../internal/operators/bufferCount");

var _bufferTime = require("../internal/operators/bufferTime");

var _bufferToggle = require("../internal/operators/bufferToggle");

var _bufferWhen = require("../internal/operators/bufferWhen");

var _catchError = require("../internal/operators/catchError");

var _combineAll = require("../internal/operators/combineAll");

var _combineLatest = require("../internal/operators/combineLatest");

var _concat = require("../internal/operators/concat");

var _concatAll = require("../internal/operators/concatAll");

var _concatMap = require("../internal/operators/concatMap");

var _concatMapTo = require("../internal/operators/concatMapTo");

var _count = require("../internal/operators/count");

var _debounce = require("../internal/operators/debounce");

var _debounceTime = require("../internal/operators/debounceTime");

var _defaultIfEmpty = require("../internal/operators/defaultIfEmpty");

var _delay = require("../internal/operators/delay");

var _delayWhen = require("../internal/operators/delayWhen");

var _dematerialize = require("../internal/operators/dematerialize");

var _distinct = require("../internal/operators/distinct");

var _distinctUntilChanged = require("../internal/operators/distinctUntilChanged");

var _distinctUntilKeyChanged = require("../internal/operators/distinctUntilKeyChanged");

var _elementAt = require("../internal/operators/elementAt");

var _endWith = require("../internal/operators/endWith");

var _every = require("../internal/operators/every");

var _exhaust = require("../internal/operators/exhaust");

var _exhaustMap = require("../internal/operators/exhaustMap");

var _expand = require("../internal/operators/expand");

var _filter = require("../internal/operators/filter");

var _finalize = require("../internal/operators/finalize");

var _find = require("../internal/operators/find");

var _findIndex = require("../internal/operators/findIndex");

var _first = require("../internal/operators/first");

var _groupBy = require("../internal/operators/groupBy");

var _ignoreElements = require("../internal/operators/ignoreElements");

var _isEmpty = require("../internal/operators/isEmpty");

var _last = require("../internal/operators/last");

var _map = require("../internal/operators/map");

var _mapTo = require("../internal/operators/mapTo");

var _materialize = require("../internal/operators/materialize");

var _max = require("../internal/operators/max");

var _merge = require("../internal/operators/merge");

var _mergeAll = require("../internal/operators/mergeAll");

var _mergeMap = require("../internal/operators/mergeMap");

var _mergeMapTo = require("../internal/operators/mergeMapTo");

var _mergeScan = require("../internal/operators/mergeScan");

var _min = require("../internal/operators/min");

var _multicast = require("../internal/operators/multicast");

var _observeOn = require("../internal/operators/observeOn");

var _onErrorResumeNext = require("../internal/operators/onErrorResumeNext");

var _pairwise = require("../internal/operators/pairwise");

var _partition = require("../internal/operators/partition");

var _pluck = require("../internal/operators/pluck");

var _publish = require("../internal/operators/publish");

var _publishBehavior = require("../internal/operators/publishBehavior");

var _publishLast = require("../internal/operators/publishLast");

var _publishReplay = require("../internal/operators/publishReplay");

var _race = require("../internal/operators/race");

var _reduce = require("../internal/operators/reduce");

var _repeat = require("../internal/operators/repeat");

var _repeatWhen = require("../internal/operators/repeatWhen");

var _retry = require("../internal/operators/retry");

var _retryWhen = require("../internal/operators/retryWhen");

var _refCount = require("../internal/operators/refCount");

var _sample = require("../internal/operators/sample");

var _sampleTime = require("../internal/operators/sampleTime");

var _scan = require("../internal/operators/scan");

var _sequenceEqual = require("../internal/operators/sequenceEqual");

var _share = require("../internal/operators/share");

var _shareReplay = require("../internal/operators/shareReplay");

var _single = require("../internal/operators/single");

var _skip = require("../internal/operators/skip");

var _skipLast = require("../internal/operators/skipLast");

var _skipUntil = require("../internal/operators/skipUntil");

var _skipWhile = require("../internal/operators/skipWhile");

var _startWith = require("../internal/operators/startWith");

var _subscribeOn = require("../internal/operators/subscribeOn");

var _switchAll = require("../internal/operators/switchAll");

var _switchMap = require("../internal/operators/switchMap");

var _switchMapTo = require("../internal/operators/switchMapTo");

var _take = require("../internal/operators/take");

var _takeLast = require("../internal/operators/takeLast");

var _takeUntil = require("../internal/operators/takeUntil");

var _takeWhile = require("../internal/operators/takeWhile");

var _tap = require("../internal/operators/tap");

var _throttle = require("../internal/operators/throttle");

var _throttleTime = require("../internal/operators/throttleTime");

var _throwIfEmpty = require("../internal/operators/throwIfEmpty");

var _timeInterval = require("../internal/operators/timeInterval");

var _timeout = require("../internal/operators/timeout");

var _timeoutWith = require("../internal/operators/timeoutWith");

var _timestamp = require("../internal/operators/timestamp");

var _toArray = require("../internal/operators/toArray");

var _window = require("../internal/operators/window");

var _windowCount = require("../internal/operators/windowCount");

var _windowTime = require("../internal/operators/windowTime");

var _windowToggle = require("../internal/operators/windowToggle");

var _windowWhen = require("../internal/operators/windowWhen");

var _withLatestFrom = require("../internal/operators/withLatestFrom");

var _zip = require("../internal/operators/zip");

var _zipAll = require("../internal/operators/zipAll");
},{"../internal/operators/audit":"../../../../node_modules/rxjs/_esm5/internal/operators/audit.js","../internal/operators/auditTime":"../../../../node_modules/rxjs/_esm5/internal/operators/auditTime.js","../internal/operators/buffer":"../../../../node_modules/rxjs/_esm5/internal/operators/buffer.js","../internal/operators/bufferCount":"../../../../node_modules/rxjs/_esm5/internal/operators/bufferCount.js","../internal/operators/bufferTime":"../../../../node_modules/rxjs/_esm5/internal/operators/bufferTime.js","../internal/operators/bufferToggle":"../../../../node_modules/rxjs/_esm5/internal/operators/bufferToggle.js","../internal/operators/bufferWhen":"../../../../node_modules/rxjs/_esm5/internal/operators/bufferWhen.js","../internal/operators/catchError":"../../../../node_modules/rxjs/_esm5/internal/operators/catchError.js","../internal/operators/combineAll":"../../../../node_modules/rxjs/_esm5/internal/operators/combineAll.js","../internal/operators/combineLatest":"../../../../node_modules/rxjs/_esm5/internal/operators/combineLatest.js","../internal/operators/concat":"../../../../node_modules/rxjs/_esm5/internal/operators/concat.js","../internal/operators/concatAll":"../../../../node_modules/rxjs/_esm5/internal/operators/concatAll.js","../internal/operators/concatMap":"../../../../node_modules/rxjs/_esm5/internal/operators/concatMap.js","../internal/operators/concatMapTo":"../../../../node_modules/rxjs/_esm5/internal/operators/concatMapTo.js","../internal/operators/count":"../../../../node_modules/rxjs/_esm5/internal/operators/count.js","../internal/operators/debounce":"../../../../node_modules/rxjs/_esm5/internal/operators/debounce.js","../internal/operators/debounceTime":"../../../../node_modules/rxjs/_esm5/internal/operators/debounceTime.js","../internal/operators/defaultIfEmpty":"../../../../node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js","../internal/operators/delay":"../../../../node_modules/rxjs/_esm5/internal/operators/delay.js","../internal/operators/delayWhen":"../../../../node_modules/rxjs/_esm5/internal/operators/delayWhen.js","../internal/operators/dematerialize":"../../../../node_modules/rxjs/_esm5/internal/operators/dematerialize.js","../internal/operators/distinct":"../../../../node_modules/rxjs/_esm5/internal/operators/distinct.js","../internal/operators/distinctUntilChanged":"../../../../node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js","../internal/operators/distinctUntilKeyChanged":"../../../../node_modules/rxjs/_esm5/internal/operators/distinctUntilKeyChanged.js","../internal/operators/elementAt":"../../../../node_modules/rxjs/_esm5/internal/operators/elementAt.js","../internal/operators/endWith":"../../../../node_modules/rxjs/_esm5/internal/operators/endWith.js","../internal/operators/every":"../../../../node_modules/rxjs/_esm5/internal/operators/every.js","../internal/operators/exhaust":"../../../../node_modules/rxjs/_esm5/internal/operators/exhaust.js","../internal/operators/exhaustMap":"../../../../node_modules/rxjs/_esm5/internal/operators/exhaustMap.js","../internal/operators/expand":"../../../../node_modules/rxjs/_esm5/internal/operators/expand.js","../internal/operators/filter":"../../../../node_modules/rxjs/_esm5/internal/operators/filter.js","../internal/operators/finalize":"../../../../node_modules/rxjs/_esm5/internal/operators/finalize.js","../internal/operators/find":"../../../../node_modules/rxjs/_esm5/internal/operators/find.js","../internal/operators/findIndex":"../../../../node_modules/rxjs/_esm5/internal/operators/findIndex.js","../internal/operators/first":"../../../../node_modules/rxjs/_esm5/internal/operators/first.js","../internal/operators/groupBy":"../../../../node_modules/rxjs/_esm5/internal/operators/groupBy.js","../internal/operators/ignoreElements":"../../../../node_modules/rxjs/_esm5/internal/operators/ignoreElements.js","../internal/operators/isEmpty":"../../../../node_modules/rxjs/_esm5/internal/operators/isEmpty.js","../internal/operators/last":"../../../../node_modules/rxjs/_esm5/internal/operators/last.js","../internal/operators/map":"../../../../node_modules/rxjs/_esm5/internal/operators/map.js","../internal/operators/mapTo":"../../../../node_modules/rxjs/_esm5/internal/operators/mapTo.js","../internal/operators/materialize":"../../../../node_modules/rxjs/_esm5/internal/operators/materialize.js","../internal/operators/max":"../../../../node_modules/rxjs/_esm5/internal/operators/max.js","../internal/operators/merge":"../../../../node_modules/rxjs/_esm5/internal/operators/merge.js","../internal/operators/mergeAll":"../../../../node_modules/rxjs/_esm5/internal/operators/mergeAll.js","../internal/operators/mergeMap":"../../../../node_modules/rxjs/_esm5/internal/operators/mergeMap.js","../internal/operators/mergeMapTo":"../../../../node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js","../internal/operators/mergeScan":"../../../../node_modules/rxjs/_esm5/internal/operators/mergeScan.js","../internal/operators/min":"../../../../node_modules/rxjs/_esm5/internal/operators/min.js","../internal/operators/multicast":"../../../../node_modules/rxjs/_esm5/internal/operators/multicast.js","../internal/operators/observeOn":"../../../../node_modules/rxjs/_esm5/internal/operators/observeOn.js","../internal/operators/onErrorResumeNext":"../../../../node_modules/rxjs/_esm5/internal/operators/onErrorResumeNext.js","../internal/operators/pairwise":"../../../../node_modules/rxjs/_esm5/internal/operators/pairwise.js","../internal/operators/partition":"../../../../node_modules/rxjs/_esm5/internal/operators/partition.js","../internal/operators/pluck":"../../../../node_modules/rxjs/_esm5/internal/operators/pluck.js","../internal/operators/publish":"../../../../node_modules/rxjs/_esm5/internal/operators/publish.js","../internal/operators/publishBehavior":"../../../../node_modules/rxjs/_esm5/internal/operators/publishBehavior.js","../internal/operators/publishLast":"../../../../node_modules/rxjs/_esm5/internal/operators/publishLast.js","../internal/operators/publishReplay":"../../../../node_modules/rxjs/_esm5/internal/operators/publishReplay.js","../internal/operators/race":"../../../../node_modules/rxjs/_esm5/internal/operators/race.js","../internal/operators/reduce":"../../../../node_modules/rxjs/_esm5/internal/operators/reduce.js","../internal/operators/repeat":"../../../../node_modules/rxjs/_esm5/internal/operators/repeat.js","../internal/operators/repeatWhen":"../../../../node_modules/rxjs/_esm5/internal/operators/repeatWhen.js","../internal/operators/retry":"../../../../node_modules/rxjs/_esm5/internal/operators/retry.js","../internal/operators/retryWhen":"../../../../node_modules/rxjs/_esm5/internal/operators/retryWhen.js","../internal/operators/refCount":"../../../../node_modules/rxjs/_esm5/internal/operators/refCount.js","../internal/operators/sample":"../../../../node_modules/rxjs/_esm5/internal/operators/sample.js","../internal/operators/sampleTime":"../../../../node_modules/rxjs/_esm5/internal/operators/sampleTime.js","../internal/operators/scan":"../../../../node_modules/rxjs/_esm5/internal/operators/scan.js","../internal/operators/sequenceEqual":"../../../../node_modules/rxjs/_esm5/internal/operators/sequenceEqual.js","../internal/operators/share":"../../../../node_modules/rxjs/_esm5/internal/operators/share.js","../internal/operators/shareReplay":"../../../../node_modules/rxjs/_esm5/internal/operators/shareReplay.js","../internal/operators/single":"../../../../node_modules/rxjs/_esm5/internal/operators/single.js","../internal/operators/skip":"../../../../node_modules/rxjs/_esm5/internal/operators/skip.js","../internal/operators/skipLast":"../../../../node_modules/rxjs/_esm5/internal/operators/skipLast.js","../internal/operators/skipUntil":"../../../../node_modules/rxjs/_esm5/internal/operators/skipUntil.js","../internal/operators/skipWhile":"../../../../node_modules/rxjs/_esm5/internal/operators/skipWhile.js","../internal/operators/startWith":"../../../../node_modules/rxjs/_esm5/internal/operators/startWith.js","../internal/operators/subscribeOn":"../../../../node_modules/rxjs/_esm5/internal/operators/subscribeOn.js","../internal/operators/switchAll":"../../../../node_modules/rxjs/_esm5/internal/operators/switchAll.js","../internal/operators/switchMap":"../../../../node_modules/rxjs/_esm5/internal/operators/switchMap.js","../internal/operators/switchMapTo":"../../../../node_modules/rxjs/_esm5/internal/operators/switchMapTo.js","../internal/operators/take":"../../../../node_modules/rxjs/_esm5/internal/operators/take.js","../internal/operators/takeLast":"../../../../node_modules/rxjs/_esm5/internal/operators/takeLast.js","../internal/operators/takeUntil":"../../../../node_modules/rxjs/_esm5/internal/operators/takeUntil.js","../internal/operators/takeWhile":"../../../../node_modules/rxjs/_esm5/internal/operators/takeWhile.js","../internal/operators/tap":"../../../../node_modules/rxjs/_esm5/internal/operators/tap.js","../internal/operators/throttle":"../../../../node_modules/rxjs/_esm5/internal/operators/throttle.js","../internal/operators/throttleTime":"../../../../node_modules/rxjs/_esm5/internal/operators/throttleTime.js","../internal/operators/throwIfEmpty":"../../../../node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js","../internal/operators/timeInterval":"../../../../node_modules/rxjs/_esm5/internal/operators/timeInterval.js","../internal/operators/timeout":"../../../../node_modules/rxjs/_esm5/internal/operators/timeout.js","../internal/operators/timeoutWith":"../../../../node_modules/rxjs/_esm5/internal/operators/timeoutWith.js","../internal/operators/timestamp":"../../../../node_modules/rxjs/_esm5/internal/operators/timestamp.js","../internal/operators/toArray":"../../../../node_modules/rxjs/_esm5/internal/operators/toArray.js","../internal/operators/window":"../../../../node_modules/rxjs/_esm5/internal/operators/window.js","../internal/operators/windowCount":"../../../../node_modules/rxjs/_esm5/internal/operators/windowCount.js","../internal/operators/windowTime":"../../../../node_modules/rxjs/_esm5/internal/operators/windowTime.js","../internal/operators/windowToggle":"../../../../node_modules/rxjs/_esm5/internal/operators/windowToggle.js","../internal/operators/windowWhen":"../../../../node_modules/rxjs/_esm5/internal/operators/windowWhen.js","../internal/operators/withLatestFrom":"../../../../node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js","../internal/operators/zip":"../../../../node_modules/rxjs/_esm5/internal/operators/zip.js","../internal/operators/zipAll":"../../../../node_modules/rxjs/_esm5/internal/operators/zipAll.js"}],"../../../compat/is_offline.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Some browsers have a builtin API to know if it's connected at least to a
 * LAN network, at most to the internet.
 *
 * /!\ This feature can be dangerous as you can both have false positives and
 * false negatives.
 *
 * False positives:
 *   - you can still play local contents (on localhost) if isOffline == true
 *   - on some browsers isOffline might be true even if we're connected to a LAN
 *     or a router (it would mean we're just not able to connect to the
 *     Internet). So we can eventually play LAN contents if isOffline == true
 *
 * False negatives:
 *   - in some cases, we even might have isOffline at false when we do not have
 *     any connection:
 *       - in browsers that do not support the feature
 *       - in browsers running in some virtualization softwares where the
 *         network adapters are always connected.
 *
 * Use with these cases in mind.
 * @returns {Boolean}
 */

function isOffline() {
  /* tslint:disable no-boolean-literal-compare */
  return navigator.onLine === false;
  /* tslint:enable no-boolean-literal-compare */
}

exports.default = isOffline;
},{}],"../../../errors/assertion_error.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Error due to an abnormal assertion fails.
 *
 * @class AssertionError
 * @extends Error
 */

var AssertionError =
/*#__PURE__*/
function (_Error) {
  _inherits(AssertionError, _Error);

  /**
   * @param {string} message
   */
  function AssertionError(message) {
    var _this;

    _classCallCheck(this, AssertionError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this)); // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(_assertThisInitialized(_this), AssertionError.prototype);
    _this.name = "AssertionError";
    _this.message = message;
    return _this;
  }

  return AssertionError;
}(_wrapNativeSuper(Error));

exports.default = AssertionError;
},{}],"../../../errors/error_codes.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var ErrorTypes = {
  NETWORK_ERROR: "NETWORK_ERROR",
  MEDIA_ERROR: "MEDIA_ERROR",
  ENCRYPTED_MEDIA_ERROR: "ENCRYPTED_MEDIA_ERROR",
  OTHER_ERROR: "OTHER_ERROR"
};
exports.ErrorTypes = ErrorTypes;
var NetworkErrorTypes = {
  TIMEOUT: "TIMEOUT",
  ERROR_EVENT: "ERROR_EVENT",
  ERROR_HTTP_CODE: "ERROR_HTTP_CODE",
  PARSE_ERROR: "PARSE_ERROR"
};
exports.NetworkErrorTypes = NetworkErrorTypes;
var ErrorCodes = {
  PIPELINE_LOAD_ERROR: "PIPELINE_LOAD_ERROR",
  PIPELINE_PARSE_ERROR: "PIPELINE_PARSE_ERROR",
  INTEGRITY_ERROR: "INTEGRITY_ERROR",
  MANIFEST_PARSE_ERROR: "MANIFEST_PARSE_ERROR",
  MANIFEST_INCOMPATIBLE_CODECS_ERROR: "MANIFEST_INCOMPATIBLE_CODECS_ERROR",
  MANIFEST_UNSUPPORTED_ADAPTATION_TYPE: "MANIFEST_UNSUPPORTED_ADAPTATION_TYPE",
  MEDIA_STARTING_TIME_NOT_FOUND: "MEDIA_STARTING_TIME_NOT_FOUND",
  MEDIA_TIME_BEFORE_MANIFEST: "MEDIA_TIME_BEFORE_MANIFEST",
  MEDIA_TIME_AFTER_MANIFEST: "MEDIA_TIME_AFTER_MANIFEST",
  MEDIA_TIME_NOT_FOUND: "MEDIA_TIME_NOT_FOUND",
  MEDIA_IS_ENCRYPTED_ERROR: "MEDIA_IS_ENCRYPTED_ERROR",
  CREATE_MEDIA_KEYS_ERROR: "CREATE_MEDIA_KEYS_ERROR",
  KEY_ERROR: "KEY_ERROR",
  KEY_STATUS_CHANGE_ERROR: "KEY_STATUS_CHANGE_ERROR",
  KEY_UPDATE_ERROR: "KEY_UPDATE_ERROR",
  KEY_LOAD_ERROR: "KEY_LOAD_ERROR",
  KEY_LOAD_TIMEOUT: "KEY_LOAD_TIMEOUT",
  KEY_GENERATE_REQUEST_ERROR: "KEY_GENERATE_REQUEST_ERROR",
  INCOMPATIBLE_KEYSYSTEMS: "INCOMPATIBLE_KEYSYSTEMS",
  INVALID_ENCRYPTED_EVENT: "INVALID_ENCRYPTED_EVENT",
  INVALID_KEY_SYSTEM: "INVALID_KEY_SYSTEM",
  LICENSE_SERVER_CERTIFICATE_ERROR: "LICENSE_SERVER_CERTIFICATE_ERROR",
  MULTIPLE_SESSIONS_SAME_INIT_DATA: "MULTIPLE_SESSIONS_SAME_INIT_DATA",
  BUFFER_APPEND_ERROR: "BUFFER_APPEND_ERROR",
  BUFFER_FULL_ERROR: "BUFFER_FULL_ERROR",
  BUFFER_TYPE_UNKNOWN: "BUFFER_TYPE_UNKNOWN",
  MEDIA_ERR_BLOCKED_AUTOPLAY: "MEDIA_ERR_BLOCKED_AUTOPLAY",
  MEDIA_ERR_PLAY_NOT_ALLOWED: "MEDIA_ERR_PLAY_NOT_ALLOWED",
  MEDIA_ERR_NOT_LOADED_METADATA: "MEDIA_ERR_NOT_LOADED_METADATA",
  MEDIA_ERR_ABORTED: "MEDIA_ERR_ABORTED",
  MEDIA_ERR_NETWORK: "MEDIA_ERR_NETWORK",
  MEDIA_ERR_DECODE: "MEDIA_ERR_DECODE",
  MEDIA_ERR_SRC_NOT_SUPPORTED: "MEDIA_ERR_SRC_NOT_SUPPORTED",
  MEDIA_ERR_UNKNOWN: "MEDIA_ERR_UNKNOWN",
  MEDIA_SOURCE_NOT_SUPPORTED: "MEDIA_SOURCE_NOT_SUPPORTED",
  MEDIA_KEYS_NOT_SUPPORTED: "MEDIA_KEYS_NOT_SUPPORTED",
  NONE: "NONE"
};
exports.ErrorCodes = ErrorCodes;
},{}],"../../../errors/error_message.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Generate a normalized error message.
 * @param {string} name
 * @param {string} code
 * @param {Error|string|Event|null} [reason]
 * @returns {string}
 */

function errorMessage(name, code, reason) {
  return "".concat(name, " (").concat(code, ") ").concat(reason);
}

exports.default = errorMessage;
},{}],"../../../errors/encrypted_media_error.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var error_codes_1 = require("./error_codes");

var error_message_1 = __importDefault(require("./error_message"));
/**
 * Error linked to the encryption of the media.
 *
 * @class EncryptedMediaError
 * @extends Error
 */


var EncryptedMediaError =
/*#__PURE__*/
function (_Error) {
  _inherits(EncryptedMediaError, _Error);

  /**
   * @param {string} code
   * @param {string} reason
   * @Param {Boolean} fatal
   */
  function EncryptedMediaError(code, reason) {
    var _this;

    _classCallCheck(this, EncryptedMediaError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(EncryptedMediaError).call(this)); // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(_assertThisInitialized(_this), EncryptedMediaError.prototype);
    _this.name = "EncryptedMediaError";
    _this.type = error_codes_1.ErrorTypes.ENCRYPTED_MEDIA_ERROR;
    _this.code = code;
    _this.message = error_message_1.default(_this.name, _this.code, reason);
    _this.fatal = false;
    return _this;
  }

  return EncryptedMediaError;
}(_wrapNativeSuper(Error));

exports.default = EncryptedMediaError;
},{"./error_codes":"../../../errors/error_codes.ts","./error_message":"../../../errors/error_message.ts"}],"../../../errors/media_error.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var error_codes_1 = require("./error_codes");

var error_message_1 = __importDefault(require("./error_message"));
/**
 * Error linked to the media Playback.
 *
 * @class MediaError
 * @extends Error
 */


var MediaError =
/*#__PURE__*/
function (_Error) {
  _inherits(MediaError, _Error);

  /**
   * @param {string} code
   * @param {string} reason
   * @param {Boolean} fatal
   */
  function MediaError(code, reason) {
    var _this;

    _classCallCheck(this, MediaError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MediaError).call(this)); // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(_assertThisInitialized(_this), MediaError.prototype);
    _this.name = "MediaError";
    _this.type = error_codes_1.ErrorTypes.MEDIA_ERROR;
    _this.code = code;
    _this.message = error_message_1.default(_this.name, _this.code, reason);
    _this.fatal = false;
    return _this;
  }

  return MediaError;
}(_wrapNativeSuper(Error));

exports.default = MediaError;
},{"./error_codes":"../../../errors/error_codes.ts","./error_message":"../../../errors/error_message.ts"}],"../../../errors/network_error.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var error_codes_1 = require("./error_codes");

var error_message_1 = __importDefault(require("./error_message"));
/**
 * Error linked to network interactions (requests).
 *
 * @class NetworkError
 * @extends Error
 */


var NetworkError =
/*#__PURE__*/
function (_Error) {
  _inherits(NetworkError, _Error);

  /**
   * @param {string} code
   * @param {Error} options
   * @param {Boolean} fatal
   */
  function NetworkError(code, options) {
    var _this;

    _classCallCheck(this, NetworkError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(NetworkError).call(this)); // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(_assertThisInitialized(_this), NetworkError.prototype);
    _this.name = "NetworkError";
    _this.type = error_codes_1.ErrorTypes.NETWORK_ERROR;
    _this.xhr = options.xhr === undefined ? null : options.xhr;
    _this.url = options.url;
    _this.status = options.status;
    _this.errorType = options.type;
    _this.code = code;
    _this.message = error_message_1.default(_this.name, _this.code, options.message);
    _this.fatal = false;
    return _this;
  }
  /**
   * Returns true if the NetworkError is due to the given http error code
   * @param {number} httpErrorCode
   * @returns {Boolean}
   */


  _createClass(NetworkError, [{
    key: "isHttpError",
    value: function isHttpError(httpErrorCode) {
      return this.errorType === error_codes_1.NetworkErrorTypes.ERROR_HTTP_CODE && this.status === httpErrorCode;
    }
  }]);

  return NetworkError;
}(_wrapNativeSuper(Error));

exports.default = NetworkError;
},{"./error_codes":"../../../errors/error_codes.ts","./error_message":"../../../errors/error_message.ts"}],"../../../errors/other_error.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var error_codes_1 = require("./error_codes");

var error_message_1 = __importDefault(require("./error_message"));
/**
 * @class OtherError
 * @extends Error
 */


var OtherError =
/*#__PURE__*/
function (_Error) {
  _inherits(OtherError, _Error);

  /**
   * @param {string} code
   * @param {string} reason
   * @param {Boolean} fatal
   */
  function OtherError(code, reason) {
    var _this;

    _classCallCheck(this, OtherError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(OtherError).call(this)); // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(_assertThisInitialized(_this), OtherError.prototype);
    _this.name = "OtherError";
    _this.type = error_codes_1.ErrorTypes.OTHER_ERROR;
    _this.code = code;
    _this.message = error_message_1.default(_this.name, _this.code, reason);
    _this.fatal = false;
    return _this;
  }

  return OtherError;
}(_wrapNativeSuper(Error));

exports.default = OtherError;
},{"./error_codes":"../../../errors/error_codes.ts","./error_message":"../../../errors/error_message.ts"}],"../../../errors/is_known_error.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var encrypted_media_error_1 = __importDefault(require("./encrypted_media_error"));

var error_codes_1 = require("./error_codes");

var media_error_1 = __importDefault(require("./media_error"));

var network_error_1 = __importDefault(require("./network_error"));

var other_error_1 = __importDefault(require("./other_error"));
/**
 * Whether the error given is a ICustomError.
 * @param {Error} error
 * @returns {Boolean}
 */


function isKnownError(error) {
  return (error instanceof encrypted_media_error_1.default || error instanceof media_error_1.default || error instanceof other_error_1.default || error instanceof network_error_1.default) && Object.keys(error_codes_1.ErrorTypes).indexOf(error.type) >= 0;
}

exports.default = isKnownError;
},{"./encrypted_media_error":"../../../errors/encrypted_media_error.ts","./error_codes":"../../../errors/error_codes.ts","./media_error":"../../../errors/media_error.ts","./network_error":"../../../errors/network_error.ts","./other_error":"../../../errors/other_error.ts"}],"../../../errors/format_error.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var is_known_error_1 = __importDefault(require("./is_known_error"));

var other_error_1 = __importDefault(require("./other_error"));
/*
 * Format an unknown error into an API-defined error.
 * @param {*} error
 * @returns {Error}
 */


function formatError(error, _ref) {
  var defaultCode = _ref.defaultCode,
      defaultReason = _ref.defaultReason;

  if (is_known_error_1.default(error)) {
    return error;
  }

  var reason = error instanceof Error ? error.toString() : defaultReason;
  return new other_error_1.default(defaultCode, reason);
}

exports.default = formatError;
},{"./is_known_error":"../../../errors/is_known_error.ts","./other_error":"../../../errors/other_error.ts"}],"../../../errors/request_error.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Errors linked to the XHR implentation done in the RxPlayer.
 *
 * @class RequestError
 * @extends Error
 */

var RequestError =
/*#__PURE__*/
function (_Error) {
  _inherits(RequestError, _Error);

  /**
   * @param {XMLHttpRequest} xhr
   * @param {string} url
   * @param {string} type
   */
  function RequestError(url, status, type, xhr) {
    var _this;

    _classCallCheck(this, RequestError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(RequestError).call(this)); // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(_assertThisInitialized(_this), RequestError.prototype);
    _this.name = "RequestError";
    _this.url = url;
    _this.xhr = xhr;
    _this.status = status;
    _this.type = type;
    _this.message = type;
    return _this;
  }

  return RequestError;
}(_wrapNativeSuper(Error));

exports.default = RequestError;
},{}],"../../../errors/index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var assertion_error_1 = __importDefault(require("./assertion_error"));

exports.AssertionError = assertion_error_1.default;

var encrypted_media_error_1 = __importDefault(require("./encrypted_media_error"));

exports.EncryptedMediaError = encrypted_media_error_1.default;

var error_codes_1 = require("./error_codes");

exports.ErrorCodes = error_codes_1.ErrorCodes;
exports.ErrorTypes = error_codes_1.ErrorTypes;
exports.IErrorCode = error_codes_1.IErrorCode;
exports.IErrorType = error_codes_1.IErrorType;
exports.NetworkErrorTypes = error_codes_1.NetworkErrorTypes;

var format_error_1 = __importDefault(require("./format_error"));

exports.formatError = format_error_1.default;

var is_known_error_1 = __importStar(require("./is_known_error"));

exports.isKnownError = is_known_error_1.default;
exports.ICustomError = is_known_error_1.ICustomError;

var media_error_1 = __importDefault(require("./media_error"));

exports.MediaError = media_error_1.default;

var network_error_1 = __importDefault(require("./network_error"));

exports.NetworkError = network_error_1.default;

var other_error_1 = __importDefault(require("./other_error"));

exports.OtherError = other_error_1.default;

var request_error_1 = __importDefault(require("./request_error"));

exports.RequestError = request_error_1.default;
},{"./assertion_error":"../../../errors/assertion_error.ts","./encrypted_media_error":"../../../errors/encrypted_media_error.ts","./error_codes":"../../../errors/error_codes.ts","./format_error":"../../../errors/format_error.ts","./is_known_error":"../../../errors/is_known_error.ts","./media_error":"../../../errors/media_error.ts","./network_error":"../../../errors/network_error.ts","./other_error":"../../../errors/other_error.ts","./request_error":"../../../errors/request_error.ts"}],"../../../utils/assert.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var errors_1 = require("../errors");
/**
 * Throw an AssertionError if the given assertion is false.
 * @param {boolean} assertion
 * @param {string} [message] - Optional message property for the AssertionError.
 * @throws AssertionError - Throws if the assertion given is false
 */


function assert(assertion, message) {
  if (!assertion) {
    throw new errors_1.AssertionError(message || "invalid assertion");
  }
}

exports.default = assert;
/**
 * Throws if the given Object does not respect the interface.
 * @param {Object} o
 * @param {Object} iface - Contains the checked keynames of o and link them
 * to their types (obtained through the typeof operator).
 * @param {string} [name="object"] - name of the _interface_
 * @throws AssertionError - The argument o given is not an object
 * @throws AssertionError - The _interface_ is not respected.
 */

function assertInterface(o, iface) {
  var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "object";
  assert(o != null, "".concat(name, " should be an object"));

  for (var k in iface) {
    if (iface.hasOwnProperty(k)) {
      /* tslint:disable:max-line-length */
      assert(_typeof(o[k]) === iface[k], "".concat(name, " should have property ").concat(k, " as a ").concat(iface[k]));
      /* tslint:enable:max-line-length */
    }
  }
}

exports.assertInterface = assertInterface;
},{"../errors":"../../../errors/index.ts"}],"../../../utils/byte_parsing.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var assert_1 = __importDefault(require("./assert"));
/**
 * Convert a simple string to an Uint8Array containing the corresponding
 * UTF-8 code units.
 * /!\ its implementation favors simplicity and performance over accuracy.
 * Each character having a code unit higher than 255 in UTF-16 will be
 * truncated (real value % 256).
 * Please take that into consideration when calling this function.
 * @param {string} str
 * @returns {Uint8Array}
 */


function strToBytes(str) {
  var len = str.length;
  var arr = new Uint8Array(len);

  for (var i = 0; i < len; i++) {
    arr[i] = str.charCodeAt(i) & 0xFF;
  }

  return arr;
}

exports.strToBytes = strToBytes;
/**
 * construct string from the code units given
 * @param {Uint16Array|Uint8Array} bytes
 * @returns {string}
 */

function bytesToStr(bytes) {
  // NOTE: ugly I know, but TS is problematic here (you can try)
  return String.fromCharCode.apply(null, bytes);
}

exports.bytesToStr = bytesToStr;
/**
 * construct string from the code units given.
 * Only use every other byte for each UTF-16 character.
 * @param {Uint8Array} bytes
 * @returns {string}
 */

function bytesToUTF16Str(bytes) {
  var str = "";
  var len = bytes.length;

  for (var i = 0; i < len; i += 2) {
    str += String.fromCharCode(bytes[i]);
  }

  return str;
}

exports.bytesToUTF16Str = bytesToUTF16Str;
/**
 * Convert hex codes in a string form into the corresponding bytes.
 * @param {string} str
 * @returns {Uint8Array}
 * @throws TypeError - str.length is odd
 */

function hexToBytes(str) {
  var len = str.length;
  var arr = new Uint8Array(len / 2);

  for (var i = 0, j = 0; i < len; i += 2, j++) {
    arr[j] = parseInt(str.substring(i, i + 2), 16) & 0xFF;
  }

  return arr;
}

exports.hexToBytes = hexToBytes;
/**
 * Convert bytes into the corresponding hex string, with the possibility
 * to add a separator.
 * @param {Uint8Array} bytes
 * @param {string} [sep=""] - separator. Separate each two hex character.
 * @returns {string}
 */

function bytesToHex(bytes) {
  var sep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  var hex = "";

  for (var i = 0; i < bytes.byteLength; i++) {
    hex += (bytes[i] >>> 4).toString(16);
    hex += (bytes[i] & 0xF).toString(16);

    if (sep.length && i < bytes.byteLength - 1) {
      hex += sep;
    }
  }

  return hex;
}

exports.bytesToHex = bytesToHex;
/**
 * Returns a Uint8Array from the arguments given, in order:
 *   - if the next argument given is a number N set the N next bytes to 0.
 *   - else set the next bytes to the argument given.
 * @param {...(Number|Uint8Array)} args
 * @returns {Uint8Array}
 */

function concat() {
  var l = arguments.length;
  var i = -1;
  var len = 0;
  var arg;

  while (++i < l) {
    arg = i < 0 || arguments.length <= i ? undefined : arguments[i];
    len += typeof arg === "number" ? arg : arg.length;
  }

  var arr = new Uint8Array(len);
  var offset = 0;
  i = -1;

  while (++i < l) {
    arg = i < 0 || arguments.length <= i ? undefined : arguments[i];

    if (typeof arg === "number") {
      offset += arg;
    } else if (arg.length > 0) {
      arr.set(arg, offset);
      offset += arg.length;
    }
  }

  return arr;
}

exports.concat = concat;
/**
 * Translate groups of 2 big-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */

function be2toi(bytes, offset) {
  return (bytes[offset + 0] << 8) + (bytes[offset + 1] << 0);
}

exports.be2toi = be2toi;
/**
 * Translate groups of 3 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */

function be3toi(bytes, offset) {
  return bytes[offset + 0] * 0x0010000 + bytes[offset + 1] * 0x0000100 + bytes[offset + 2];
}

exports.be3toi = be3toi;
/**
 * Translate groups of 4 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */

function be4toi(bytes, offset) {
  return bytes[offset + 0] * 0x1000000 + bytes[offset + 1] * 0x0010000 + bytes[offset + 2] * 0x0000100 + bytes[offset + 3];
}

exports.be4toi = be4toi;
/**
 * Translate groups of 8 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */

function be8toi(bytes, offset) {
  return (bytes[offset + 0] * 0x1000000 + bytes[offset + 1] * 0x0010000 + bytes[offset + 2] * 0x0000100 + bytes[offset + 3]) * 0x100000000 + bytes[offset + 4] * 0x1000000 + bytes[offset + 5] * 0x0010000 + bytes[offset + 6] * 0x0000100 + bytes[offset + 7];
}

exports.be8toi = be8toi;
/**
 * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of
 * the corresponding big-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */

function itobe2(num) {
  return new Uint8Array([num >>> 8 & 0xFF, num & 0xFF]);
}

exports.itobe2 = itobe2;
/**
 * Translate Integer to a Uint8Array of length 4 of the corresponding big-endian
 * bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */

function itobe4(num) {
  return new Uint8Array([num >>> 24 & 0xFF, num >>> 16 & 0xFF, num >>> 8 & 0xFF, num & 0xFF]);
}

exports.itobe4 = itobe4;
/**
 * Translate Integer to a Uint8Array of length 8 of the corresponding big-endian
 * bytes.
 * /!\ If the top-most bytes are set, this might go over MAX_SAFE_INTEGER, thus
 * leading to a "bad" value.
 * @param {Number} num
 * @returns {Uint8Array}
 */

function itobe8(num) {
  var l = num % 0x100000000;
  var h = (num - l) / 0x100000000;
  return new Uint8Array([h >>> 24 & 0xFF, h >>> 16 & 0xFF, h >>> 8 & 0xFF, h & 0xFF, l >>> 24 & 0xFF, l >>> 16 & 0xFF, l >>> 8 & 0xFF, l & 0xFF]);
}

exports.itobe8 = itobe8;
/**
 * Translate groups of 2 little-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */

function le2toi(bytes, offset) {
  return (bytes[offset + 0] << 0) + (bytes[offset + 1] << 8);
}

exports.le2toi = le2toi;
/**
 * Translate groups of 4 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */

function le4toi(bytes, offset) {
  return bytes[offset + 0] + bytes[offset + 1] * 0x0000100 + bytes[offset + 2] * 0x0010000 + bytes[offset + 3] * 0x1000000;
}

exports.le4toi = le4toi;
/**
 * Translate groups of 8 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */

function le8toi(bytes, offset) {
  return bytes[offset + 0] + bytes[offset + 1] * 0x0000100 + bytes[offset + 2] * 0x0010000 + bytes[offset + 3] * 0x1000000 + (bytes[offset + 4] + bytes[offset + 5] * 0x0000100 + bytes[offset + 6] * 0x0010000 + bytes[offset + 7] * 0x1000000) * 0x100000000;
}

exports.le8toi = le8toi;
/**
 * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of
 * the corresponding little-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */

function itole2(num) {
  return new Uint8Array([num & 0xFF, num >>> 8 & 0xFF]);
}

exports.itole2 = itole2;
/**
 * Translate Integer to a Uint8Array of length 4 of the corresponding
 * little-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */

function itole4(num) {
  return new Uint8Array([num & 0xFF, num >>> 8 & 0xFF, num >>> 16 & 0xFF, num >>> 24 & 0xFF]);
}

exports.itole4 = itole4;
/**
 * @param {string} uuid
 * @returns {string}
 * @throws AssertionError - The uuid length is not 16
 */

function guidToUuid(uuid) {
  assert_1.default(uuid.length === 16, "UUID length should be 16");
  var buf = strToBytes(uuid);
  var p1A = buf[0];
  var p1B = buf[1];
  var p1C = buf[2];
  var p1D = buf[3];
  var p2A = buf[4];
  var p2B = buf[5];
  var p3A = buf[6];
  var p3B = buf[7];
  var p4 = buf.subarray(8, 10);
  var p5 = buf.subarray(10, 16);
  var ord = new Uint8Array(16);
  ord[0] = p1D;
  ord[1] = p1C;
  ord[2] = p1B;
  ord[3] = p1A; // swap32 BE -> LE

  ord[4] = p2B;
  ord[5] = p2A; // swap16 BE -> LE

  ord[6] = p3B;
  ord[7] = p3A; // swap16 BE -> LE

  ord.set(p4, 8);
  ord.set(p5, 10);
  return bytesToHex(ord);
}

exports.guidToUuid = guidToUuid;
},{"./assert":"../../../utils/assert.ts"}],"../../../parsers/containers/isobmff/create_box.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var byte_parsing_1 = require("../../../utils/byte_parsing");
/**
 * Speed up string to bytes conversion by memorizing the result
 *
 * The keys here are ISOBMFF box names. The values are the corresponding
 * bytes conversion for putting as an ISOBMFF boxes.
 *
 * Used by the boxName method.
 * @type {Object}
 */


var boxNamesMem = {};
/**
 * Convert the string name of an ISOBMFF box into the corresponding bytes.
 * Has a memorization mechanism to speed-up if you want to translate the
 * same string multiple times.
 * @param {string} str
 * @returns {Uint8Array}
 */

function boxName(str) {
  if (boxNamesMem[str]) {
    return boxNamesMem[str];
  }

  var nameInBytes = byte_parsing_1.strToBytes(str);
  boxNamesMem[str] = nameInBytes;
  return nameInBytes;
}
/**
 * Create a new ISOBMFF "box" with the given name.
 * @param {string} name - name of the box you want to create, must always
 * be 4 characters (uuid boxes not supported)
 * @param {Uint8Array} buff - content of the box
 * @returns {Uint8Array} - The entire ISOBMFF box (length+name+content)
 */


function createBox(name, buff) {
  var len = buff.length + 8;
  return byte_parsing_1.concat(byte_parsing_1.itobe4(len), boxName(name), buff);
}

exports.createBox = createBox;
/**
 * @param {string} name
 * @param {Array.<Uint8Array>} children
 * @returns {Uint8Array}
 */

function createBoxWithChildren(name, children) {
  return createBox(name, byte_parsing_1.concat.apply(byte_parsing_1, _toConsumableArray(children)));
}

exports.createBoxWithChildren = createBoxWithChildren;
},{"../../../utils/byte_parsing":"../../../utils/byte_parsing.ts"}],"../../../parsers/containers/isobmff/get_box.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var byte_parsing_1 = require("../../../utils/byte_parsing");
/**
 * Returns the content of a box based on its name.
 * `null` if not found.
 * /!\ does not work with UUID boxes
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 4-letter 'name' of the box (e.g. 'sidx' or
 * 'moov'), hexa encoded
 * @returns {UInt8Array|null}
 */


function getBoxContent(buf, boxName) {
  var offsets = getBoxOffsets(buf, boxName);
  return offsets != null ? buf.subarray(offsets[0] + 8, offsets[1]) : null;
}

exports.getBoxContent = getBoxContent;
/**
 * Returns an ISOBMFF box based on its name.
 * `null` if not found.
 * /!\ does not work with UUID boxes
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 4-letter 'name' of the box (e.g. 'sidx' or
 * 'moov'), hexa encoded
 * @returns {UInt8Array|null}
 */

function getBox(buf, boxName) {
  var offsets = getBoxOffsets(buf, boxName);
  return offsets != null ? buf.subarray(offsets[0], offsets[1]) : null;
}

exports.getBox = getBox;
/**
 * Returns start and end offset for a given box.
 * `null` if not found.
 * /!\ does not work with UUID boxes
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 4-letter 'name' of the box (e.g. 'sidx' or
 * 'moov'), hexa encoded
 * @returns {Array.<number>|null}
 */

function getBoxOffsets(buf, boxName) {
  var l = buf.length;
  var i = 0;
  var name;
  var size = 0;

  while (i + 8 < l) {
    size = byte_parsing_1.be4toi(buf, i);
    name = byte_parsing_1.be4toi(buf, i + 4);

    if (size <= 0) {
      throw new Error("ISOBMFF: Size out of range");
    }

    if (name === boxName) {
      break;
    } else {
      i += size;
    }
  }

  if (i < l) {
    return [i, i + size];
  } else {
    return null;
  }
}

exports.getBoxOffsets = getBoxOffsets;
/**
 * Gives the content of a specific UUID with its attached ID
 * @param {Uint8Array} buf
 * @param {Number} id1
 * @param {Number} id2
 * @param {Number} id3
 * @param {Number} id4
 * @returns {Uint8Array|undefined}
 */

function getUuidContent(buf, id1, id2, id3, id4) {
  var len;
  var l = buf.length;

  for (var i = 0; i < l; i += len) {
    len = byte_parsing_1.be4toi(buf, i);

    if (byte_parsing_1.be4toi(buf, i + 4) === 0x75756964
    /* === "uuid" */
    && byte_parsing_1.be4toi(buf, i + 8) === id1 && byte_parsing_1.be4toi(buf, i + 12) === id2 && byte_parsing_1.be4toi(buf, i + 16) === id3 && byte_parsing_1.be4toi(buf, i + 20) === id4) {
      return buf.subarray(i + 24, i + len);
    }
  }
}

exports.getUuidContent = getUuidContent;
},{"../../../utils/byte_parsing":"../../../utils/byte_parsing.ts"}],"../../../parsers/containers/isobmff/read.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var get_box_1 = require("./get_box");
/**
 * Returns TRAF Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */


function getTRAF(buffer) {
  var moof = get_box_1.getBoxContent(buffer, 0x6d6f6f66
  /* moof */
  );

  if (!moof) {
    return null;
  }

  return get_box_1.getBoxContent(moof, 0x74726166
  /* traf */
  );
}

exports.getTRAF = getTRAF;
/**
 * Returns MDAT Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */

function getMDAT(buf) {
  return get_box_1.getBoxContent(buf, 0x6D646174
  /* "mdat" */
  );
}

exports.getMDAT = getMDAT;
/**
 * Returns MDIA Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */

function getMDIA(buf) {
  var moov = get_box_1.getBoxContent(buf, 0x6d6f6f76
  /* moov */
  );

  if (!moov) {
    return null;
  }

  var trak = get_box_1.getBoxContent(moov, 0x7472616b
  /* "trak" */
  );

  if (!trak) {
    return null;
  }

  return get_box_1.getBoxContent(trak, 0x6d646961
  /* "mdia" */
  );
}

exports.getMDIA = getMDIA;
},{"./get_box":"../../../parsers/containers/isobmff/get_box.ts"}],"../../../utils/noop.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Do nothing (but do it well).
 *
 * Having this definition here allow to use the same reference each time a noop
 * is needed.
 * Also, it allows to avoid telling tslint to ignore empty blocks everywhere.
 */

/* tslint:disable:no-empty */

function default_1() {}

exports.default = default_1;
/* tslint:enable:no-empty */
},{}],"../../../utils/logger.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var noop_1 = __importDefault(require("./noop"));

var DEFAULT_LOG_LEVEL = "NONE";
/**
 * Logger implementation.
 * @class Logger
 */

var Logger =
/*#__PURE__*/
function () {
  function Logger() {
    _classCallCheck(this, Logger);

    this.error = noop_1.default;
    this.warn = noop_1.default;
    this.info = noop_1.default;
    this.debug = noop_1.default;
    this.LEVELS = {
      NONE: 0,
      ERROR: 1,
      WARNING: 2,
      INFO: 3,
      DEBUG: 4
    };
    this.currentLevel = DEFAULT_LOG_LEVEL;
  }
  /**
   * @param {string} levelStr
   */


  _createClass(Logger, [{
    key: "setLevel",
    value: function setLevel(levelStr) {
      var level;
      var foundLevel = this.LEVELS[levelStr];

      if (foundLevel) {
        // levelStr is a ILoggerLevel
        level = foundLevel;
        this.currentLevel = levelStr;
      } else {
        // either 0 or not found
        level = 0;
        this.currentLevel = "NONE";
      }
      /* tslint:disable no-invalid-this */

      /* tslint:disable no-console */


      this.error = level >= this.LEVELS.ERROR ? console.error.bind(console) : noop_1.default;
      this.warn = level >= this.LEVELS.WARNING ? console.warn.bind(console) : noop_1.default;
      this.info = level >= this.LEVELS.INFO ? console.info.bind(console) : noop_1.default;
      this.debug = level >= this.LEVELS.DEBUG ? console.log.bind(console) : noop_1.default;
      /* tslint:enable no-console */

      /* tslint:enable no-invalid-this */
    }
    /**
     * @returns {string}
     */

  }, {
    key: "getLevel",
    value: function getLevel() {
      return this.currentLevel;
    }
  }]);

  return Logger;
}();

exports.default = Logger;
},{"./noop":"../../../utils/noop.ts"}],"../../../log.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var logger_1 = __importDefault(require("./utils/logger")); // create a logger specifically for the RxPlayer.


var logger = new logger_1.default();
exports.default = logger;
},{"./utils/logger":"../../../utils/logger.ts"}],"../../../parsers/containers/isobmff/drm/playready.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var byte_parsing_1 = require("../../../../utils/byte_parsing");
/**
 * Parse PlayReady privateData to get its Hexa-coded KeyID.
 * @param {Uint8Array} privateData
 * @returns {string}
 */


function getPlayReadyKIDFromPrivateData(data) {
  var xmlLength = byte_parsing_1.le2toi(data, 8);
  var xml = byte_parsing_1.bytesToUTF16Str(data.subarray(10, xmlLength + 10));
  var doc = new DOMParser().parseFromString(xml, "application/xml");
  var kidElement = doc.querySelector("KID");

  if (!kidElement) {
    throw new Error("Cannot parse PlayReady private data: invalid XML");
  }

  var kid = kidElement.textContent || "";
  return byte_parsing_1.guidToUuid(atob(kid)).toLowerCase();
}

exports.getPlayReadyKIDFromPrivateData = getPlayReadyKIDFromPrivateData;
},{"../../../../utils/byte_parsing":"../../../utils/byte_parsing.ts"}],"../../../parsers/containers/isobmff/drm/index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var playready_1 = require("./playready");

exports.getPlayReadyKIDFromPrivateData = playready_1.getPlayReadyKIDFromPrivateData;
},{"./playready":"../../../parsers/containers/isobmff/drm/playready.ts"}],"../../../parsers/containers/isobmff/utils.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../../log"));

var assert_1 = __importDefault(require("../../../utils/assert"));

var byte_parsing_1 = require("../../../utils/byte_parsing");

var create_box_1 = require("./create_box");

var drm_1 = require("./drm");

exports.getPlayReadyKIDFromPrivateData = drm_1.getPlayReadyKIDFromPrivateData;

var read_1 = require("./read");
/**
 * Find the offset for the first declaration of the given box in an isobmff.
 * Returns -1 if not found.
 *
 * This function calls log.error in case of partial segments.
 * @param {Uint8Array} buf - the isobmff
 * @param {Number} wantedName
 * @returns {Number} - Offset where the box begins. -1 if not found.
 */


function findBox(buf, wantedName) {
  var len = buf.length;
  var i = 0;

  while (i + 8 < len) {
    var size = byte_parsing_1.be4toi(buf, i);

    if (size <= 0) {
      log_1.default.error("ISOBMFF: size out of range");
      return -1;
    }

    var name = byte_parsing_1.be4toi(buf, i + 4);

    if (name === wantedName) {
      if (i + size <= len) {
        return i;
      }

      log_1.default.error("ISOBMFF: box out of range");
      return -1;
    }

    i += size;
  }

  return -1;
}
/**
 * Parse the sidx part (segment index) of the isobmff.
 * Returns null if not found.
 *
 * @param {Uint8Array} buf
 * @param {Number} initialOffset
 * @returns {Object|null} {Array.<Object>} - Information about each subsegment.
 * Contains those keys:
 *   - time {Number}: starting _presentation time_ for the subsegment,
 *     timescaled
 *   - duration {Number}: duration of the subsegment, timescaled
 *   - timescale {Number}: the timescale in which the time and duration are set
 *   - count {Number}: always at 0
 *   - range {Array.<Number>}: first and last bytes in the media file
 *     from the anchor point (first byte after the sidx box) for the
 *     concerned subsegment.
 */


function getSegmentsFromSidx(buf, initialOffset) {
  var index = findBox(buf, 0x73696478
  /* "sidx" */
  );

  if (index === -1) {
    return null;
  }

  var offset = initialOffset;
  var size = byte_parsing_1.be4toi(buf, index);
  var pos = index +
  /* size */
  4 +
  /* name */
  4;
  /* version(8) */

  /* flags(24) */

  /* reference_ID(32); */

  /* timescale(32); */

  var version = buf[pos];
  pos += 4 + 4;
  var timescale = byte_parsing_1.be4toi(buf, pos);
  pos += 4;
  /* earliest_presentation_time(32 / 64) */

  /* first_offset(32 / 64) */

  var time;

  if (version === 0) {
    time = byte_parsing_1.be4toi(buf, pos);
    pos += 4;
    offset += byte_parsing_1.be4toi(buf, pos) + size;
    pos += 4;
  } else if (version === 1) {
    time = byte_parsing_1.be8toi(buf, pos);
    pos += 8;
    offset += byte_parsing_1.be8toi(buf, pos) + size;
    pos += 8;
  } else {
    return null;
  }

  var segments = [];
  /* reserved(16) */

  /* reference_count(16) */

  pos += 2;
  var count = byte_parsing_1.be2toi(buf, pos);
  pos += 2;

  while (--count >= 0) {
    /* reference_type(1) */

    /* reference_size(31) */

    /* segment_duration(32) */

    /* sap..(32) */
    var refChunk = byte_parsing_1.be4toi(buf, pos);
    pos += 4;
    var refType = (refChunk & 0x80000000) >>> 31;
    var refSize = refChunk & 0x7fffffff; // when set to 1 indicates that the reference is to a sidx, else to media

    if (refType === 1) {
      throw new Error("sidx with reference_type `1` not yet implemented");
    }

    var duration = byte_parsing_1.be4toi(buf, pos);
    pos += 4; // let sapChunk = be4toi(buf, pos + 8);

    pos += 4; // TODO(pierre): handle sap
    // let startsWithSap = (sapChunk & 0x80000000) >>> 31;
    // let sapType = (sapChunk & 0x70000000) >>> 28;
    // let sapDelta = sapChunk & 0x0FFFFFFF;

    segments.push({
      time: time,
      duration: duration,
      count: 0,
      timescale: timescale,
      range: [offset, offset + refSize - 1]
    });
    time += duration;
    offset += refSize;
  }

  return segments;
}

exports.getSegmentsFromSidx = getSegmentsFromSidx;
/**
 * Parse track Fragment Decode Time to get a precize initial time for this
 * segment (in the media timescale).
 * Stops at the first tfdt encountered from the beginning of the file.
 * Returns this time. -1 if not found.
 * @param {Uint8Array} buffer
 * @returns {Number}
 */

function getTrackFragmentDecodeTime(buffer) {
  var traf = read_1.getTRAF(buffer);

  if (!traf) {
    return -1;
  }

  var index = findBox(traf, 0x74666474
  /* tfdt */
  );

  if (index === -1) {
    return -1;
  }

  var pos = index +
  /* size */
  4 +
  /* name */
  4;
  var version = traf[pos];
  pos += 4;

  if (version > 1) {
    return -1;
  }

  return version ? byte_parsing_1.be8toi(traf, pos) : byte_parsing_1.be4toi(traf, pos);
}

exports.getTrackFragmentDecodeTime = getTrackFragmentDecodeTime;
/**
 * @param {Uint8Array} traf
 * @returns {number}
 */

function getDefaultDurationFromTFHDInTRAF(traf) {
  var index = findBox(traf, 0x74666864
  /* tfhd */
  );

  if (index === -1) {
    return -1;
  }

  var pos = index +
  /* size */
  4 +
  /* name */
  4 +
  /* version */
  1;
  var flags = byte_parsing_1.be3toi(traf, pos);
  pos += 3;
  var hasBaseDataOffset = flags & 0x000001;
  var hasSampleDescriptionIndex = flags & 0x000002;
  var hasDefaultSampleDuration = flags & 0x000008;

  if (!hasDefaultSampleDuration) {
    return -1;
  }

  pos += 4;

  if (hasBaseDataOffset) {
    pos += 8;
  }

  if (hasSampleDescriptionIndex) {
    pos += 4;
  }

  var defaultDuration = byte_parsing_1.be4toi(traf, pos);
  return defaultDuration;
}
/**
 * @param {Uint8Array} buffer
 * @returns {number}
 */


function getDurationFromTrun(buffer) {
  var traf = read_1.getTRAF(buffer);

  if (!traf) {
    return -1;
  }

  var index = findBox(traf, 0x7472756e
  /* trun */
  );

  if (index === -1) {
    return -1;
  }

  var pos = index +
  /* size */
  4 +
  /* name */
  4;
  var version = traf[pos];
  pos += 1;

  if (version > 1) {
    return -1;
  }

  var flags = byte_parsing_1.be3toi(traf, pos);
  pos += 3;
  var hasSampleDuration = flags & 0x000100;
  var defaultDuration = 0;

  if (!hasSampleDuration) {
    defaultDuration = getDefaultDurationFromTFHDInTRAF(traf);

    if (defaultDuration < 0) {
      return -1;
    }
  }

  var hasDataOffset = flags & 0x000001;
  var hasFirstSampleFlags = flags & 0x000004;
  var hasSampleSize = flags & 0x000200;
  var hasSampleFlags = flags & 0x000400;
  var hasSampleCompositionOffset = flags & 0x000800;
  var sampleCounts = byte_parsing_1.be4toi(traf, pos);
  pos += 4;

  if (hasDataOffset) {
    pos += 4;
  }

  if (hasFirstSampleFlags) {
    pos += 4;
  }

  var i = sampleCounts;
  var duration = 0;

  while (i--) {
    if (hasSampleDuration) {
      duration += byte_parsing_1.be4toi(traf, pos);
      pos += 4;
    } else {
      duration += defaultDuration;
    }

    if (hasSampleSize) {
      pos += 4;
    }

    if (hasSampleFlags) {
      pos += 4;
    }

    if (hasSampleCompositionOffset) {
      pos += 4;
    }
  }

  return duration;
}

exports.getDurationFromTrun = getDurationFromTrun;
/**
 * Get various information from a movie header box. Found in init segments.
 * null if not found or not parsed.
 *
 * This timescale is the default timescale used for segments.
 * @param {Uint8Array} buffer
 * @returns {Number}
 */

function getMDHDTimescale(buffer) {
  var mdia = read_1.getMDIA(buffer);

  if (!mdia) {
    return -1;
  }

  var index = findBox(mdia, 0x6d646864
  /* "mdhd" */
  );

  if (index === -1) {
    return -1;
  }

  var pos = index +
  /* size */
  4 +
  /* name */
  4;
  var version = mdia[pos];
  pos += 4;

  if (version === 1) {
    pos += 16;
    return byte_parsing_1.be4toi(mdia, pos);
  } else if (version === 0) {
    pos += 8;
    return byte_parsing_1.be4toi(mdia, pos);
  } else {
    return -1;
  }
}

exports.getMDHDTimescale = getMDHDTimescale;
/**
 * Returns a PSSH box from a systemId and private data.
 * @param {Array.<Object>} pssList - The content protections under the form of
 * object containing two properties:
 *   - systemId {string}: The uuid code. Should only contain 32 hexadecimal
 *     numbers and hyphens
 *   - privateData {Uint8Array} private data associated.
 * @returns {Uint8Array}
 */

function createPssh(_ref) {
  var systemId = _ref.systemId,
      privateData = _ref.privateData;

  var _systemId = systemId.replace(/-/g, "");

  assert_1.default(_systemId.length === 32);
  return create_box_1.createBox("pssh", byte_parsing_1.concat(4, // 4 initial zeroed bytes
  byte_parsing_1.hexToBytes(_systemId), byte_parsing_1.itobe4(privateData.length), privateData));
}
/**
 * Update ISOBMFF given to add a "pssh" box in the "moov" box for every content
 * protection in the pssList array given.
 * @param {Uint8Array} buf - the ISOBMFF file
 * @param {Array.<Object>} pssList - The content protections under the form of
 * objects containing two properties:
 *   - systemId {string}: The uuid code. Should only contain 32 hexadecimal
 *     numbers and hyphens
 *   - privateData {Uint8Array} private data associated.
 * @returns {Uint8Array} - The new ISOBMFF generated.
 */


function patchPssh(buf, pssList) {
  if (!pssList || !pssList.length) {
    return buf;
  }

  var pos = findBox(buf, 0x6d6f6f76
  /* = "moov" */
  );

  if (pos === -1) {
    return buf;
  }

  var size = byte_parsing_1.be4toi(buf, pos); // size of the "moov" box

  var moov = buf.subarray(pos, pos + size);
  var moovArr = [moov];

  for (var i = 0; i < pssList.length; i++) {
    moovArr.push(createPssh(pssList[i]));
  }

  var newmoov = byte_parsing_1.concat.apply(byte_parsing_1, moovArr);
  newmoov.set(byte_parsing_1.itobe4(newmoov.length), 0); // overwrite "moov" length

  return byte_parsing_1.concat(buf.subarray(0, pos), newmoov, buf.subarray(pos + size));
}

exports.patchPssh = patchPssh;
},{"../../../log":"../../../log.ts","../../../utils/assert":"../../../utils/assert.ts","../../../utils/byte_parsing":"../../../utils/byte_parsing.ts","./create_box":"../../../parsers/containers/isobmff/create_box.ts","./drm":"../../../parsers/containers/isobmff/drm/index.ts","./read":"../../../parsers/containers/isobmff/read.ts"}],"../../../parsers/containers/isobmff/index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var create_box_1 = require("./create_box");

exports.createBox = create_box_1.createBox;
exports.createBoxWithChildren = create_box_1.createBoxWithChildren;

var get_box_1 = require("./get_box");

exports.getBox = get_box_1.getBox;
exports.getBoxContent = get_box_1.getBoxContent;
exports.getBoxOffsets = get_box_1.getBoxOffsets;
exports.getUuidContent = get_box_1.getUuidContent;

var read_1 = require("./read");

exports.getMDAT = read_1.getMDAT;
exports.getMDIA = read_1.getMDIA;
exports.getTRAF = read_1.getTRAF;

var utils_1 = require("./utils");

exports.getMDHDTimescale = utils_1.getMDHDTimescale;
exports.getPlayReadyKIDFromPrivateData = utils_1.getPlayReadyKIDFromPrivateData;
exports.getTrackFragmentDecodeTime = utils_1.getTrackFragmentDecodeTime;
exports.getDurationFromTrun = utils_1.getDurationFromTrun;
exports.getSegmentsFromSidx = utils_1.getSegmentsFromSidx;
exports.ISidxSegment = utils_1.ISidxSegment;
exports.patchPssh = utils_1.patchPssh;
},{"./create_box":"../../../parsers/containers/isobmff/create_box.ts","./get_box":"../../../parsers/containers/isobmff/get_box.ts","./read":"../../../parsers/containers/isobmff/read.ts","./utils":"../../../parsers/containers/isobmff/utils.ts"}],"../../../utils/array_find_index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Array.prototype.find ponyfill.
 * @param {Array} arr
 * @param {Function} predicate
 * @param {*} context
 * @returns {boolean}
 */

function arrayFindIndex(arr, predicate, thisArg) {
  if (typeof Array.prototype.findIndex === "function") {
    /* tslint:disable ban */
    return arr.findIndex(predicate, thisArg);
    /* tslint:enable ban */
  }

  var len = arr.length >>> 0;

  for (var i = 0; i < len; i++) {
    if (predicate.call(thisArg, arr[i], i, arr)) {
      return i;
    }
  }

  return -1;
}

exports.default = arrayFindIndex;
},{}],"../../../../node_modules/pinkie/index.js":[function(require,module,exports) {
var global = arguments[3];
'use strict';

var PENDING = 'pending';
var SETTLED = 'settled';
var FULFILLED = 'fulfilled';
var REJECTED = 'rejected';

var NOOP = function () {};

var isNode = typeof global !== 'undefined' && typeof global.process !== 'undefined' && typeof global.process.emit === 'function';
var asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;
var asyncQueue = [];
var asyncTimer;

function asyncFlush() {
  // run promise callbacks
  for (var i = 0; i < asyncQueue.length; i++) {
    asyncQueue[i][0](asyncQueue[i][1]);
  } // reset async asyncQueue


  asyncQueue = [];
  asyncTimer = false;
}

function asyncCall(callback, arg) {
  asyncQueue.push([callback, arg]);

  if (!asyncTimer) {
    asyncTimer = true;
    asyncSetTimer(asyncFlush, 0);
  }
}

function invokeResolver(resolver, promise) {
  function resolvePromise(value) {
    resolve(promise, value);
  }

  function rejectPromise(reason) {
    reject(promise, reason);
  }

  try {
    resolver(resolvePromise, rejectPromise);
  } catch (e) {
    rejectPromise(e);
  }
}

function invokeCallback(subscriber) {
  var owner = subscriber.owner;
  var settled = owner._state;
  var value = owner._data;
  var callback = subscriber[settled];
  var promise = subscriber.then;

  if (typeof callback === 'function') {
    settled = FULFILLED;

    try {
      value = callback(value);
    } catch (e) {
      reject(promise, e);
    }
  }

  if (!handleThenable(promise, value)) {
    if (settled === FULFILLED) {
      resolve(promise, value);
    }

    if (settled === REJECTED) {
      reject(promise, value);
    }
  }
}

function handleThenable(promise, value) {
  var resolved;

  try {
    if (promise === value) {
      throw new TypeError('A promises callback cannot return that same promise.');
    }

    if (value && (typeof value === 'function' || typeof value === 'object')) {
      // then should be retrieved only once
      var then = value.then;

      if (typeof then === 'function') {
        then.call(value, function (val) {
          if (!resolved) {
            resolved = true;

            if (value === val) {
              fulfill(promise, val);
            } else {
              resolve(promise, val);
            }
          }
        }, function (reason) {
          if (!resolved) {
            resolved = true;
            reject(promise, reason);
          }
        });
        return true;
      }
    }
  } catch (e) {
    if (!resolved) {
      reject(promise, e);
    }

    return true;
  }

  return false;
}

function resolve(promise, value) {
  if (promise === value || !handleThenable(promise, value)) {
    fulfill(promise, value);
  }
}

function fulfill(promise, value) {
  if (promise._state === PENDING) {
    promise._state = SETTLED;
    promise._data = value;
    asyncCall(publishFulfillment, promise);
  }
}

function reject(promise, reason) {
  if (promise._state === PENDING) {
    promise._state = SETTLED;
    promise._data = reason;
    asyncCall(publishRejection, promise);
  }
}

function publish(promise) {
  promise._then = promise._then.forEach(invokeCallback);
}

function publishFulfillment(promise) {
  promise._state = FULFILLED;
  publish(promise);
}

function publishRejection(promise) {
  promise._state = REJECTED;
  publish(promise);

  if (!promise._handled && isNode) {
    global.process.emit('unhandledRejection', promise._data, promise);
  }
}

function notifyRejectionHandled(promise) {
  global.process.emit('rejectionHandled', promise);
}
/**
 * @class
 */


function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('Promise resolver ' + resolver + ' is not a function');
  }

  if (this instanceof Promise === false) {
    throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
  }

  this._then = [];
  invokeResolver(resolver, this);
}

Promise.prototype = {
  constructor: Promise,
  _state: PENDING,
  _then: null,
  _data: undefined,
  _handled: false,
  then: function (onFulfillment, onRejection) {
    var subscriber = {
      owner: this,
      then: new this.constructor(NOOP),
      fulfilled: onFulfillment,
      rejected: onRejection
    };

    if ((onRejection || onFulfillment) && !this._handled) {
      this._handled = true;

      if (this._state === REJECTED && isNode) {
        asyncCall(notifyRejectionHandled, this);
      }
    }

    if (this._state === FULFILLED || this._state === REJECTED) {
      // already resolved, call callback async
      asyncCall(invokeCallback, subscriber);
    } else {
      // subscribe
      this._then.push(subscriber);
    }

    return subscriber.then;
  },
  catch: function (onRejection) {
    return this.then(null, onRejection);
  }
};

Promise.all = function (promises) {
  if (!Array.isArray(promises)) {
    throw new TypeError('You must pass an array to Promise.all().');
  }

  return new Promise(function (resolve, reject) {
    var results = [];
    var remaining = 0;

    function resolver(index) {
      remaining++;
      return function (value) {
        results[index] = value;

        if (! --remaining) {
          resolve(results);
        }
      };
    }

    for (var i = 0, promise; i < promises.length; i++) {
      promise = promises[i];

      if (promise && typeof promise.then === 'function') {
        promise.then(resolver(i), reject);
      } else {
        results[i] = promise;
      }
    }

    if (!remaining) {
      resolve(results);
    }
  });
};

Promise.race = function (promises) {
  if (!Array.isArray(promises)) {
    throw new TypeError('You must pass an array to Promise.race().');
  }

  return new Promise(function (resolve, reject) {
    for (var i = 0, promise; i < promises.length; i++) {
      promise = promises[i];

      if (promise && typeof promise.then === 'function') {
        promise.then(resolve, reject);
      } else {
        resolve(promise);
      }
    }
  });
};

Promise.resolve = function (value) {
  if (value && typeof value === 'object' && value.constructor === Promise) {
    return value;
  }

  return new Promise(function (resolve) {
    resolve(value);
  });
};

Promise.reject = function (reason) {
  return new Promise(function (resolve, reject) {
    reject(reason);
  });
};

module.exports = Promise;
},{}],"../../../utils/promise.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var pinkie_1 = __importDefault(require("pinkie"));

exports.default = typeof Promise === "function" ? Promise : pinkie_1.default;
},{"pinkie":"../../../../node_modules/pinkie/index.js"}],"../../../config.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Configuration file for the whole player.
 * Feel free to tweak those values if you know what you're doing.
 *
 * Please not that you will need to re-build the whole project to take these
 * modifications into account.
 *
 * @type {Object}
 */

exports.default = {
  /**
   * Volume set on unMute if the volume is set to 0 and either:
   *   - mute has never been called before
   *   - mute has last been called while the volume was already set to 0 (either
   *     via setVolume, or a previous mute call)
   * @type {Number}
   */
  DEFAULT_UNMUTED_VOLUME: 0.1,

  /**
   * Default time interval after which a request will timeout, in ms.
   * @type {Number}
   */
  DEFAULT_REQUEST_TIMEOUT: 30 * 1000,

  /**
   * Can be either:
   *   - "native": Subtitles are all displayed in a <track> element
   *   - "html": Subtitles are all displayed in a <div> separated from the video
   *     element. Can be useful to display richer TTML subtitles, for example.
   * @type {Object|null}
   */
  DEFAULT_TEXT_TRACK_MODE: "native",

  /**
   * Strategy to adopt when manually setting the current bitrate.
   * Can be either:
   *   - "seamless": transitions are very smooth but not immediate.
   *   - "direct": the quality switch happens immediately but to achieve that,
   *     the player will need to set a new MediaSource on the media element in
   *     some cases. This often leads to a black screen + unavailable APIs
   *     during a short moment.
   * @type {string}
   */
  DEFAULT_MANUAL_BITRATE_SWITCHING_MODE: "seamless",

  /**
   * If set to true, video through loadVideo will auto play by default
   * @type {Boolean}
   */
  DEFAULT_AUTO_PLAY: false,

  /**
   * If set to false, "native" subtitles (in a <track> element) will be hidden
   * by default.
   * @type {Boolean}
   */
  DEFAULT_SHOW_NATIVE_SUBTITLE: true,

  /**
   * If set to true, the player will by default stop immediately and unload the
   * content on reaching the end of the media.
   *
   * If set to false, it will not unload nor stop by default, leaving the user
   * free to seek in the already-loaded content.
   *
   * Set to `true` for legacy reasons.
   * @type {Boolean}
   */
  DEFAULT_STOP_AT_END: true,

  /**
   * Default buffer goal in seconds.
   * Once enough content has been downloaded to fill the buffer up to
   * ``current position + DEFAULT_WANTED_BUFFER_AHEAD", we will stop downloading
   * content.
   * @type {Number}
   */
  DEFAULT_WANTED_BUFFER_AHEAD: 30,

  /**
   * Default max buffer size ahead of the current position in seconds.
   * The buffer _after_ this limit will be garbage collected.
   * Set to Infinity for no limit.
   * @type {Number}
   */
  DEFAULT_MAX_BUFFER_AHEAD: Infinity,

  /**
   * Default max buffer size ahead of the current position in seconds.
   * The buffer _before_ this limit will be garbage collected.
   * Set to Infinity for no limit.
   * @type {Number}
   */
  DEFAULT_MAX_BUFFER_BEHIND: Infinity,

  /* tslint:disable no-object-literal-type-assertion */

  /**
   * Maximum possible buffer ahead for each type of buffer, to avoid too much
   * memory usage when playing for a long time.
   * Equal to Infinity if not defined here.
   * @type {Object}
   */
  MAXIMUM_MAX_BUFFER_AHEAD: {
    text: 5 * 60 * 60
  },

  /* tslint:enable no-object-literal-type-assertion */

  /* tslint:disable no-object-literal-type-assertion */

  /**
   * Maximum possible buffer behind for each type of buffer, to avoid too much
   * memory usage when playing for a long time.
   * Equal to Infinity if not defined here.
   * @type {Object}
   */
  MAXIMUM_MAX_BUFFER_BEHIND: {
    text: 5 * 60 * 60
  },

  /* tslint:enable no-object-literal-type-assertion */

  /**
   * Default bitrate ceils initially set as the first content begins.
   *
   * If no track is found with a bitrate inferior or equal to the
   * bitrate there, the one with the lowest bitrate will be taken instead.
   *
   * Set to 0 for the lowest bitrate, Infinity for the highest.
   *
   * These values are only useful for the first content played, as consecutive
   * play will always take the last set one.
   * @type {Object}
   */
  DEFAULT_INITIAL_BITRATES: {
    audio: 0,
    video: 0,
    other: 0
  },

  /* tslint:disable no-object-literal-type-assertion */

  /**
   * Default bitrate ceil initially set to dictate the maximum bitrate the
   * ABR manager can automatically switch to.
   *
   * If no track is found with a quality inferior or equal to the
   * bitrate there, the lowest bitrate will be taken instead.
   *
   * Set to Infinity to discard any limit in the ABR strategy.
   * @type {Object}
   */
  DEFAULT_MAX_BITRATES: {
    audio: Infinity,
    video: Infinity,
    other: Infinity
  },

  /* tslint:enable no-object-literal-type-assertion */

  /**
   * Delay after which, if the page is hidden, the user is considered inactive
   * on the current video.
   *
   * Allow to enforce specific optimizations when the page is not shown.
   * @see DEFAULT_THROTTLE_WHEN_HIDDEN
   * @type {Number}
   */
  INACTIVITY_DELAY: 60 * 1000,

  /**
   * If true, if the player is in a "hidden" state for a delay specified by the
   * INACTIVITY DELAY config property, we throttle automatically to the video
   * representation with the lowest bitrate.
   * @type {Boolean}
   */
  DEFAULT_THROTTLE_WHEN_HIDDEN: false,

  /**
   * If true, if the video is considered in a "hidden" state for a delay specified by
   * the INACTIVITY DELAY config property, we throttle automatically to the video
   * representation with the lowest bitrate.
   * @type {Boolean}
   */
  DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN: false,

  /**
   * If true, the video representations you can switch to in adaptive mode
   * are limited by the video element's width.
   *
   * Basically in that case, we won't switch to a video Representation with
   * a width higher than the current width of the video HTMLElement.
   * @type {Boolean}
   */
  DEFAULT_LIMIT_VIDEO_WIDTH: false,

  /**
   * Default initial live gap considered if no presentation delay has been
   * suggested, in seconds.
   * @type {Number}
   */
  DEFAULT_LIVE_GAP: {
    DEFAULT: 10,
    LOW_LATENCY: 3
  },

  /**
   * Maximum time, in seconds, the player should automatically skip when stalled
   * because of a discontinuity in the downloaded range.
   * @type {Number}
   */
  BUFFER_DISCONTINUITY_THRESHOLD: 1,

  /**
   * Ratio used to know if an already loaded segment should be re-buffered.
   * We re-load the given segment if the current one times that ratio is
   * inferior to the new one.
   * @type {Number}
   */
  BITRATE_REBUFFERING_RATIO: 1.5,

  /**
   * Those are used when a "QuotaExceededError" error is received after
   * appending a new segment in the SourceBuffer.
   *
   * This error can arise when the browser's buffer is considered full.
   * In this case, the player goes into manual garbage collection (GC) mode.
   * @type {Object}
   */
  BUFFER_GC_GAPS: {
    /**
     * _Low_ gap (from current position) from which the buffer will be _garbage
     * collected_ (read removed from the buffer) when a QuotaExceededError is
     * received.
     * In seconds.
     * @type {Number}
     */
    CALM: 240,

    /**
     * _High_ gap (from current position) from which the buffer will be _garbage
     * collected_ (read removed from the buffer) when a QuotaExceededError is
     * received, if the low one does not clean up any buffer.
     * In seconds.
     * @type {Number}
     */
    BEEFY: 30
  },

  /**
   * The default number of times a manifest request will be re-performed
   * when loaded/refreshed if the request finishes on an error which
   * justify an retry.
   *
   * Note that some errors do not use this counter:
   *   - if the error is not due to the xhr, no retry will be peformed
   *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
   *     retry will be performed.
   *   - if it has a high chance of being due to the user being offline, a
   *     separate counter is used (see DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE).
   * @type Number
   */
  DEFAULT_MAX_MANIFEST_REQUEST_RETRY: 4,

  /**
   * The default number of times a pipeline request will be re-performed when
   * on error which justify a retry.
   *
   * Note that some errors do not use this counter:
   *   - if the error is not due to the xhr, no retry will be peformed
   *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
   *     retry will be performed.
   *   - if it has a high chance of being due to the user being offline, a
   *     separate counter is used (see DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE).
   * @type Number
   */
  DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR: 4,

  /**
   * Under some circonstances, we're able to tell that the user is offline (see
   * the compat files).
   * When this happens, and xhr requests fails due to an error event (you might
   * still be able to perform xhr offline, e.g. on localhost), you might want to
   * retry indefinitely or with a higher number of retry than if the error is
   * due to a CDN problem.
   *
   * A capped exponential backoff will still be used (like for an error code).
   * @type {Number}
   */
  DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE: Infinity,

  /**
   * Initial backoff delay when a segment / manifest download fails, in
   * milliseconds.
   *
   * This delay will then grow exponentally by power of twos (200, 400, 800
   * etc.)
   *
   * Please note that this delay is not exact, as it will be fuzzed.
   * @type {Number}
   */
  INITIAL_BACKOFF_DELAY_BASE: {
    REGULAR: 200,
    LOW_LATENCY: 50
  },

  /**
   * Maximum backoff delay when a segment / manifest download fails, in
   * milliseconds.
   *
   * Please note that this delay is not exact, as it will be fuzzed.
   * @type {Number}
   */
  MAX_BACKOFF_DELAY_BASE: {
    REGULAR: 3000,
    LOW_LATENCY: 1000
  },

  /**
   * Minimum interval at which timeupdate events will be "constructed". This
   * variable is for the "regular" mediasource strategy (that is, not for the
   * directfile API.
   *
   * Those events are the base of various important mechanisms in the player:
   *   - set the clock for the buffer.
   *   - set the clock for the ABR strategy.
   *   - used to trigger positionUpdate events.
   *
   * This common logic is for performance reasons, as we call multiple browser's
   * APIs which are useful for most of these.
   *
   * Keep in mind this is the minimum interval. This logic will also be
   * triggered when various events of the media element are received.
   * @type {Number}
   */
  SAMPLING_INTERVAL_MEDIASOURCE: 1000,

  /**
   * Same than SAMPLING_INTERVAL_MEDIASOURCE but for lowLatency mode.
   * @type {Number}
   */
  SAMPLING_INTERVAL_LOW_LATENCY: 250,

  /**
   * Same than SAMPLING_INTERVAL_MEDIASOURCE but for the directfile API.
   * @type {Number}
   */
  SAMPLING_INTERVAL_NO_MEDIASOURCE: 500,

  /**
   * Minimum number of bytes sampled before we trust the estimate.
   * If we have not sampled much data, our estimate may not be accurate
   * enough to trust.
   * If the total of bytes sampled is less than this value, we use a
   * default estimate.
   * This specific value is based on experimentations.
   * @type {Number}
   */
  ABR_MINIMUM_TOTAL_BYTES: 150e3,

  /**
   * Minimum number of bytes, under which samples are discarded.
   * Our models do not include latency information, so connection startup time
   * (time to first byte) is considered part of the download time.
   * Because of this, we should ignore very small downloads which would cause
   * our estimate to be too low.
   * This specific value is based on experimentation.
   * @type {Number}
   */
  ABR_MINIMUM_CHUNK_SIZE: 16e3,

  /**
   * Factor with which is multiplied the bandwidth estimate when the ABR is in
   * starvation mode.
   * @type {Object}
   */
  ABR_STARVATION_FACTOR: {
    DEFAULT: 0.72,
    LOW_LATENCY: 0.64
  },

  /**
   * Factor with which is multiplied the bandwidth estimate when the ABR is not
   * in starvation mode.
   * @type {Object}
   */
  ABR_REGULAR_FACTOR: {
    DEFAULT: 0.90,
    LOW_LATENCY: 0.90
  },

  /**
   * If a SourceBuffer has less than ABR_STARVATION_GAP in seconds ahead of the
   * current position in its buffer, the ABR manager will go into starvation
   * mode.
   *
   * It gets out of starvation mode when the OUT_OF_STARVATION_GAP value is
   * reached.
   *
   * Under this starvation mode:
   *
   *   - the bandwidth considered will be a little lower than the one estimated
   *
   *   - the time the next important request take will be checked
   *     multiple times to detect when/if it takes too much time.
   *     If the request is considered too long, the bitrate will be hastily
   *     re-calculated from this single request.
   *
   * @type {Object}
   */
  ABR_STARVATION_GAP: {
    DEFAULT: 5,
    LOW_LATENCY: 5
  },
  OUT_OF_STARVATION_GAP: {
    DEFAULT: 7,
    LOW_LATENCY: 7
  },

  /**
   * This is a security to avoid going into starvation mode when the content is
   * ending (@see ABR_STARVATION_GAP).
   * Basically, we subtract that value from the global duration of the content
   * and we never enter "starvation mode" if the currently available buffer
   * (which equals to the current position + the available buffer ahead of it)
   * is equal or higher than this value.
   * @type {Number}
   */
  ABR_STARVATION_DURATION_DELTA: 0.1,

  /**
   * Half-life, in seconds for a fastly-evolving exponential weighted moving
   * average.
   * The lower it is, the faster the ABR logic will react to the bandwidth
   * falling quickly.
   * Should be kept to a lower number than ABR_SLOW_EMA for coherency reasons.
   * @type {Number}
   */
  ABR_FAST_EMA: 2,

  /**
   * Half-life, in seconds for a slowly-evolving exponential weighted moving
   * average.
   * The lower it is, the faster the ABR logic is going to react to recent
   * bandwidth variation, on the higher and on the lower side.
   * Should be kept to a higher number than ABR_FAST_EMA for coherency reasons.
   * @type {Number}
   */
  ABR_SLOW_EMA: 10,

  /**
   * Number of seconds ahead in the buffer after which playback will resume when
   * seeking on an unbuffered part of the content.
   * @type {Number}
   */
  RESUME_GAP_AFTER_SEEKING: {
    DEFAULT: 1.5,
    LOW_LATENCY: 0.5
  },

  /**
   * Number of seconds ahead in the buffer after which playback will resume when
   * the player was stalled due to a low readyState.
   * @type {Number}
   */
  RESUME_GAP_AFTER_NOT_ENOUGH_DATA: {
    DEFAULT: 0.5,
    LOW_LATENCY: 0.5
  },

  /**
   * Number of seconds ahead in the buffer after which playback will resume
   * after the player went through a buffering step.
   * @type {Number}
   */
  RESUME_GAP_AFTER_BUFFERING: {
    DEFAULT: 5,
    LOW_LATENCY: 0.5
  },

  /**
   * Maximum number of seconds in the buffer based on which a "stalling"
   * strategy will be considered:
   * The player will pause playback to get enough time building a sufficient
   * buffer. This mostly happen when seeking in an unbuffered part or when
   * buffering.
   * @type {Number}
   */
  STALL_GAP: {
    DEFAULT: 0.5,
    LOW_LATENCY: 0.2
  },

  /**
   * Maximum authorized difference between what we calculated to be the
   * beginning or end of the segment in the SourceBuffer and what we
   * actually are noticing now.
   *
   * If the segment seems to have removed more than this size in seconds, we
   * will infer that the segment has been garbage collected and we might try to
   * re-download it.
   * @type {Number}
   */
  MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT: 0.15,

  /**
   * The maximum authorized difference, in seconds, between the real buffered
   * time of a given chunk and what the segment information of the Manifest
   * tells us.
   *
   * Setting a value too high can lead to parts of the SourceBuffer being
   * linked to the wrong segments and to segments wrongly believed to be still
   * complete (instead of garbage collected).
   *
   * Setting a value too low can lead to parts of the SourceBuffer not being
   * linked to the concerned segment and to segments wrongly believed to be
   * partly garbage collected (instead of complete segments).
   * @type {Number}
   */
  MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE: 0.4,

  /**
   * The maximum authorized difference, in seconds, between the duration a
   * segment should have according to the Manifest and the actual duration it
   * seems to have once pushed to the SourceBuffer.
   *
   * Setting a value too high can lead to parts of the SourceBuffer being
   * linked to the wrong segments and to segments wrongly believed to be still
   * complete (instead of garbage collected).
   *
   * Setting a value too low can lead to parts of the SourceBuffer not being
   * linked to the concerned segment and to segments wrongly believed to be
   * partly garbage collected (instead of complete segments). This last point
   * could lead to unnecessary segment re-downloading.
   * @type {Number}
   */
  MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE: 0.3,

  /**
   * Minimum duration in seconds a segment should be into a buffered range to be
   * considered as part of that range.
   * Segments which have less than this amount of time "linked" to a buffered
   * range will be deleted.
   *
   * Setting a value too low can lead in worst-case scenarios to segments being
   * wrongly linked to the next or previous range it is truly linked too (if
   * those ranges are too close).
   *
   * Setting a value too high can lead to part of the buffer not being assigned
   * any segment. It also limits the minimum duration a segment can be.
   *
   * TODO As of now, this limits the minimum size a complete segment can be. A
   * better logic would be to also consider the duration of a segment. Though
   * this logic could lead to bugs with the current code.
   * @type {Number}
   */
  MINIMUM_SEGMENT_SIZE: 0.005,

  /**
   * Append windows allow to filter media data from segments if they are outside
   * a given limit.
   * Coded frames with presentation timestamp within this range are allowed to
   * be appended to the SourceBuffer while coded frames outside this range are
   * filtered out.
   *
   * Those are often set to be the start and end of the "Period" the segment is
   * in.
   * However, we noticed that some browsers were too aggressive when the exact
   * limits were set: more data than needed was removed, often leading to
   * discontinuities.
   *
   * Those securities are added to the set windows (substracted from the window
   * start and added to the window end) to avoid those problems.
   * @type {Object}
   */
  APPEND_WINDOW_SECURITIES: {
    START: 0.2,
    END: 0.1
  },

  /**
   * Maximum interval at which text tracks are refreshed in an "html"
   * textTrackMode.
   *
   * The text tracks are also refreshed on various video events, this interval
   * will only trigger a refresh if none of those events was received during
   * that timespan.
   *
   * Note that if the TextTrack cue did not change between two intervals or
   * events, the DOM won't be refreshed.
   * The TextTrack cues structure is also optimized for fast retrieval.
   * We should thus not have much of a performance impact here if we set a low
   * interval.
   *
   * @type {Number}
   */
  MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL: 50,

  /**
   * The Buffer padding is a time offset from the current time that affects
   * the buffer.
   *
   * Basically, from a given time, if the current buffer gap number (time
   * between the current time and the end of the downloaded buffer) is above
   * the padding described here (of the corresponding type), we won't
   * reschedule segments for that range.
   *
   * This is to avoid excessive re-buffering.
   *
   * Keeping the padding too low would increase the risk of re-bufferings.
   *
   * Keeping the padding too high would delay visible quality increase.
   *
   * @type {Object}
   */
  BUFFER_PADDING: {
    audio: 1,
    video: 3,
    other: 1
  },

  /**
   * Segments of different types are downloaded by steps:
   *
   *   - first the audio/video/text Segments which are immediately needed
   *
   *   - then once every of those Segments have been downloaded, less-needed
   *     Segments
   *
   *   - then once every of those less-needed Segments have been downloaded,
   *     even less-needed Segments
   *
   *   - etc.
   *
   * This stepped download strategy allows to make a better use of network
   * ressources.
   *
   * For example, if more than sufficient audio buffer has been downloaded but
   * the immediately-needed video Segment is still pending its request, we might
   * be in a situation of rebuffering.
   * In that case, a better strategy would be to make sure every network
   * ressource is allocated for this video Segment before rebuffering happens.
   *
   * This is where those steps become useful.
   *
   * --
   *
   * The numbers defined in this Array describe what the steps are.
   *
   * Each number is linked to a distance from the current playing position, in
   * seconds.
   * Distances which will be used as limit points, from which a new step is
   * reached (see example).
   *
   * Note: You can set an empty array to deactivate the steps feature (every
   * Segments have the same priority).
   *
   * @example
   *
   * let's imagine the following SEGMENT_PRIORITIES_STEPS array:
   * [5, 11, 17, 25]
   *
   * To link each Segments to a corresponding priority (and thus to a specific
   * step), we have to consider the distance d between the current position and
   * the start time of the Segment.
   *
   * We have in our example 5 groups, which correspond to the following possible
   * d values:
   *   1. inferior to 5
   *   2. between 5 and 11
   *   3. between 11 and 17
   *   4. between 17 and 25
   *   5. superior to 25
   *
   * Segments corresponding to a lower-step will need to all be downloaded
   * before Segments of a newer step begin.
   *
   * @type {Array.<Number>}
   */
  SEGMENT_PRIORITIES_STEPS: [6, 14],

  /**
   * Robustnesses used in the {audio,video}Capabilities of the
   * MediaKeySystemConfiguration (EME).
   *
   * Only used for widevine keysystems.
   *
   * Defined in order of importance (first will be tested first etc.)
   * @type {Array.<string>}
   */
  EME_DEFAULT_WIDEVINE_ROBUSTNESSES: ["HW_SECURE_ALL", "HW_SECURE_DECODE", "HW_SECURE_CRYPTO", "SW_SECURE_DECODE", "SW_SECURE_CRYPTO"],

  /**
   * Link canonical key systems names to their respective reverse domain name,
   * used in the EME APIs.
   * This allows to have a simpler API, where users just need to set "widevine"
   * or "playready" as a keySystem.
   * @type {Object}
   */

  /* tslint:disable no-object-literal-type-assertion */
  EME_KEY_SYSTEMS: {
    clearkey: ["webkit-org.w3.clearkey", "org.w3.clearkey"],
    widevine: ["com.widevine.alpha"],
    playready: ["com.microsoft.playready", "com.chromecast.playready", "com.youtube.playready"]
  },

  /* tslint:enable no-object-literal-type-assertion */

  /**
   * When we detect that the local Manifest might be out-of-sync with the
   * server's one, we schedule a Manifest refresh.
   * However, as this "unsynchronization" is only a theory and as we do not want
   * to send too many Manifest requests, we keep a delay between the last
   * Manifest refresh done and that one.
   * This value indicates which delay we want. Note that the Manifest could
   * still be refreshed before this delay for other reasons.
   * @type {Number}
   */
  OUT_OF_SYNC_MANIFEST_REFRESH_DELAY: 3000,

  /**
   * Max simultaneous MediaKeySessions that will be kept as a cache to avoid
   * doing superfluous license requests.
   * If this number is reached, any new session creation will close the oldest
   * one.
   * @type {Number}
   */
  EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS: 50,

  /**
   * The player relies on browser events and properties to update its status to
   * "ENDED".
   *
   * Sadly in some cases, like in Chrome 54, this event is never triggered on
   * some contents probably due to a browser bug.
   *
   * This threshold resolves this issue by forcing the status to "ENDED" when:
   *   1. the player is stalling
   *   2. the absolute difference between current playback time and duration is
   *      under this value
   *
   * If set to null, this workaround is disabled and the player only relies on
   * browser events.
   *
   * @type {Number|null}
   */
  FORCED_ENDED_THRESHOLD: 0.001,

  /**
   * Maximum duration from the current position we will let in the buffer when
   * switching an Adaptation of a given type.
   *
   * For example, if we have ``text: { before: 1, after: 4 }``, it means that
   * when switching subtitles, we will let 1 second before and 4 second after
   * the current position in the previous language (until the new segments
   * overwrite it).
   * This is to allow smooth transitions and avoid de-synchronization that
   * can happen when removing the content being decoded.
   * @type {Object}
   */
  ADAPTATION_SWITCH_BUFFER_PADDINGS: {
    video: {
      before: 0.5,
      after: 1
    },
    audio: {
      before: 0.5,
      after: 2
    },
    text: {
      before: 0,
      after: 0
    },
    image: {
      before: 0,
      after: 0
    }
  },

  /**
   * Interval, in milliseconds, at which we should manually flush
   * SourceBuffers.
   * Some browsers (happened with firefox 66) sometimes "forget" to send us
   * `update` or `updateend` events.
   * In that case, we're completely unable to continue the queue here and
   * stay locked in a waiting state.
   * This interval is here to check at regular intervals if the underlying
   * SourceBuffer is currently updating.
   * @type {Number}
   */
  SOURCE_BUFFER_FLUSHING_INTERVAL: 2000
};
},{}],"../../../utils/request/fetch.ts":[function(require,module,exports) {
"use strict";
/*
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var config_1 = __importDefault(require("../../config"));

var errors_1 = require("../../errors");

var log_1 = __importDefault(require("../../log"));

var DEFAULT_REQUEST_TIMEOUT = config_1.default.DEFAULT_REQUEST_TIMEOUT;

var _Headers = typeof Headers === "function" ? Headers : null;

var _AbortController = typeof AbortController === "function" ? AbortController : null;

function fetchRequest(options) {
  var headers;

  if (options.headers != null) {
    if (_Headers == null) {
      headers = options.headers;
    } else {
      headers = new _Headers();
      var headerNames = Object.keys(options.headers);

      for (var i = 0; i < headerNames.length; i++) {
        var headerName = headerNames[i];
        headers.append(headerName, options.headers[headerName]);
      }
    }
  }

  return new rxjs_1.Observable(function (obs) {
    log_1.default.debug("Fetch: Called with URL", options.url);
    var hasAborted = false;
    var timeouted = false;
    var isDone = false;
    var sendingTime = performance.now();
    var abortController = _AbortController != null ? new _AbortController() : null;
    /**
     * Abort current fetchRequest by triggering AbortController signal.
     * @returns {void}
     */

    function abortRequest() {
      if (!isDone) {
        if (abortController) {
          return abortController.abort();
        }

        log_1.default.warn("Fetch: AbortController API not available.");
      }
    }

    var requestTimeout = options.timeout == null ? DEFAULT_REQUEST_TIMEOUT : options.timeout;
    var timeout = window.setTimeout(function () {
      timeouted = true;
      abortRequest();
    }, requestTimeout);
    fetch(options.url, {
      headers: headers,
      method: "GET",
      signal: abortController ? abortController.signal : undefined
    }).then(function (response) {
      if (timeout != null) {
        clearTimeout(timeout);
      }

      if (response.status >= 300) {
        log_1.default.warn("Fetch: Request HTTP Error", response);
        obs.error(new errors_1.RequestError(response.url, response.status, errors_1.NetworkErrorTypes.ERROR_HTTP_CODE));
        return undefined;
      }

      if (response.body == null) {
        obs.error(new errors_1.RequestError(response.url, response.status, errors_1.NetworkErrorTypes.PARSE_ERROR));
        return undefined;
      }

      var contentLengthHeader = response.headers.get("Content-Length");
      var contentLength = contentLengthHeader != null && !isNaN(+contentLengthHeader) ? +contentLengthHeader : undefined;
      var reader = response.body.getReader();
      var size = 0;
      return readBufferAndSendEvents();

      function readBufferAndSendEvents() {
        return _readBufferAndSendEvents.apply(this, arguments);
      }

      function _readBufferAndSendEvents() {
        _readBufferAndSendEvents = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee() {
          var data, currentTime, dataChunk, receivedTime, duration;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return reader.read();

                case 2:
                  data = _context.sent;

                  if (!(!data.done && data.value != null)) {
                    _context.next = 11;
                    break;
                  }

                  size += data.value.byteLength;
                  currentTime = performance.now();
                  dataChunk = {
                    type: "data-chunk",
                    value: {
                      url: response.url,
                      currentTime: currentTime,
                      duration: currentTime - sendingTime,
                      sendingTime: sendingTime,
                      chunkSize: data.value.byteLength,
                      chunk: data.value.buffer,
                      size: size,
                      totalSize: contentLength
                    }
                  };
                  obs.next(dataChunk);
                  return _context.abrupt("return", readBufferAndSendEvents());

                case 11:
                  if (data.done) {
                    receivedTime = performance.now();
                    duration = receivedTime - sendingTime;
                    isDone = true;
                    obs.next({
                      type: "data-complete",
                      value: {
                        duration: duration,
                        receivedTime: receivedTime,
                        sendingTime: sendingTime,
                        size: size,
                        status: response.status,
                        url: response.url
                      }
                    });
                    obs.complete();
                  }

                case 12:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        return _readBufferAndSendEvents.apply(this, arguments);
      }
    }).catch(function (err) {
      if (hasAborted) {
        log_1.default.debug("Fetch: Request aborted.");
        return;
      }

      if (timeouted) {
        log_1.default.warn("Fetch: Request timeouted.");
        obs.error(new errors_1.RequestError(options.url, 0, errors_1.NetworkErrorTypes.TIMEOUT));
        return;
      }

      log_1.default.warn("Fetch: Request Error", err && err.toString());
      obs.error(new errors_1.RequestError(options.url, 0, errors_1.NetworkErrorTypes.ERROR_EVENT));
      return;
    });
    return function () {
      hasAborted = true;
      abortRequest();
    };
  });
}
/**
 * Returns true if fetch should be supported in the current browser.
 * @return {boolean}
 */


function fetchIsSupported() {
  return !!(window.fetch && _AbortController != null && _Headers != null);
}

exports.fetchIsSupported = fetchIsSupported;
exports.default = fetchRequest; // function fetchRequest(options : IRequestOptions< undefined | null | "" | "text",
//                                             false | undefined>)
//                      : Observable<IRequestResponse< string, "text" >>;
// function fetchRequest(options : IRequestOptions< undefined | null | "" | "text",
//                                             true >)
//                      : Observable<IRequestResponse< string, "text" > |
//                                   IRequestProgress< string > >;
// function fetchRequest(options : IRequestOptions< "arraybuffer",
//                                             false | undefined>)
//                      : Observable<IRequestResponse< ArrayBuffer, "arraybuffer" >>;
// function fetchRequest(options : IRequestOptions<"arraybuffer", true>)
//                      : Observable<IRequestResponse< ArrayBuffer, "arraybuffer" > |
//                                   IRequestProgress < ArrayBuffer > >;
//                                   // IRequestProgress |
//                                   // IRequestDataChunk< ArrayBuffer, "arraybuffer" >>;
// function fetchRequest(options : IRequestOptions< "document",
//                                             false | undefined >)
//                 : Observable<IRequestResponse< Document, "document" >>;
// function fetchRequest(options : IRequestOptions< "document",
//                                             true >)
//                 : Observable<IRequestResponse< Document, "document" > |
//                              IRequestProgress< undefined > >;
// function fetchRequest(options : IRequestOptions< "json",
//                                             false | undefined >)
//                 : Observable<IRequestResponse< object, "json" >>;
// function fetchRequest(options : IRequestOptions< "json", true >)
//                 : Observable<IRequestResponse< object, "json" > |
//                              IRequestProgress< undefined > >;
// function fetchRequest(options : IRequestOptions< "blob",
//                                             false|undefined >)
//                 : Observable<IRequestResponse< Blob, "blob" >>;
// function fetchRequest(options : IRequestOptions<"blob", true>)
//                 : Observable<IRequestResponse< Blob, "blob" > |
//                              IRequestProgress< Blob > >;
// function fetchRequest<T>(
//   options : IRequestOptions< XMLHttpRequestResponseType | null | undefined,
//                              false | undefined >)
//   : Observable<IRequestResponse< T, XMLHttpRequestResponseType >>;
// function fetchRequest<T>(
//   options : IRequestOptions< XMLHttpRequestResponseType | null | undefined,
//                             true >)
//   : Observable<IRequestResponse< T, XMLHttpRequestResponseType > |
//                IRequestProgress< T | undefined >
// >;
// function fetchRequest<T>(
//   options : IRequestOptions< XMLHttpRequestResponseType | null | undefined,
//                             boolean | undefined >
// ) : Observable<IRequestResponse< T, XMLHttpRequestResponseType > |
//                IRequestProgress< T | undefined >
// > {
// const responseType = !options.responseType ||
//                      options.responseType === "document" ? "text" :
//                                                            options.responseType;
// return (() => {
//   switch (responseType) {
//     case "arraybuffer":
//       return response.arrayBuffer();
//     case "json":
//       return response.json();
//     case "blob":
//       return response.blob();
//     case "text":
//       return response.text();
//   }
// })().then((responseData) => {
//   isDone = true;
//   const receivedTime = performance.now();
//   obs.next({ type: "response" as const,
//              value: { responseType,
//                       status: response.status,
//                       url: response.url,
//                       sendingTime,
//                       receivedTime,
//                duration: receivedTime - sendingTime,
//                       size: responseData instanceof ArrayBuffer ?
//                               responseData.byteLength :
//                               0,
//                       responseData } });
// }).catch((err) => {
//   log.warn("Fetch: Request Parsing Error", err && err.toString());
//   if (hasAborted) { // is that even possible?
//     return;
//   }
//   obs.error(new RequestError(null,
//                              response.url,
//                              response.status,
//                              NetworkErrorTypes.PARSE_ERROR));
//   return;
// });
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","../../config":"../../../config.ts","../../errors":"../../../errors/index.ts","../../log":"../../../log.ts"}],"../../../utils/request/xhr.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var config_1 = __importDefault(require("../../config"));

var errors_1 = require("../../errors");

var DEFAULT_REQUEST_TIMEOUT = config_1.default.DEFAULT_REQUEST_TIMEOUT;
var DEFAULT_RESPONSE_TYPE = "json";
/**
 * @param {string} data
 * @returns {Object|null}
 */

function toJSONForIE(data) {
  try {
    return JSON.parse(data);
  } catch (e) {
    return null;
  }
}

function request(options) {
  var requestOptions = {
    url: options.url,
    headers: options.headers,
    responseType: options.responseType == null ? DEFAULT_RESPONSE_TYPE : options.responseType,
    timeout: options.timeout == null ? DEFAULT_REQUEST_TIMEOUT : options.timeout
  };
  return new rxjs_1.Observable(function (obs) {
    var url = requestOptions.url,
        headers = requestOptions.headers,
        responseType = requestOptions.responseType,
        timeout = requestOptions.timeout;
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, true);

    if (timeout >= 0) {
      xhr.timeout = timeout;
    }

    xhr.responseType = responseType;

    if (xhr.responseType === "document") {
      xhr.overrideMimeType("text/xml");
    }

    if (headers) {
      var _headers = headers;

      for (var key in _headers) {
        if (_headers.hasOwnProperty(key)) {
          xhr.setRequestHeader(key, _headers[key]);
        }
      }
    }

    var sendingTime = performance.now();

    xhr.onerror = function onXHRError() {
      obs.error(new errors_1.RequestError(url, xhr.status, "ERROR_EVENT", xhr));
    };

    xhr.ontimeout = function onXHRTimeout() {
      obs.error(new errors_1.RequestError(url, xhr.status, "TIMEOUT", xhr));
    };

    if (options.sendProgressEvents === true) {
      xhr.onprogress = function onXHRProgress(event) {
        var currentTime = performance.now();
        obs.next({
          type: "progress",
          value: {
            url: url,
            duration: currentTime - sendingTime,
            sendingTime: sendingTime,
            currentTime: currentTime,
            size: event.loaded,
            totalSize: event.total
          }
        });
      };
    }

    xhr.onload = function onXHRLoad(event) {
      if (xhr.readyState === 4) {
        if (xhr.status >= 200 && xhr.status < 300) {
          var receivedTime = performance.now();
          var totalSize = xhr.response instanceof ArrayBuffer ? xhr.response.byteLength : event.total;
          var status = xhr.status;
          var loadedResponseType = xhr.responseType;

          var _url = xhr.responseURL || url;

          var responseData;

          if (loadedResponseType === "json") {
            // IE bug where response is string with responseType json
            responseData = xhr.response !== "string" ? xhr.response : toJSONForIE(xhr.responseText);
          } else {
            responseData = xhr.response;
          }

          if (responseData == null) {
            obs.error(new errors_1.RequestError(url, xhr.status, "PARSE_ERROR", xhr));
            return;
          }

          obs.next({
            type: "data-loaded",
            value: {
              status: status,
              url: _url,
              responseType: loadedResponseType,
              sendingTime: sendingTime,
              receivedTime: receivedTime,
              duration: receivedTime - sendingTime,
              size: totalSize,
              responseData: responseData
            }
          });
          obs.complete();
        } else {
          obs.error(new errors_1.RequestError(url, xhr.status, "ERROR_HTTP_CODE", xhr));
        }
      }
    };

    xhr.send();
    return function () {
      if (xhr && xhr.readyState !== 4) {
        xhr.abort();
      }
    };
  });
}

exports.default = request;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","../../config":"../../../config.ts","../../errors":"../../../errors/index.ts"}],"../../../utils/request/index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var fetch_1 = __importStar(require("./fetch"));

exports.fetchRequest = fetch_1.default;
exports.fetchIsSupported = fetch_1.fetchIsSupported;
exports.IDataChunk = fetch_1.IDataChunk;
exports.IDataComplete = fetch_1.IDataComplete;

var xhr_1 = __importStar(require("./xhr"));

exports.xhr = xhr_1.default;
exports.IRequestOptions = xhr_1.IRequestOptions;
exports.IRequestProgress = xhr_1.IRequestProgress;
exports.IRequestResponse = xhr_1.IRequestResponse;
exports.default = xhr_1.default;
},{"./fetch":"../../../utils/request/fetch.ts","./xhr":"../../../utils/request/xhr.ts"}],"../../../compat/browser_detection.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
}); // true on IE11
// false on Edge and other IEs/browsers.

var isIE11 = !!window.MSInputMethodContext && !!document.documentMode;
exports.isIE11 = isIE11; // true for IE / Edge

var isIEOrEdge = navigator.appName === "Microsoft Internet Explorer" || navigator.appName === "Netscape" && /(Trident|Edge)\//.test(navigator.userAgent);
exports.isIEOrEdge = isIEOrEdge;
var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
exports.isFirefox = isFirefox;
var isSamsungBrowser = /SamsungBrowser/.test(navigator.userAgent);
exports.isSamsungBrowser = isSamsungBrowser;
var isSafari = /Safari/i.test(navigator.userAgent);
exports.isSafari = isSafari;
},{}],"../../../compat/add_text_track.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var browser_detection_1 = require("./browser_detection");
/**
 * Add text track to the given media element.
 * Returns an object with the following properties:
 *   - track {TextTrack}: the added text track
 *   - trackElement {HTMLElement|undefined}: the added <track> element.
 *     undefined if no trackElement was added.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {Boolean} hidden
 * @returns {Object}
 */


function addTextTrack(mediaElement, hidden) {
  var track;
  var trackElement;
  var kind = "subtitles";

  if (browser_detection_1.isIEOrEdge) {
    var tracksLength = mediaElement.textTracks.length;
    track = tracksLength > 0 ? mediaElement.textTracks[tracksLength - 1] : mediaElement.addTextTrack(kind);
    track.mode = hidden ? track.HIDDEN : track.SHOWING;
  } else {
    trackElement = document.createElement("track");
    mediaElement.appendChild(trackElement);
    track = trackElement.track;
    trackElement.kind = kind;
    track.mode = hidden ? "hidden" : "showing";
  }

  return {
    track: track,
    trackElement: trackElement
  };
}

exports.default = addTextTrack;
},{"./browser_detection":"../../../compat/browser_detection.ts"}],"../../../compat/should_use_webkit_media_keys.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var browser_detection_1 = require("./browser_detection"); // On Safari 12.1, it seems that since fairplay CDM implementation
// within the browser is not standard with EME w3c current spec, the
// requestMediaKeySystemAccess API doesn't resolve positively, even
// if the drm (fairplay in most cases) is supported.


function shouldUseWebKitMediaKeys() {
  return browser_detection_1.isSafari && window.WebKitMediaKeys != null;
}

exports.default = shouldUseWebKitMediaKeys;
},{"./browser_detection":"../../../compat/browser_detection.ts"}],"../../../compat/browser_compatibility_types.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var errors_1 = require("../errors");

var should_use_webkit_media_keys_1 = __importDefault(require("./should_use_webkit_media_keys"));

var win = window;
var HTMLElement_ = win.HTMLElement;
exports.HTMLElement_ = HTMLElement_;
var VTTCue_ = win.VTTCue || win.TextTrackCue;
exports.VTTCue_ = VTTCue_;
var MediaSource_ = win.MediaSource || win.MozMediaSource || win.WebKitMediaSource || win.MSMediaSource;
exports.MediaSource_ = MediaSource_;

var MediaKeys_ = function () {
  if (should_use_webkit_media_keys_1.default()) {
    return win.WebKitMediaKeys;
  }

  return win.MediaKeys || win.MSMediaKeys || win.MozMediaKeys || win.WebKitMediaKeys ||
  /*#__PURE__*/
  function () {
    function _class() {
      _classCallCheck(this, _class);

      var noMediaKeys = function noMediaKeys() {
        throw new errors_1.MediaError("MEDIA_KEYS_NOT_SUPPORTED", "No `MediaKeys` implementation found " + "in the current browser.");
      };

      this.create = noMediaKeys;
      this.createSession = noMediaKeys;
      this.isTypeSupported = noMediaKeys;
      this.setServerCertificate = noMediaKeys;
    }

    return _class;
  }();
}();

exports.MediaKeys_ = MediaKeys_;
var READY_STATES = {
  HAVE_NOTHING: 0,
  HAVE_METADATA: 1,
  HAVE_CURRENT_DATA: 2,
  HAVE_FUTURE_DATA: 3,
  HAVE_ENOUGH_DATA: 4
};
exports.READY_STATES = READY_STATES;
},{"../errors":"../../../errors/index.ts","./should_use_webkit_media_keys":"../../../compat/should_use_webkit_media_keys.ts"}],"../../../compat/can_patch_isobmff.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var browser_detection_1 = require("./browser_detection");
/**
 * TODO(pierre): fix patchSegmentInPlace to work with IE11. Maybe
 * try to put free atom inside traf children
 *
 * Returns true if the current target is tolerant enough for us to
 * simply be able to "patch" an ISOBMFF segment or if we have to create a
 * new one from scratch instead.
 * @returns {Boolean}
 */


function canPatchISOBMFFSegment() {
  return !browser_detection_1.isIEOrEdge;
}

exports.default = canPatchISOBMFFSegment;
},{"./browser_detection":"../../../compat/browser_detection.ts"}],"../../../compat/change_source_buffer_type.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../log"));
/**
 * If the changeType MSE API is implemented, update the current codec of the
 * SourceBuffer and return true if it succeeded.
 * In any other cases, return false.
 * @param {Object} sourceBuffer
 * @param {string} codec
 * @returns {boolean}
 */


function tryToChangeSourceBufferType(sourceBuffer, codec) {
  if (typeof sourceBuffer.changeType === "function") {
    try {
      sourceBuffer.changeType(codec);
    } catch (e) {
      log_1.default.warn("Could not call 'changeType' on the given SourceBuffer:", e);
      return false;
    }

    return true;
  }

  return false;
}

exports.default = tryToChangeSourceBufferType;
},{"../log":"../../../log.ts"}],"../../../compat/clear_element_src.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../log"));

var browser_detection_1 = require("./browser_detection");
/**
 * Clear element's src attribute.
 * @param {HTMLMediaElement} element
 */


function clearElementSrc(element) {
  // On Firefox, we also have to make sure the textTracks elements are both
  // disabled and removed from the DOM.
  // If we do not do that, we may be left with displayed text tracks on the
  // screen
  if (browser_detection_1.isFirefox) {
    var textTracks = element.textTracks;

    for (var i = 0; i < textTracks.length; i++) {
      textTracks[i].mode = "disabled";
    }

    if (element.hasChildNodes()) {
      var childNodes = element.childNodes;

      for (var j = childNodes.length - 1; j >= 0; j--) {
        if (childNodes[j].nodeName === "track") {
          try {
            element.removeChild(childNodes[j]);
          } catch (err) {
            log_1.default.warn("Compat: Could not remove text track child from element.");
          }
        }
      }
    }
  }

  element.src = ""; // On IE11, element.src = "" is not sufficient as it
  // does not clear properly the current MediaKey Session.
  // Microsoft recommended to use element.removeAttr("src").

  element.removeAttribute("src");
}

exports.default = clearElementSrc;
},{"../log":"../../../log.ts","./browser_detection":"../../../compat/browser_detection.ts"}],"../../../compat/eme/custom_key_system_access.ts":[function(require,module,exports) {
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var promise_1 = __importDefault(require("../../utils/promise"));
/**
 * Simple implementation of the MediaKeySystemAccess EME API.
 *
 * All needed arguments are given to the constructor
 * @class CustomMediaKeySystemAccess
 */


var CustomMediaKeySystemAccess =
/*#__PURE__*/
function () {
  /**
   * @param {string} _keyType - type of key system (e.g. "widevine" or
   * "com.widevine.alpha").
   * @param {Object} _mediaKeys - MediaKeys implementation
   * @param {Object} _configuration - Configuration accepted for this
   * MediaKeySystemAccess.
   */
  function CustomMediaKeySystemAccess(_keyType, _mediaKeys, _configuration) {
    _classCallCheck(this, CustomMediaKeySystemAccess);

    this._keyType = _keyType;
    this._mediaKeys = _mediaKeys;
    this._configuration = _configuration;
  }
  /**
   * @returns {string} - current key system type (e.g. "widevine" or
   * "com.widevine.alpha").
   */


  _createClass(CustomMediaKeySystemAccess, [{
    key: "createMediaKeys",

    /**
     * @returns {Promise.<Object>} - Promise wrapping the MediaKeys for this
     * MediaKeySystemAccess. Never rejects.
     */
    value: function createMediaKeys() {
      var _this = this;

      return new promise_1.default(function (res) {
        return res(_this._mediaKeys);
      });
    }
    /**
     * @returns {Object} - Configuration accepted for this MediaKeySystemAccess.
     */

  }, {
    key: "getConfiguration",
    value: function getConfiguration() {
      return this._configuration;
    }
  }, {
    key: "keySystem",
    get: function get() {
      return this._keyType;
    }
  }]);

  return CustomMediaKeySystemAccess;
}();

exports.default = CustomMediaKeySystemAccess;
},{"../../utils/promise":"../../../utils/promise.ts"}],"../../../utils/cast_to_observable.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

function castToObservable(value) {
  if (value instanceof rxjs_1.Observable) {
    return value;
  }

  if (value && typeof value.subscribe === "function") {
    var valObsLike = value;
    return new rxjs_1.Observable(function (obs) {
      var sub = valObsLike.subscribe(function (val) {
        obs.next(val);
      }, function (err) {
        obs.error(err);
      }, function () {
        obs.complete();
      });
      return function () {
        if (sub && sub.dispose) {
          sub.dispose();
        } else if (sub && sub.unsubscribe) {
          sub.unsubscribe();
        }
      };
    });
  }

  if (value && typeof value.then === "function") {
    return rxjs_1.from(value);
  }

  return rxjs_1.of(value);
}

exports.default = castToObservable;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js"}],"../../../utils/event_emitter.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var log_1 = __importDefault(require("../log"));
/**
 * Simple but fully type-safe EventEmitter implementation.
 * @class EventEmitter
 */


var EventEmitter =
/*#__PURE__*/
function () {
  function EventEmitter() {
    _classCallCheck(this, EventEmitter);

    this._listeners = {};
  }
  /**
   * Register a new callback for an event.
   *
   * @param {string} evt - The event to register a callback to
   * @param {Function} fn - The callback to call as that event is triggered.
   * The callback will take as argument the eventual payload of the event
   * (single argument).
   */


  _createClass(EventEmitter, [{
    key: "addEventListener",
    value: function addEventListener(evt, fn) {
      var listeners = this._listeners[evt];

      if (!listeners) {
        this._listeners[evt] = [fn];
      } else {
        listeners.push(fn);
      }
    }
    /**
     * Unregister callbacks linked to events.
     * @param {string} [evt] - The event for which the callback[s] should be
     * unregistered. Set it to null or undefined to remove all callbacks
     * currently registered (for any event).
     * @param {Function} [fn] - The callback to unregister. If set to null
     * or undefined while the evt argument is set, all callbacks linked to that
     * event will be unregistered.
     */

  }, {
    key: "removeEventListener",
    value: function removeEventListener(evt, fn) {
      if (evt == null) {
        this._listeners = {};
        return;
      }

      var listeners = this._listeners[evt];

      if (!listeners) {
        return;
      }

      if (fn == null) {
        delete this._listeners[evt];
        return;
      }

      var index = listeners.indexOf(fn);

      if (~index) {
        listeners.splice(index, 1);
      }

      if (!listeners.length) {
        delete this._listeners[evt];
      }
    }
    /**
     * Trigger every registered callbacks for a given event
     * @param {string} evt - The event to trigger
     * @param {*} arg - The eventual payload for that event. All triggered
     * callbacks will recieve this payload as argument.
     */

  }, {
    key: "trigger",
    value: function trigger(evt, arg) {
      var listeners = this._listeners[evt];

      if (!listeners) {
        return;
      }

      listeners.slice().forEach(function (listener) {
        try {
          listener(arg);
        } catch (e) {
          log_1.default.error(e, e.stack);
        }
      });
    }
  }]);

  return EventEmitter;
}();

exports.default = EventEmitter;
/**
 * Simple redefinition of the fromEvent from rxjs to also work on our
 * implementation of EventEmitter with type-checked strings
 * @param {Object} target
 * @param {string} eventName
 * @returns {Observable}
 */

function fromEvent(target, eventName) {
  return new rxjs_1.Observable(function (obs) {
    function handler(event) {
      obs.next(event);
    }

    target.addEventListener(eventName, handler);
    return function () {
      target.removeEventListener(eventName, handler);
    };
  });
}

exports.fromEvent = fromEvent;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","../log":"../../../log.ts"}],"../../../compat/event_listeners.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * This file provides browser-agnostic event listeners under the form of
 * RxJS Observables
 */

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var config_1 = __importDefault(require("../config"));

var log_1 = __importDefault(require("../log"));

var browser_compatibility_types_1 = require("./browser_compatibility_types");

var BROWSER_PREFIXES = ["", "webkit", "moz", "ms"];
var INACTIVITY_DELAY = config_1.default.INACTIVITY_DELAY;
var pixelRatio = window.devicePixelRatio || 1;
/**
 * Find the first supported event from the list given.
 * @param {HTMLElement} element
 * @param {string} eventNameSuffix
 * @returns {Boolean}
 */

function isEventSupported(element, eventNameSuffix) {
  var clone = document.createElement(element.tagName);
  var eventName = "on" + eventNameSuffix;

  if (eventName in clone) {
    return true;
  } else {
    clone.setAttribute(eventName, "return;");
    return typeof clone[eventName] === "function";
  }
}
/**
 * Find the first supported event from the list given.
 * @param {HTMLElement} element
 * @param {Array.<string>} eventNames
 * @returns {string|undefined}
 */


function findSupportedEvent(element, eventNames) {
  return eventNames.filter(function (name) {
    return isEventSupported(element, name);
  })[0];
}
/**
 * @param {Array.<string>} eventNames
 * @param {Array.<string>|undefined} prefixes
 * @returns {Array.<string>}
 */


function eventPrefixed(eventNames, prefixes) {
  return eventNames.reduce(function (parent, name) {
    return parent.concat((prefixes || BROWSER_PREFIXES).map(function (p) {
      return p + name;
    }));
  }, []);
}
/**
 * @param {Array.<string>} eventNames
 * @param {Array.<string>|undefined} prefixes
 * @returns {Observable}
 */


function compatibleListener(eventNames, prefixes) {
  var mem;
  var prefixedEvents = eventPrefixed(eventNames, prefixes);
  return function (element) {
    // if the element is a HTMLElement we can detect
    // the supported event, and memoize it in `mem`
    if (element instanceof browser_compatibility_types_1.HTMLElement_) {
      if (typeof mem === "undefined") {
        mem = findSupportedEvent(element, prefixedEvents);
      }

      if (mem) {
        return rxjs_1.fromEvent(element, mem);
      } else {
        if (__DEV__) {
          log_1.default.warn("compat: element ".concat(element.tagName) + " does not support any of these events: " + prefixedEvents.join(", "));
        }

        return rxjs_1.NEVER;
      }
    } // otherwise, we need to listen to all the events
    // and merge them into one observable sequence


    return rxjs_1.merge.apply(rxjs_1, _toConsumableArray(prefixedEvents.map(function (eventName) {
      return rxjs_1.fromEvent(element, eventName);
    })));
  };
}
/**
 * Returns an observable:
 *   - emitting true when the document is visible
 *   - emitting false when the document is hidden
 * @returns {Observable}
 */


function visibilityChange() {
  var prefix;
  var doc = document;

  if (doc.hidden != null) {
    prefix = "";
  } else if (doc.mozHidden != null) {
    prefix = "moz";
  } else if (doc.msHidden != null) {
    prefix = "ms";
  } else if (doc.webkitHidden != null) {
    prefix = "webkit";
  }

  var hidden = prefix ? prefix + "Hidden" : "hidden";
  var visibilityChangeEvent = prefix ? prefix + "visibilitychange" : "visibilitychange";
  return rxjs_1.defer(function () {
    var isHidden = document[hidden];
    return rxjs_1.fromEvent(document, visibilityChangeEvent).pipe(operators_1.map(function () {
      return !document[hidden];
    }), operators_1.startWith(!isHidden), operators_1.distinctUntilChanged());
  });
}
/**
 * @returns {Observable}
 */


function videoSizeChange() {
  return rxjs_1.fromEvent(window, "resize");
}
/**
 * Emit `true` if the page is considered active.
 * `false` when considered inactive.
 * Emit the original value on subscription.
 * @returns {Observable}
 */


function isActive() {
  return visibilityChange().pipe(operators_1.switchMap(function (x) {
    if (!x) {
      return rxjs_1.of(x).pipe(operators_1.delay(INACTIVITY_DELAY));
    }

    return rxjs_1.of(x);
  }));
}

exports.isActive = isActive;
/**
 * Get video width from Picture-in-Picture window
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} pipWindow
 * @returns {number}
 */

function getVideoWidthFromPIPWindow(mediaElement, pipWindow) {
  var width = pipWindow.width,
      height = pipWindow.height;
  var videoRatio = mediaElement.clientHeight / mediaElement.clientWidth;
  var calcWidth = height / videoRatio;
  return Math.min(width, calcWidth);
}
/**
 * Emit when video enters and leaves Picture-In-Picture mode.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */


function onPictureInPictureEvent$(mediaElement) {
  return rxjs_1.defer(function () {
    if (mediaElement.webkitSupportsPresentationMode && typeof mediaElement.webkitSetPresentationMode === "function") {
      var isWebKitPIPEnabled = mediaElement.webkitPresentationMode === "picture-in-picture";
      return rxjs_1.fromEvent(mediaElement, "webkitpresentationmodechanged").pipe(operators_1.map(function () {
        return {
          isEnabled: mediaElement.webkitPresentationMode === "picture-in-picture",
          pipWindow: null
        };
      }), operators_1.startWith({
        isEnabled: isWebKitPIPEnabled,
        pipWindow: null
      }));
    }

    var isPIPEnabled = document.pictureInPictureElement && document.pictureInPictureElement === mediaElement;
    var initialState = {
      isEnabled: isPIPEnabled,
      pipWindow: null
    };
    return rxjs_1.merge(rxjs_1.fromEvent(mediaElement, "enterpictureinpicture").pipe(operators_1.map(function (evt) {
      return {
        isEnabled: true,
        pipWindow: evt.pictureInPictureWindow
      };
    })), rxjs_1.fromEvent(mediaElement, "leavepictureinpicture").pipe(operators_1.mapTo({
      isEnabled: false,
      pipWindow: null
    }))).pipe(operators_1.startWith(initialState));
  });
}

exports.onPictureInPictureEvent$ = onPictureInPictureEvent$;
/**
 * Returns `true` when video is considered as visible (the page is visible and/or
 * the Picture-In-Picture is activated). Returns `false` otherwise.
 * @param {Observable} pip$
 * @returns {Observable}
 */

function isVideoVisible(pip$) {
  return rxjs_1.combineLatest([visibilityChange(), pip$]).pipe(operators_1.switchMap(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        isVisible = _ref2[0],
        pip = _ref2[1];

    if (pip.isEnabled || isVisible) {
      return rxjs_1.of(true);
    }

    return rxjs_1.of(false).pipe(operators_1.delay(INACTIVITY_DELAY));
  }), operators_1.distinctUntilChanged());
}

exports.isVideoVisible = isVideoVisible;
/**
 * Get video width from HTML video element, or video estimated dimensions
 * when Picture-in-Picture is activated.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

function videoWidth$(mediaElement, pip$) {
  return rxjs_1.combineLatest([pip$, rxjs_1.interval(20000).pipe(operators_1.startWith(null)), videoSizeChange().pipe(operators_1.throttleTime(500), operators_1.startWith(null))]).pipe(operators_1.switchMap(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 1),
        pip = _ref4[0];

    if (!pip.isEnabled) {
      return rxjs_1.of(mediaElement.clientWidth * pixelRatio);
    } else if (pip.pipWindow != null) {
      var pipWindow = pip.pipWindow;
      var firstWidth = getVideoWidthFromPIPWindow(mediaElement, pipWindow); // RxJS typing issue (for the "as any")

      return rxjs_1.fromEvent(pipWindow, "resize").pipe(operators_1.startWith(firstWidth * pixelRatio), operators_1.map(function () {
        return getVideoWidthFromPIPWindow(mediaElement, pipWindow) * pixelRatio;
      }));
    } else {
      return rxjs_1.of(Infinity);
    }
  }), operators_1.distinctUntilChanged());
}

exports.videoWidth$ = videoWidth$;
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

var onLoadedMetadata$ = compatibleListener(["loadedmetadata"]);
exports.onLoadedMetadata$ = onLoadedMetadata$;
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

var onSeeking$ = compatibleListener(["seeking"]);
exports.onSeeking$ = onSeeking$;
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

var onSeeked$ = compatibleListener(["seeked"]);
exports.onSeeked$ = onSeeked$;
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

var onEnded$ = compatibleListener(["ended"]);
exports.onEnded$ = onEnded$;
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

var onTimeUpdate$ = compatibleListener(["timeupdate"]);
exports.onTimeUpdate$ = onTimeUpdate$;
/**
 * @param {HTMLElement} element
 * @returns {Observable}
 */

var onFullscreenChange$ = compatibleListener(["fullscreenchange", "FullscreenChange"], // On IE11, fullscreen change events is called MSFullscreenChange
BROWSER_PREFIXES.concat("MS"));
exports.onFullscreenChange$ = onFullscreenChange$;
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

var onPlayPause$ = function onPlayPause$(mediaElement) {
  return rxjs_1.merge(compatibleListener(["play"])(mediaElement), compatibleListener(["pause"])(mediaElement));
};

exports.onPlayPause$ = onPlayPause$;
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

var onTextTrackChanges$ = function onTextTrackChanges$(textTrackList) {
  return rxjs_1.merge(compatibleListener(["addtrack"])(textTrackList), compatibleListener(["removetrack"])(textTrackList));
};

exports.onTextTrackChanges$ = onTextTrackChanges$;
/**
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */

var onSourceOpen$ = compatibleListener(["sourceopen", "webkitsourceopen"]);
exports.onSourceOpen$ = onSourceOpen$;
/**
 * @param {SourceBuffer} sourceBuffer
 * @returns {Observable}
 */

var onUpdate$ = compatibleListener(["update"]);
exports.onUpdate$ = onUpdate$;
/**
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */

var onRemoveSourceBuffers$ = compatibleListener(["onremovesourcebuffer"]);
exports.onRemoveSourceBuffers$ = onRemoveSourceBuffers$;
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

var onEncrypted$ = compatibleListener(["encrypted", "needkey"]);
exports.onEncrypted$ = onEncrypted$;
/**
 * @param {MediaKeySession} mediaKeySession
 * @returns {Observable}
 */

var onKeyMessage$ = compatibleListener(["keymessage", "message"]);
exports.onKeyMessage$ = onKeyMessage$;
/**
 * @param {MediaKeySession} mediaKeySession
 * @returns {Observable}
 */

var onKeyAdded$ = compatibleListener(["keyadded", "ready"]);
exports.onKeyAdded$ = onKeyAdded$;
/**
 * @param {MediaKeySession} mediaKeySession
 * @returns {Observable}
 */

var onKeyError$ = compatibleListener(["keyerror", "error"]);
exports.onKeyError$ = onKeyError$;
/**
 * @param {MediaKeySession} mediaKeySession
 * @returns {Observable}
 */

var onKeyStatusesChange$ = compatibleListener(["keystatuseschange"]);
exports.onKeyStatusesChange$ = onKeyStatusesChange$;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../config":"../../../config.ts","../log":"../../../log.ts","./browser_compatibility_types":"../../../compat/browser_compatibility_types.ts"}],"../../../compat/eme/custom_media_keys.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var byte_parsing_1 = require("../../utils/byte_parsing");

var cast_to_observable_1 = __importDefault(require("../../utils/cast_to_observable"));

var event_emitter_1 = __importDefault(require("../../utils/event_emitter"));

var promise_1 = __importDefault(require("../../utils/promise"));

var browser_compatibility_types_1 = require("../browser_compatibility_types");

var browser_detection_1 = require("../browser_detection");

var events = __importStar(require("../event_listeners"));

var should_use_webkit_media_keys_1 = __importDefault(require("../should_use_webkit_media_keys"));

var custom_key_system_access_1 = __importDefault(require("./custom_key_system_access"));

var requestMediaKeySystemAccess = null;
exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess;

function createMediaKeysSession(mediaKeys, sessionType) {
  return mediaKeys.createSession(sessionType);
}

var createSession = createMediaKeysSession;
exports.createSession = createSession; // Default CustomMediaKeys implementation

var CustomMediaKeys =
/*#__PURE__*/
function () {
  function CustomMediaKeys() {
    _classCallCheck(this, CustomMediaKeys);
  }

  _createClass(CustomMediaKeys, [{
    key: "_setVideo",
    value: function _setVideo() {
      throw new Error("MediaKeys is not implemented in your browser");
    }
  }, {
    key: "createSession",
    value: function createSession() {
      throw new Error("MediaKeys is not implemented in your browser");
    }
  }, {
    key: "setServerCertificate",
    value: function setServerCertificate() {
      throw new Error("MediaKeys is not implemented in your browser");
    }
  }]);

  return CustomMediaKeys;
}();
/**
 * Since Safari 12.1, EME APIs are available without webkit prefix.
 * However, it seems that since fairplay CDM implementation within the browser is not
 * standard with EME w3c current spec, the requestMediaKeySystemAccess API doesn't resolve
 * positively, even if the drm (fairplay in most cases) is supported.
 *
 * Therefore, we prefer not to use requestMediaKeySystemAccess on Safari when webkit API
 * is available.
 */


if (navigator.requestMediaKeySystemAccess && !should_use_webkit_media_keys_1.default()) {
  exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess = function requestMediaKeySystemAccess(a, b) {
    return cast_to_observable_1.default(navigator.requestMediaKeySystemAccess(a, b));
  };
} else {
  // Wrap "MediaKeys.prototype.update" form an event based system to a
  // Promise based function.
  var wrapUpdate = function wrapUpdate(memUpdate) {
    return function (license, sessionId) {
      var _this = this;

      return new promise_1.default(function (resolve, reject) {
        try {
          memUpdate.call(_this, license, sessionId || "");
          resolve();
        } catch (e) {
          reject(e);
        }
      });
    };
  };
  /**
   * Returns true if the given media element has old webkit methods
   * corresponding to the IOldWebkitHTMLMediaElement interface.
   * @param {HTMLMediaElement} element
   * @returns {Boolean}
   */


  var isOldWebkitMediaElement = function isOldWebkitMediaElement(element) {
    return typeof element.webkitGenerateKeyRequest === "function";
  }; // This is for Chrome with unprefixed EME api


  if (isOldWebkitMediaElement(HTMLVideoElement.prototype)) {
    var WebkitMediaKeySession =
    /*#__PURE__*/
    function (_event_emitter_1$defa) {
      _inherits(WebkitMediaKeySession, _event_emitter_1$defa);

      function WebkitMediaKeySession(mediaElement, keySystem) {
        var _this2;

        _classCallCheck(this, WebkitMediaKeySession);

        _this2 = _possibleConstructorReturn(this, _getPrototypeOf(WebkitMediaKeySession).call(this));
        _this2._closeSession$ = new rxjs_1.Subject();
        _this2._vid = mediaElement;
        _this2._key = keySystem;
        _this2.sessionId = "";
        _this2.closed = new promise_1.default(function (resolve) {
          _this2._closeSession$.subscribe(resolve);
        });
        _this2.keyStatuses = new Map();
        _this2.expiration = NaN;
        rxjs_1.merge(events.onKeyMessage$(mediaElement), events.onKeyAdded$(mediaElement), events.onKeyError$(mediaElement)).pipe(operators_1.takeUntil(_this2._closeSession$)).subscribe(function (evt) {
          return _this2.trigger(evt.type, evt);
        });
        _this2.update = wrapUpdate(function (license, sessionId) {
          if (!isOldWebkitMediaElement(_this2._vid)) {
            throw new Error("impossible to add a new key");
          }

          if (_this2._key.indexOf("clearkey") >= 0) {
            var licenseTypedArray = license instanceof ArrayBuffer ? new Uint8Array(license) : license;
            var json = JSON.parse(byte_parsing_1.bytesToStr(licenseTypedArray));
            var key = byte_parsing_1.strToBytes(atob(json.keys[0].k));
            var kid = byte_parsing_1.strToBytes(atob(json.keys[0].kid));

            _this2._vid.webkitAddKey(_this2._key, key, kid, sessionId);
          } else {
            _this2._vid.webkitAddKey(_this2._key, license, null, sessionId);
          }

          _this2.sessionId = sessionId;
        });
        return _this2;
      }

      _createClass(WebkitMediaKeySession, [{
        key: "generateRequest",
        value: function generateRequest(_initDataType, initData) {
          var _this3 = this;

          return new promise_1.default(function (resolve) {
            if (!isOldWebkitMediaElement(_this3._vid)) {
              throw new Error("impossible to generate a key request");
            }

            _this3._vid.webkitGenerateKeyRequest(_this3._key, initData);

            resolve();
          });
        }
      }, {
        key: "close",
        value: function close() {
          var _this4 = this;

          return new promise_1.default(function (resolve) {
            _this4._closeSession$.next();

            _this4._closeSession$.complete();

            resolve();
          });
        }
      }, {
        key: "load",
        value: function load() {
          return promise_1.default.resolve(false);
        }
      }, {
        key: "remove",
        value: function remove() {
          return promise_1.default.resolve();
        }
      }]);

      return WebkitMediaKeySession;
    }(event_emitter_1.default);

    CustomMediaKeys =
    /*#__PURE__*/
    function () {
      function CustomMediaKeys(keySystem) {
        _classCallCheck(this, CustomMediaKeys);

        this.ks_ = keySystem;
      }

      _createClass(CustomMediaKeys, [{
        key: "_setVideo",
        value: function _setVideo(vid) {
          this._vid = vid;
        }
      }, {
        key: "createSession",
        value: function createSession()
        /* sessionType */
        {
          if (!this._vid) {
            throw new Error("Video not attached to the MediaKeys");
          }

          return new WebkitMediaKeySession(this._vid, this.ks_);
        }
      }, {
        key: "setServerCertificate",
        value: function setServerCertificate() {
          throw new Error("Server certificate is not implemented in your browser");
        }
      }]);

      return CustomMediaKeys;
    }();

    var isTypeSupported = function isTypeSupported(keyType) {
      // get any <video> element from the DOM or create one
      // and try the `canPlayType` method
      var videoElement = document.querySelector("video") || document.createElement("video");

      if (videoElement && videoElement.canPlayType) {
        return !!videoElement.canPlayType("video/mp4", keyType);
      } else {
        return false;
      }
    };

    exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess = function requestMediaKeySystemAccess(keyType, keySystemConfigurations) {
      if (!isTypeSupported(keyType)) {
        return rxjs_1.throwError(undefined);
      }

      for (var i = 0; i < keySystemConfigurations.length; i++) {
        var keySystemConfiguration = keySystemConfigurations[i];
        var videoCapabilities = keySystemConfiguration.videoCapabilities,
            audioCapabilities = keySystemConfiguration.audioCapabilities,
            initDataTypes = keySystemConfiguration.initDataTypes,
            sessionTypes = keySystemConfiguration.sessionTypes,
            distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier,
            persistentState = keySystemConfiguration.persistentState;
        var supported = true;
        supported = supported && (!initDataTypes || !!initDataTypes.filter(function (initDataType) {
          return initDataType === "cenc";
        })[0]);
        supported = supported && (!sessionTypes || sessionTypes.filter(function (sessionType) {
          return sessionType === "temporary";
        }).length === sessionTypes.length);
        supported = supported && distinctiveIdentifier !== "required";
        supported = supported && persistentState !== "required";

        if (supported) {
          var keySystemConfigurationResponse = {
            videoCapabilities: videoCapabilities,
            audioCapabilities: audioCapabilities,
            initDataTypes: ["cenc"],
            sessionTypes: ["temporary"],
            distinctiveIdentifier: "not-allowed",
            persistentState: "not-allowed"
          };
          return rxjs_1.of(new custom_key_system_access_1.default(keyType, new CustomMediaKeys(keyType), keySystemConfigurationResponse));
        }
      }

      return rxjs_1.throwError(undefined);
    };
  } else if (browser_compatibility_types_1.MediaKeys_ && browser_compatibility_types_1.MediaKeys_.prototype && typeof browser_compatibility_types_1.MediaKeys_.isTypeSupported === "function") {
    exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess = function requestMediaKeySystemAccess(keyType, keySystemConfigurations) {
      // TODO Why TS Do not understand that isTypeSupported exists here?
      if (!browser_compatibility_types_1.MediaKeys_.isTypeSupported(keyType)) {
        return rxjs_1.throwError(undefined);
      }

      for (var i = 0; i < keySystemConfigurations.length; i++) {
        var keySystemConfiguration = keySystemConfigurations[i];
        var videoCapabilities = keySystemConfiguration.videoCapabilities,
            audioCapabilities = keySystemConfiguration.audioCapabilities,
            initDataTypes = keySystemConfiguration.initDataTypes,
            distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier;
        var supported = true;
        supported = supported && (!initDataTypes || !!initDataTypes.filter(function (idt) {
          return idt === "cenc";
        })[0]);
        supported = supported && distinctiveIdentifier !== "required";

        if (supported) {
          var keySystemConfigurationResponse = {
            videoCapabilities: videoCapabilities,
            audioCapabilities: audioCapabilities,
            initDataTypes: ["cenc"],
            distinctiveIdentifier: "not-allowed",
            persistentState: "required",
            sessionTypes: ["temporary", "persistent-license"]
          };
          return rxjs_1.of(new custom_key_system_access_1.default(keyType, new browser_compatibility_types_1.MediaKeys_(keyType), keySystemConfigurationResponse));
        }
      }

      return rxjs_1.throwError(undefined);
    };

    if (browser_detection_1.isIE11 && typeof browser_compatibility_types_1.MediaKeys_.prototype.createSession === "function") {
      var IE11MediaKeySession =
      /*#__PURE__*/
      function (_event_emitter_1$defa2) {
        _inherits(IE11MediaKeySession, _event_emitter_1$defa2);

        function IE11MediaKeySession(mk) {
          var _this5;

          _classCallCheck(this, IE11MediaKeySession);

          _this5 = _possibleConstructorReturn(this, _getPrototypeOf(IE11MediaKeySession).call(this));
          _this5.sessionId = "";
          _this5.expiration = NaN;
          _this5.keyStatuses = new Map();
          _this5._mk = mk;
          _this5._closeSession$ = new rxjs_1.Subject();
          _this5.closed = new promise_1.default(function (resolve) {
            _this5._closeSession$.subscribe(resolve);
          });
          _this5.update = wrapUpdate(function (license, sessionId) {
            if (!_this5._ss) {
              throw new Error("MediaKeySession not set");
            }

            _this5._ss.update(license, sessionId);

            _this5.sessionId = sessionId;
          });
          return _this5;
        }

        _createClass(IE11MediaKeySession, [{
          key: "generateRequest",
          value: function generateRequest(_initDataType, initData) {
            var _this6 = this;

            return new promise_1.default(function (resolve) {
              _this6._ss = _this6._mk.createSession("video/mp4", initData);
              rxjs_1.merge(events.onKeyMessage$(_this6._ss), events.onKeyAdded$(_this6._ss), events.onKeyError$(_this6._ss)).pipe(operators_1.takeUntil(_this6._closeSession$)).subscribe(function (evt) {
                return _this6.trigger(evt.type, evt);
              });
              resolve();
            });
          }
        }, {
          key: "close",
          value: function close() {
            var _this7 = this;

            return new promise_1.default(function (resolve) {
              if (_this7._ss) {
                /* tslint:disable no-floating-promises */
                _this7._ss.close();
                /* tslint:enable no-floating-promises */


                _this7._ss = undefined;
              }

              _this7._closeSession$.next();

              _this7._closeSession$.complete();

              resolve();
            });
          }
        }, {
          key: "load",
          value: function load() {
            return promise_1.default.resolve(false);
          }
        }, {
          key: "remove",
          value: function remove() {
            return promise_1.default.resolve();
          }
        }]);

        return IE11MediaKeySession;
      }(event_emitter_1.default);

      exports.createSession = createSession = function createIE11MediaKeySession(mediaKeys) {
        return new IE11MediaKeySession(mediaKeys);
      };
    }
  }
}

exports.default = CustomMediaKeys;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../utils/byte_parsing":"../../../utils/byte_parsing.ts","../../utils/cast_to_observable":"../../../utils/cast_to_observable.ts","../../utils/event_emitter":"../../../utils/event_emitter.ts","../../utils/promise":"../../../utils/promise.ts","../browser_compatibility_types":"../../../compat/browser_compatibility_types.ts","../browser_detection":"../../../compat/browser_detection.ts","../event_listeners":"../../../compat/event_listeners.ts","../should_use_webkit_media_keys":"../../../compat/should_use_webkit_media_keys.ts","./custom_key_system_access":"../../../compat/eme/custom_key_system_access.ts"}],"../../../compat/eme/constants.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var byte_parsing_1 = require("../../utils/byte_parsing"); // The way "pssh" will be written in ISOBMFF files


exports.PSSH_TO_INTEGER = byte_parsing_1.be4toi(byte_parsing_1.strToBytes("pssh"), 0);
},{"../../utils/byte_parsing":"../../../utils/byte_parsing.ts"}],"../../../compat/eme/generate_key_request.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var log_1 = __importDefault(require("../../log"));

var byte_parsing_1 = require("../../utils/byte_parsing");

var cast_to_observable_1 = __importDefault(require("../../utils/cast_to_observable"));

var browser_detection_1 = require("../browser_detection");

var constants_1 = require("./constants");
/**
 * Some browsers have problems when the CENC PSSH box is the first managed PSSH
 * encountered (for the moment just Edge was noted with this behavior).
 *
 * This function tries to move CENC PSSH boxes at the end of the given init
 * data.
 *
 * If the initData is unrecognized or if a CENC PSSH is not found, this function
 * throws.
 * @param {Uint8Array} initData - Initialization data you want to patch
 * @returns {Uint8Array} - Initialization data, patched
 */


function patchInitData(initData) {
  var initialLength = initData.byteLength;
  log_1.default.info("Compat: Trying to move CENC PSSH from init data at the end of it.");
  var cencs = new Uint8Array();
  var resInitData = new Uint8Array();
  var offset = 0;

  while (offset < initData.length) {
    if (initData.length < offset + 8 || byte_parsing_1.be4toi(initData, offset + 4) !== constants_1.PSSH_TO_INTEGER) {
      log_1.default.warn("Compat: unrecognized initialization data. Cannot patch it.");
      throw new Error("Compat: unrecognized initialization data. Cannot patch it.");
    }

    var len = byte_parsing_1.be4toi(new Uint8Array(initData), offset);

    if (offset + len > initData.length) {
      log_1.default.warn("Compat: unrecognized initialization data. Cannot patch it.");
      throw new Error("Compat: unrecognized initialization data. Cannot patch it.");
    }

    var currentPSSH = initData.subarray(offset, offset + len); // yep

    if (initData[offset + 12] === 0x10 && initData[offset + 13] === 0x77 && initData[offset + 14] === 0xef && initData[offset + 15] === 0xec && initData[offset + 16] === 0xc0 && initData[offset + 17] === 0xb2 && initData[offset + 18] === 0x4d && initData[offset + 19] === 0x02 && initData[offset + 20] === 0xac && initData[offset + 21] === 0xe3 && initData[offset + 22] === 0x3c && initData[offset + 23] === 0x1e && initData[offset + 24] === 0x52 && initData[offset + 25] === 0xe2 && initData[offset + 26] === 0xfb && initData[offset + 27] === 0x4b) {
      log_1.default.info("Compat: CENC PSSH found.");
      cencs = byte_parsing_1.concat(cencs, currentPSSH);
    } else {
      resInitData = byte_parsing_1.concat(resInitData, currentPSSH);
    }

    offset += len;
  }

  if (offset !== initData.length) {
    log_1.default.warn("Compat: unrecognized initialization data. Cannot patch it.");
    throw new Error("Compat: unrecognized initialization data. Cannot patch it.");
  }

  if (resInitData.byteLength === initialLength) {
    log_1.default.warn("Compat: CENC PSSH not found. Cannot patch it");
    throw new Error("Compat: unrecognized initialization data. Cannot patch it.");
  }

  return byte_parsing_1.concat(resInitData, cencs);
}

exports.patchInitData = patchInitData;
/**
 * Generate a request from session.
 * @param {MediaKeySession}Â session - MediaKeySession on which the request will
 * be done.
 * @param {Uint8Array}Â initData - Initialization data given e.g. by the
 * "encrypted" event for the corresponding request.
 * @param {string} initDataType - Initialization data type given e.g. by the
 * "encrypted" event for the corresponding request.
 * @param {string} sessionType - Type of session you want to generate. Consult
 * EME Specification for more information on session types.
 * @returns {Observable} - Emit when done. Errors if fails.
 */

function generateKeyRequest(session, initData, initDataType) {
  return rxjs_1.defer(function () {
    log_1.default.debug("Compat: Calling generateRequest on the MediaKeySession");
    var patchedInit;

    if (browser_detection_1.isIEOrEdge) {
      try {
        patchedInit = patchInitData(initData);
      } catch (_e) {
        patchedInit = initData;
      }
    } else {
      patchedInit = initData;
    }

    return cast_to_observable_1.default(session.generateRequest(initDataType || "", patchedInit));
  });
}

exports.default = generateKeyRequest;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","../../log":"../../../log.ts","../../utils/byte_parsing":"../../../utils/byte_parsing.ts","../../utils/cast_to_observable":"../../../utils/cast_to_observable.ts","../browser_detection":"../../../compat/browser_detection.ts","./constants":"../../../compat/eme/constants.ts"}],"../../../utils/hash_buffer.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Convert given buffer to a 32bit integer hash
 * @param {Array.<number>|TypedArray} buffer
 * @returns {number}
 */

function hashBuffer(buffer) {
  var hash = 0;
  var char;

  for (var i = 0; i < buffer.length; i++) {
    char = buffer[i];
    hash = (hash << 5) - hash + char;
    hash = hash & hash; // Convert to 32bit integer
  }

  return hash;
}

exports.default = hashBuffer;
},{}],"../../../utils/simple_set.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Simple hash-based set.
 * @class SimpleSet
 */

var SimpleSet =
/*#__PURE__*/
function () {
  function SimpleSet() {
    _classCallCheck(this, SimpleSet);

    this._hashes = {};
  }
  /**
   * Add a new hash entry in the set.
   * Do not have any effect on already-added hashes
   * @param {string|number} x
   */


  _createClass(SimpleSet, [{
    key: "add",
    value: function add(x) {
      this._hashes[x] = true;
    }
    /**
     * Remove an hash entry from the set.
     * Do not have any effect on already-removed or inexistant hashes
     * @param {string|number} x
     */

  }, {
    key: "remove",
    value: function remove(x) {
      delete this._hashes[x];
    }
    /**
     * Test if the given hash has an entry in the set.
     * @param {string|number} x
     * @returns {boolean}
     */

  }, {
    key: "test",
    value: function test(x) {
      return !!this._hashes[x];
    }
    /**
     * Returns true if there's currently no hash in this set.
     * @returns {boolean}
     */

  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return !Object.keys(this._hashes).length;
    }
  }]);

  return SimpleSet;
}();

exports.default = SimpleSet;
},{}],"../../../compat/eme/get_init_data.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var errors_1 = require("../../errors");

var log_1 = __importDefault(require("../../log"));

var byte_parsing_1 = require("../../utils/byte_parsing");

var hash_buffer_1 = __importDefault(require("../../utils/hash_buffer"));

var simple_set_1 = __importDefault(require("../../utils/simple_set"));

var constants_1 = require("./constants");
/**
 * As we observed on some browsers (IE and Edge), the initialization data on
 * some segments have sometimes duplicated PSSH when sent through an encrypted
 * event (but not when pushed to the SourceBuffer).
 *
 * This function tries to guess if the initialization data contains only PSSHs
 * concatenated (as it is usually the case).
 * If that's the case, it will filter duplicated PSSHs from it.
 *
 * @param {Uint8Array} initData - Raw initialization data
 * @returns {Uint8Array} - Initialization data, "cleaned"
 */


function cleanEncryptedEvent(initData) {
  var resInitData = new Uint8Array();
  var currentHashes = new simple_set_1.default();
  var offset = 0;

  while (offset < initData.length) {
    if (initData.length < offset + 8 || byte_parsing_1.be4toi(initData, offset + 4) !== constants_1.PSSH_TO_INTEGER) {
      log_1.default.warn("Compat: Unrecognized initialization data. Use as is.");
      return initData;
    }

    var len = byte_parsing_1.be4toi(new Uint8Array(initData), offset);

    if (offset + len > initData.length) {
      log_1.default.warn("Compat: Unrecognized initialization data. Use as is.");
      return initData;
    }

    var currentPSSH = initData.subarray(offset, offset + len);
    var currentPSSHHash = hash_buffer_1.default(currentPSSH);

    if (!currentHashes.test(currentPSSHHash)) {
      currentHashes.add(currentPSSHHash);
      resInitData = byte_parsing_1.concat(resInitData, currentPSSH);
    } else {
      log_1.default.warn("Compat: Duplicated PSSH found in initialization data, removing it.");
    }

    offset += len;
  }

  if (offset !== initData.length) {
    log_1.default.warn("Compat: Unrecognized initialization data. Use as is.");
    return initData;
  }

  return resInitData;
}
/**
 * Take out the two things we need on an encryptedEvent:
 *   - the initialization Data
 *   - the initialization Data type
 *
 * @param {MediaEncryptedEvent} encryptedEvent - Payload received with an
 * "encrypted" event.
 * @returns {Object} - Initialization data and Initialization data type.
 * @throws {EncryptedMediaError} - Throws if no initialization data is
 * encountered in the given event.
 */


function getInitData(encryptedEvent) {
  var initData = encryptedEvent.initData;

  if (initData == null) {
    throw new errors_1.EncryptedMediaError("INVALID_ENCRYPTED_EVENT", "Compat: No init data found on media encrypted event.");
  }

  var initDataBytes = new Uint8Array(initData);
  return {
    initData: cleanEncryptedEvent(initDataBytes),
    initDataType: encryptedEvent.initDataType
  };
}

exports.default = getInitData;
},{"../../errors":"../../../errors/index.ts","../../log":"../../../log.ts","../../utils/byte_parsing":"../../../utils/byte_parsing.ts","../../utils/hash_buffer":"../../../utils/hash_buffer.ts","../../utils/simple_set":"../../../utils/simple_set.ts","./constants":"../../../compat/eme/constants.ts"}],"../../../compat/eme/set_media_keys.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var cast_to_observable_1 = __importDefault(require("../../utils/cast_to_observable"));

var custom_media_keys_1 = __importDefault(require("./custom_media_keys"));
/**
 * Set the MediaKeys given on the media element.
 * @param {HTMLMediaElement} elt
 * @param {Object} mediaKeys
 * @returns {*}
 */


function _setMediaKeys(elt, mediaKeys) {
  if (mediaKeys instanceof custom_media_keys_1.default) {
    return mediaKeys._setVideo(elt);
  }

  if (elt.setMediaKeys) {
    return elt.setMediaKeys(mediaKeys);
  }

  if (mediaKeys === null) {
    return;
  }

  if (elt.WebkitSetMediaKeys) {
    return elt.WebkitSetMediaKeys(mediaKeys);
  }

  if (elt.mozSetMediaKeys) {
    return elt.mozSetMediaKeys(mediaKeys);
  }

  if (elt.msSetMediaKeys) {
    return elt.msSetMediaKeys(mediaKeys);
  }
}
/**
 * Set the given MediaKeys on the given HTMLMediaElement.
 * Emits null when done then complete.
 * @param {HTMLMediaElement} elt
 * @param {Object} mediaKeys
 * @returns {Observable}
 */


function setMediaKeys$(elt, mediaKeys) {
  return rxjs_1.defer(function () {
    return cast_to_observable_1.default(_setMediaKeys(elt, mediaKeys));
  });
}

exports.default = setMediaKeys$;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","../../utils/cast_to_observable":"../../../utils/cast_to_observable.ts","./custom_media_keys":"../../../compat/eme/custom_media_keys.ts"}],"../../../compat/eme/index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var custom_key_system_access_1 = __importStar(require("./custom_key_system_access"));

exports.CustomMediaKeySystemAccess = custom_key_system_access_1.default;
exports.ICustomMediaKeySystemAccess = custom_key_system_access_1.ICustomMediaKeySystemAccess;

var custom_media_keys_1 = require("./custom_media_keys");

exports.createSession = custom_media_keys_1.createSession;
exports.ICustomMediaKeys = custom_media_keys_1.ICustomMediaKeys;
exports.ICustomMediaKeySession = custom_media_keys_1.ICustomMediaKeySession;
exports.requestMediaKeySystemAccess = custom_media_keys_1.requestMediaKeySystemAccess;

var generate_key_request_1 = __importDefault(require("./generate_key_request"));

exports.generateKeyRequest = generate_key_request_1.default;

var get_init_data_1 = __importDefault(require("./get_init_data"));

exports.getInitData = get_init_data_1.default;

var set_media_keys_1 = __importDefault(require("./set_media_keys"));

exports.setMediaKeys = set_media_keys_1.default;
},{"./custom_key_system_access":"../../../compat/eme/custom_key_system_access.ts","./custom_media_keys":"../../../compat/eme/custom_media_keys.ts","./generate_key_request":"../../../compat/eme/generate_key_request.ts","./get_init_data":"../../../compat/eme/get_init_data.ts","./set_media_keys":"../../../compat/eme/set_media_keys.ts"}],"../../../compat/fullscreen.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Request fullScreen action on a given element.
 * @param {HTMLElement} elt
 * rs-detect)
 */

function requestFullscreen(element) {
  if (!isFullscreen()) {
    var elt = element;

    if (elt.requestFullscreen) {
      /* tslint:disable no-floating-promises */
      elt.requestFullscreen();
      /* tslint:enable no-floating-promises */
    } else if (elt.msRequestFullscreen) {
      elt.msRequestFullscreen();
    } else if (elt.mozRequestFullScreen) {
      elt.mozRequestFullScreen();
    } else if (elt.webkitRequestFullscreen) {
      elt.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
    }
  }
}

exports.requestFullscreen = requestFullscreen;
/**
 * Exit fullscreen if an element is currently in fullscreen.
 */

function exitFullscreen() {
  if (isFullscreen()) {
    var doc = document;

    if (doc.exitFullscreen) {
      /* tslint:disable no-floating-promises */
      doc.exitFullscreen();
      /* tslint:enable no-floating-promises */
    } else if (doc.msExitFullscreen) {
      doc.msExitFullscreen();
    } else if (doc.mozCancelFullScreen) {
      doc.mozCancelFullScreen();
    } else if (doc.webkitExitFullscreen) {
      doc.webkitExitFullscreen();
    }
  }
}

exports.exitFullscreen = exitFullscreen;
/**
 * Returns true if an element in the document is being displayed in fullscreen
 * mode;
 * otherwise it's false.
 * @returns {boolean}
 */

function isFullscreen() {
  var doc = document;
  return !!(doc.fullscreenElement || doc.mozFullScreenElement || doc.webkitFullscreenElement || doc.msFullscreenElement);
}

exports.isFullscreen = isFullscreen;
},{}],"../../../compat/has_eme_apis.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var eme_1 = require("./eme");
/**
 * Returns true if the browser has the minimum needed EME APIs to decrypt a
 * content.
 * @returns {Boolean}
 */


function hasEMEAPIs() {
  return typeof eme_1.requestMediaKeySystemAccess === "function";
}

exports.default = hasEMEAPIs;
},{"./eme":"../../../compat/eme/index.ts"}],"../../../compat/is_codec_supported.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var browser_compatibility_types_1 = require("./browser_compatibility_types");
/**
 * Returns true if the given codec is supported by the browser's MediaSource
 * implementation.
 * @returns {Boolean}
 */


function isCodecSupported(codec) {
  if (!browser_compatibility_types_1.MediaSource_) {
    return false;
  }
  /* tslint:disable no-unbound-method */


  if (typeof browser_compatibility_types_1.MediaSource_.isTypeSupported === "function") {
    /* tslint:enable no-unbound-method */
    return browser_compatibility_types_1.MediaSource_.isTypeSupported(codec);
  }

  return true;
}

exports.default = isCodecSupported;
},{"./browser_compatibility_types":"../../../compat/browser_compatibility_types.ts"}],"../../../compat/is_playback_stuck.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var browser_detection_1 = require("./browser_detection");
/**
 * firefox fix: sometimes playback can be stalled, even if we are in a buffer.
 * TODO This seems to be about an old Firefox version. Delete it?
 * @param {number} time
 * @param {Object|null} currentRange
 * @param {string} state
 * @param {Boolean} isStalled
 * @returns {Boolean}
 */


function isPlaybackStuck(time, currentRange, state, isStalled) {
  var FREEZE_THRESHOLD = 10; // freeze threshold in seconds

  return browser_detection_1.isFirefox && isStalled && state === "timeupdate" && !!currentRange && currentRange.end - time > FREEZE_THRESHOLD;
}

exports.default = isPlaybackStuck;
},{"./browser_detection":"../../../compat/browser_detection.ts"}],"../../../compat/is_vtt_cue.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Returns true if the given cue is an instance of a VTTCue.
 * @param {*} cue
 * @returns {boolean}
 */

function isVTTCue(cue) {
  return typeof window.VTTCue === "function" && cue instanceof window.VTTCue;
}

exports.default = isVTTCue;
},{}],"../../../compat/make_vtt_cue.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../log"));

var browser_compatibility_types_1 = require("./browser_compatibility_types");
/**
 * Creates a cue using the best platform-specific interface available.
 *
 * @param {Number} startTime
 * @param {Number} endTime
 * @param {string} payload
 * @returns {VTTCue|TextTrackCue|null} Text track cue or null if the parameters
 * were invalid.
 */


function makeCue(startTime, endTime, payload) {
  if (!browser_compatibility_types_1.VTTCue_) {
    throw new Error("VTT cues not supported in your target");
  }

  if (startTime >= endTime) {
    // IE/Edge will throw in this case.
    // See issue #501
    log_1.default.warn("Compat: Invalid cue times: " + startTime + " - " + endTime);
    return null;
  }

  return new browser_compatibility_types_1.VTTCue_(startTime, endTime, payload);
}

exports.default = makeCue;
},{"../log":"../../../log.ts","./browser_compatibility_types":"../../../compat/browser_compatibility_types.ts"}],"../../../../../../../.config/yarn/global/node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"../../../../node_modules/next-tick/index.js":[function(require,module,exports) {
var process = require("process");
'use strict';

var callable, byObserver;

callable = function (fn) {
	if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
	return fn;
};

byObserver = function (Observer) {
	var node = document.createTextNode(''), queue, currentQueue, i = 0;
	new Observer(function () {
		var callback;
		if (!queue) {
			if (!currentQueue) return;
			queue = currentQueue;
		} else if (currentQueue) {
			queue = currentQueue.concat(queue);
		}
		currentQueue = queue;
		queue = null;
		if (typeof currentQueue === 'function') {
			callback = currentQueue;
			currentQueue = null;
			callback();
			return;
		}
		node.data = (i = ++i % 2); // Invoke other batch, to handle leftover callbacks in case of crash
		while (currentQueue) {
			callback = currentQueue.shift();
			if (!currentQueue.length) currentQueue = null;
			callback();
		}
	}).observe(node, { characterData: true });
	return function (fn) {
		callable(fn);
		if (queue) {
			if (typeof queue === 'function') queue = [queue, fn];
			else queue.push(fn);
			return;
		}
		queue = fn;
		node.data = (i = ++i % 2);
	};
};

module.exports = (function () {
	// Node.js
	if ((typeof process === 'object') && process && (typeof process.nextTick === 'function')) {
		return process.nextTick;
	}

	// MutationObserver
	if ((typeof document === 'object') && document) {
		if (typeof MutationObserver === 'function') return byObserver(MutationObserver);
		if (typeof WebKitMutationObserver === 'function') return byObserver(WebKitMutationObserver);
	}

	// W3C Draft
	// http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
	if (typeof setImmediate === 'function') {
		return function (cb) { setImmediate(callable(cb)); };
	}

	// Wide available standard
	if ((typeof setTimeout === 'function') || (typeof setTimeout === 'object')) {
		return function (cb) { setTimeout(callable(cb), 0); };
	}

	return null;
}());

},{"process":"../../../../../../../.config/yarn/global/node_modules/process/browser.js"}],"../../../compat/patch_webkit_source_buffer.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var next_tick_1 = __importDefault(require("next-tick"));

var event_emitter_1 = __importDefault(require("../utils/event_emitter")); // TODO This is the last ugly side-effect here.
// Either remove it or find the best way to implement that


function patchWebkitSourceBuffer() {
  // old WebKit SourceBuffer implementation,
  // where a synchronous append is used instead of appendBuffer
  if (window.WebKitSourceBuffer && !window.WebKitSourceBuffer.prototype.addEventListener) {
    var sourceBufferWebkitRef = window.WebKitSourceBuffer;
    var sourceBufferWebkitProto = sourceBufferWebkitRef.prototype;

    for (var fnName in event_emitter_1.default.prototype) {
      if (event_emitter_1.default.prototype.hasOwnProperty(fnName)) {
        sourceBufferWebkitProto[fnName] = event_emitter_1.default.prototype[fnName];
      }
    }

    sourceBufferWebkitProto._listeners = [];

    sourceBufferWebkitProto.__emitUpdate = function (eventName, val) {
      var _this = this;

      next_tick_1.default(function () {
        /* tslint:disable no-invalid-this */
        _this.trigger(eventName, val);

        _this.updating = false;

        _this.trigger("updateend");
        /* tslint:enable no-invalid-this */

      });
    };

    sourceBufferWebkitProto.appendBuffer = function (data) {
      /* tslint:disable no-invalid-this */
      if (this.updating) {
        throw new Error("updating");
      }

      this.trigger("updatestart");
      this.updating = true;

      try {
        this.append(data);
      } catch (error) {
        this.__emitUpdate("error", error);

        return;
      }

      this.__emitUpdate("update");
      /* tslint:enable no-invalid-this */

    };
  }
}

exports.default = patchWebkitSourceBuffer;
},{"next-tick":"../../../../node_modules/next-tick/index.js","../utils/event_emitter":"../../../utils/event_emitter.ts"}],"../../../utils/rx-try_catch.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");
/**
 * @param {Function} func - A function you want to execute
 * @param {*} args - The function's argument
 * @returns {*} - If it fails, returns a throwing Observable, else the
 * function's result (which should be, in most cases, an Observable).
 */


function tryCatch(func, args) {
  try {
    return func(args);
  } catch (e) {
    return rxjs_1.throwError(e);
  }
}

exports.default = tryCatch;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js"}],"../../../compat/play.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var cast_to_observable_1 = __importDefault(require("../utils/cast_to_observable"));

var rx_try_catch_1 = __importDefault(require("../utils/rx-try_catch"));
/**
 * Call play on the media element on subscription and return the response as an
 * observable.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */


function play$(mediaElement) {
  return rxjs_1.defer(function () {
    return (// mediaElement.play is not always a Promise. In the improbable case it
      // throws, I prefer still to catch to return the error wrapped in an
      // Observable
      rx_try_catch_1.default(function () {
        return cast_to_observable_1.default(mediaElement.play());
      }, undefined)
    );
  });
}

exports.default = play$;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","../utils/cast_to_observable":"../../../utils/cast_to_observable.ts","../utils/rx-try_catch":"../../../utils/rx-try_catch.ts"}],"../../../compat/set_element_src.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var log_1 = __importDefault(require("../log"));

var clear_element_src_1 = __importDefault(require("./clear_element_src"));
/**
 * Set an URL to the element's src.
 * Emit ``undefined`` when done.
 * Unlink src on unsubscription.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {string} url
 * @returns {Observable}
 */


function setElementSrc$(mediaElement, url) {
  return new rxjs_1.Observable(function (observer) {
    log_1.default.info("Setting URL to Element", url, mediaElement);
    mediaElement.src = url;
    observer.next(undefined);
    return function () {
      clear_element_src_1.default(mediaElement);
    };
  });
}

exports.default = setElementSrc$;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","../log":"../../../log.ts","./clear_element_src":"../../../compat/clear_element_src.ts"}],"../../../compat/should_renew_media_keys.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var browser_detection_1 = require("./browser_detection");
/**
 * Returns true if the current target require the media keys to be renewed on
 * each content.
 * @returns {Boolean}
 */


function shouldRenewMediaKeys() {
  return browser_detection_1.isIE11;
}

exports.default = shouldRenewMediaKeys;
},{"./browser_detection":"../../../compat/browser_detection.ts"}],"../../../compat/should_unset_media_keys.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var browser_detection_1 = require("./browser_detection");
/**
 * Returns true if the mediakeys associated to a media element should be
 * unset once the content is stopped.
 * Depends on the target.
 * @returns {Boolean}
 */


function shouldUnsetMediaKeys() {
  return browser_detection_1.isIE11;
}

exports.default = shouldUnsetMediaKeys;
},{"./browser_detection":"../../../compat/browser_detection.ts"}],"../../../compat/should_validate_metadata.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var browser_detection_1 = require("./browser_detection");
/**
 * Returns true if the metadata received after a "loadedmetadata" event has
 * to be validated in the current browser (which means that we do not trust
 * this event on these browsers).
 * @returns {boolean}
 */


function shouldValidateMetadata() {
  return browser_detection_1.isSamsungBrowser;
}

exports.default = shouldValidateMetadata;
},{"./browser_detection":"../../../compat/browser_detection.ts"}],"../../../compat/when_loaded_metadata.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var browser_compatibility_types_1 = require("./browser_compatibility_types");

var event_listeners_1 = require("./event_listeners");
/**
 * Returns an observable emitting a single time, as soon as a seek is possible
 * (the metadata are loaded).
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */


function whenLoadedMetadata$(mediaElement) {
  if (mediaElement.readyState >= browser_compatibility_types_1.READY_STATES.HAVE_METADATA) {
    return rxjs_1.of(null);
  } else {
    return event_listeners_1.onLoadedMetadata$(mediaElement).pipe(operators_1.take(1));
  }
}

exports.default = whenLoadedMetadata$;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","./browser_compatibility_types":"../../../compat/browser_compatibility_types.ts","./event_listeners":"../../../compat/event_listeners.ts"}],"../../../compat/when_media_source_open.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var event_listeners_1 = require("./event_listeners");
/**
 * Wait for the MediaSource's sourceopen event and emit. Emit immediatelly if
 * already received.
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */


function whenMediaSourceOpen$(mediaSource) {
  if (mediaSource.readyState === "open") {
    return rxjs_1.of(null);
  } else {
    return event_listeners_1.onSourceOpen$(mediaSource).pipe(operators_1.take(1));
  }
}

exports.default = whenMediaSourceOpen$;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","./event_listeners":"../../../compat/event_listeners.ts"}],"../../../compat/index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var add_text_track_1 = __importDefault(require("./add_text_track"));

exports.addTextTrack = add_text_track_1.default;

var browser_compatibility_types_1 = require("./browser_compatibility_types");

exports.ICompatMediaKeySystemAccess = browser_compatibility_types_1.ICompatMediaKeySystemAccess;
exports.ICompatMediaKeySystemConfiguration = browser_compatibility_types_1.ICompatMediaKeySystemConfiguration;
exports.ICompatTextTrack = browser_compatibility_types_1.ICompatTextTrack;
exports.ICompatVTTCue = browser_compatibility_types_1.ICompatVTTCue;
exports.MediaSource_ = browser_compatibility_types_1.MediaSource_;
exports.VTTCue_ = browser_compatibility_types_1.VTTCue_;

var can_patch_isobmff_1 = __importDefault(require("./can_patch_isobmff"));

exports.canPatchISOBMFFSegment = can_patch_isobmff_1.default;

var change_source_buffer_type_1 = __importStar(require("./change_source_buffer_type"));

exports.tryToChangeSourceBufferType = change_source_buffer_type_1.default;
exports.ICustomSourceBuffer = change_source_buffer_type_1.ICustomSourceBuffer;

var clear_element_src_1 = __importDefault(require("./clear_element_src"));

exports.clearElementSrc = clear_element_src_1.default;

var eme_1 = require("./eme");

exports.createSession = eme_1.createSession;
exports.CustomMediaKeySystemAccess = eme_1.CustomMediaKeySystemAccess;
exports.generateKeyRequest = eme_1.generateKeyRequest;
exports.getInitData = eme_1.getInitData;
exports.ICustomMediaKeys = eme_1.ICustomMediaKeys;
exports.ICustomMediaKeySession = eme_1.ICustomMediaKeySession;
exports.ICustomMediaKeySystemAccess = eme_1.ICustomMediaKeySystemAccess;
exports.requestMediaKeySystemAccess = eme_1.requestMediaKeySystemAccess;
exports.setMediaKeys = eme_1.setMediaKeys;

var events = __importStar(require("./event_listeners"));

exports.events = events;

var fullscreen_1 = require("./fullscreen");

exports.exitFullscreen = fullscreen_1.exitFullscreen;
exports.isFullscreen = fullscreen_1.isFullscreen;
exports.requestFullscreen = fullscreen_1.requestFullscreen;

var has_eme_apis_1 = __importDefault(require("./has_eme_apis"));

exports.hasEMEAPIs = has_eme_apis_1.default;

var is_codec_supported_1 = __importDefault(require("./is_codec_supported"));

exports.isCodecSupported = is_codec_supported_1.default;

var is_offline_1 = __importDefault(require("./is_offline"));

exports.isOffline = is_offline_1.default;

var is_playback_stuck_1 = __importDefault(require("./is_playback_stuck"));

exports.isPlaybackStuck = is_playback_stuck_1.default;

var is_vtt_cue_1 = __importDefault(require("./is_vtt_cue"));

exports.isVTTCue = is_vtt_cue_1.default;

var make_vtt_cue_1 = __importDefault(require("./make_vtt_cue"));

exports.makeVTTCue = make_vtt_cue_1.default;

var patch_webkit_source_buffer_1 = __importDefault(require("./patch_webkit_source_buffer"));

var play_1 = __importDefault(require("./play"));

exports.play$ = play_1.default;

var set_element_src_1 = __importDefault(require("./set_element_src"));

exports.setElementSrc$ = set_element_src_1.default;

var should_renew_media_keys_1 = __importDefault(require("./should_renew_media_keys"));

exports.shouldRenewMediaKeys = should_renew_media_keys_1.default;

var should_unset_media_keys_1 = __importDefault(require("./should_unset_media_keys"));

exports.shouldUnsetMediaKeys = should_unset_media_keys_1.default;

var should_validate_metadata_1 = __importDefault(require("./should_validate_metadata"));

exports.shouldValidateMetadata = should_validate_metadata_1.default;

var when_loaded_metadata_1 = __importDefault(require("./when_loaded_metadata"));

exports.whenLoadedMetadata$ = when_loaded_metadata_1.default;

var when_media_source_open_1 = __importDefault(require("./when_media_source_open"));

exports.whenMediaSourceOpen$ = when_media_source_open_1.default; // TODO TO REMOVE

patch_webkit_source_buffer_1.default();
},{"./add_text_track":"../../../compat/add_text_track.ts","./browser_compatibility_types":"../../../compat/browser_compatibility_types.ts","./can_patch_isobmff":"../../../compat/can_patch_isobmff.ts","./change_source_buffer_type":"../../../compat/change_source_buffer_type.ts","./clear_element_src":"../../../compat/clear_element_src.ts","./eme":"../../../compat/eme/index.ts","./event_listeners":"../../../compat/event_listeners.ts","./fullscreen":"../../../compat/fullscreen.ts","./has_eme_apis":"../../../compat/has_eme_apis.ts","./is_codec_supported":"../../../compat/is_codec_supported.ts","./is_offline":"../../../compat/is_offline.ts","./is_playback_stuck":"../../../compat/is_playback_stuck.ts","./is_vtt_cue":"../../../compat/is_vtt_cue.ts","./make_vtt_cue":"../../../compat/make_vtt_cue.ts","./patch_webkit_source_buffer":"../../../compat/patch_webkit_source_buffer.ts","./play":"../../../compat/play.ts","./set_element_src":"../../../compat/set_element_src.ts","./should_renew_media_keys":"../../../compat/should_renew_media_keys.ts","./should_unset_media_keys":"../../../compat/should_unset_media_keys.ts","./should_validate_metadata":"../../../compat/should_validate_metadata.ts","./when_loaded_metadata":"../../../compat/when_loaded_metadata.ts","./when_media_source_open":"../../../compat/when_media_source_open.ts"}],"../../../core/eme/create_session.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var log_1 = __importDefault(require("../../log"));

var array_includes_1 = __importDefault(require("../../utils/array_includes"));

var cast_to_observable_1 = __importDefault(require("../../utils/cast_to_observable"));
/**
 * If session creating fails, retry once session creation/loading.
 * Emit true, if it has succeeded to load, false if there is no data for the
 * given sessionId.
 * @param {string} sessionId
 * @param {MediaKeySession} session
 * @returns {Observable}
 */


function loadPersistentSession(sessionId, session) {
  return rxjs_1.defer(function () {
    log_1.default.debug("EME: Load persisted session", sessionId);
    return cast_to_observable_1.default(session.load(sessionId));
  });
}
/**
 * Create a new Session on the given MediaKeys, corresponding to the given
 * initializationData.
 * If session creating fails, remove the oldest MediaKeySession loaded and
 * retry.
 *
 * /!\ This only creates new sessions.
 * It will fail if sessionsStore already has a MediaKeySession with
 * the given initializationData.
 * @param {Uint8Array} initData
 * @param {string|undefined} initDataType
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */


function createSession(initData, initDataType, mediaKeysInfos) {
  return rxjs_1.defer(function () {
    var keySystemOptions = mediaKeysInfos.keySystemOptions,
        mediaKeySystemAccess = mediaKeysInfos.mediaKeySystemAccess,
        sessionsStore = mediaKeysInfos.sessionsStore,
        sessionStorage = mediaKeysInfos.sessionStorage;
    var mksConfig = mediaKeySystemAccess.getConfiguration();
    var sessionTypes = mksConfig.sessionTypes;
    var hasPersistence = sessionTypes && array_includes_1.default(sessionTypes, "persistent-license");
    var sessionType = hasPersistence && sessionStorage && keySystemOptions.persistentLicense ? "persistent-license" : "temporary";
    log_1.default.debug("EME: Create a new ".concat(sessionType, " session"));
    var session = sessionsStore.createSession(initData, initDataType, sessionType); // Re-check for Dumb typescript. Equivalent to `sessionType === "temporary"`.

    if (!hasPersistence || !sessionStorage || !keySystemOptions.persistentLicense) {
      return rxjs_1.of({
        type: "created-session",
        value: {
          mediaKeySession: session,
          sessionType: sessionType
        }
      });
    }

    var storedEntry = sessionStorage.get(initData, initDataType);

    if (!storedEntry) {
      return rxjs_1.of({
        type: "created-session",
        value: {
          mediaKeySession: session,
          sessionType: sessionType
        }
      });
    }
    /**
     * Helper function to close and restart the current persistent session
     * considered, and re-create it from scratch.
     * @returns {Observable}
     */


    var recreatePersistentSession = function recreatePersistentSession() {
      log_1.default.info("EME: Removing previous persistent session.");

      if (sessionStorage.get(initData, initDataType) !== null) {
        sessionStorage.delete(initData, initDataType);
      }

      return sessionsStore.deleteAndCloseSession(session).pipe(operators_1.map(function () {
        var newSession = sessionsStore.createSession(initData, initDataType, sessionType);
        return {
          type: "created-session",
          value: {
            mediaKeySession: newSession,
            sessionType: sessionType
          }
        };
      }));
    };

    return loadPersistentSession(storedEntry.sessionId, session).pipe(operators_1.mergeMap(function (hasLoadedSession) {
      if (!hasLoadedSession) {
        log_1.default.warn("EME: No data stored for the loaded session");
        sessionStorage.delete(initData, initDataType);
        return rxjs_1.of({
          type: "created-session",
          value: {
            mediaKeySession: session,
            sessionType: sessionType
          }
        });
      } // TODO From our tests, we only get empty MediaKeyStatusesMap.
      // Find out if that's normal, and if we can bring back to life an
      // expired or internal-errored session.
      // If both are true, we can safely remove that part.
      // if (!isSessionUsable(session)) {
      //   // Unusable persistent session: recreate a new session from scratch.
      //   log.warn("EME: Previous persistent session not usable anymore.");
      //   return recreatePersistentSession();
      // }


      sessionStorage.add(initData, initDataType, session);
      log_1.default.info("EME: Succeeded to load persistent session.");
      return rxjs_1.of({
        type: "loaded-persistent-session",
        value: {
          mediaKeySession: session,
          sessionType: sessionType
        }
      });
    }), operators_1.catchError(function () {
      log_1.default.warn("EME: Unable to load persistent session.");
      return recreatePersistentSession();
    }));
  });
}

exports.default = createSession;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../log":"../../../log.ts","../../utils/array_includes":"../../../utils/array_includes.ts","../../utils/cast_to_observable":"../../../utils/cast_to_observable.ts"}],"../../../core/eme/utils/is_session_usable.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../../log"));

var array_includes_1 = __importDefault(require("../../../utils/array_includes"));
/**
 * If all key statuses attached to session are valid (either not
 * "expired" or "internal-error"), return true.
 * If not, return false.
 * @param {Uint8Array} initData
 * @param {MediaKeySession} loadedSession
 * @returns {MediaKeySession}
 */


function isSessionUsable(loadedSession) {
  if (loadedSession.sessionId === "") {
    return false;
  }

  var keyStatusesMap = loadedSession.keyStatuses;
  var keyStatuses = [];
  keyStatusesMap.forEach(function (keyStatus) {
    keyStatuses.push(keyStatus);
  });

  if (keyStatuses.length > 0 && !array_includes_1.default(keyStatuses, "expired") && !array_includes_1.default(keyStatuses, "internal-error")) {
    log_1.default.debug("EME: Reuse loaded session", loadedSession.sessionId);
    return true;
  }

  return false;
}

exports.default = isSessionUsable;
},{"../../../log":"../../../log.ts","../../../utils/array_includes":"../../../utils/array_includes.ts"}],"../../../core/eme/get_session.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var config_1 = __importDefault(require("../../config"));

var log_1 = __importDefault(require("../../log"));

var create_session_1 = __importDefault(require("./create_session"));

var is_session_usable_1 = __importDefault(require("./utils/is_session_usable"));

var MAX_SESSIONS = config_1.default.EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS;
/**
 * Handle MediaEncryptedEvents sent by a HTMLMediaElement:
 * Either create a session, recuperate a previous session and returns it or load
 * a persistent session.
 * @param {Event} encryptedEvent
 * @param {Object} handledInitData
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */

function getSession(encryptedEvent, mediaKeysInfos) {
  return rxjs_1.defer(function () {
    var initDataType = encryptedEvent.type,
        initData = encryptedEvent.data; // possible previous loaded session with the same initialization data

    var previousLoadedSession = null;
    var sessionsStore = mediaKeysInfos.sessionsStore;
    var entry = sessionsStore.get(initData, initDataType);

    if (entry != null) {
      previousLoadedSession = entry.session;

      if (is_session_usable_1.default(previousLoadedSession)) {
        log_1.default.debug("EME: Reuse loaded session", previousLoadedSession.sessionId);
        return rxjs_1.of({
          type: "loaded-open-session",
          value: {
            mediaKeySession: previousLoadedSession,
            sessionType: entry.sessionType,
            initData: initData,
            initDataType: initDataType
          }
        });
      } else if (mediaKeysInfos.sessionStorage) {
        mediaKeysInfos.sessionStorage.delete(new Uint8Array(initData), initDataType);
      }
    }

    return (previousLoadedSession ? sessionsStore.deleteAndCloseSession(previousLoadedSession) : rxjs_1.of(null)).pipe(operators_1.mergeMap(function () {
      var cleaningOldSessions$ = [];
      var entries = sessionsStore.getAll().slice();

      if (MAX_SESSIONS > 0 && MAX_SESSIONS <= entries.length) {
        for (var i = 0; i < MAX_SESSIONS - entries.length + 1; i++) {
          cleaningOldSessions$.push(sessionsStore.deleteAndCloseSession(entries[i].session));
        }
      }

      return rxjs_1.concat(rxjs_1.merge.apply(rxjs_1, cleaningOldSessions$).pipe(operators_1.ignoreElements()), create_session_1.default(initData, initDataType, mediaKeysInfos).pipe(operators_1.map(function (evt) {
        return {
          type: evt.type,
          value: {
            mediaKeySession: evt.value.mediaKeySession,
            sessionType: evt.value.sessionType,
            initData: initData,
            initDataType: initDataType
          }
        };
      })));
    }));
  });
}

exports.default = getSession;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../config":"../../../config.ts","../../log":"../../../log.ts","./create_session":"../../../core/eme/create_session.ts","./utils/is_session_usable":"../../../core/eme/utils/is_session_usable.ts"}],"../../../core/eme/media_keys_infos_store.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
}); // Store the MediaKeys infos attached to a media element.

var currentMediaState = new WeakMap();
exports.default = {
  /**
   * Update MediaKeys infos set on a HMTLMediaElement
   * @param {HTMLMediaElement} mediaElement
   * @param {Object} state
   */
  setState: function setState(mediaElement, state) {
    currentMediaState.set(mediaElement, state);
  },

  /**
   * Get MediaKeys infos currently set on a HMTLMediaElement
   * @param {HTMLMediaElement} mediaElement
   * @returns {Object}
   */
  getState: function getState(mediaElement) {
    return currentMediaState.get(mediaElement) || null;
  },

  /**
   * Remove MediaKeys infos currently set on a HMTLMediaElement
   * @param {HTMLMediaElement} mediaElement
   */
  clearState: function clearState(mediaElement) {
    currentMediaState.set(mediaElement, null);
  }
};
},{}],"../../../core/eme/attach_media_keys.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var compat_1 = require("../../compat");

var log_1 = __importDefault(require("../../log"));

var media_keys_infos_store_1 = __importDefault(require("./media_keys_infos_store"));
/**
 * Set the MediaKeys object on the HTMLMediaElement if it is not already on the
 * element.
 * If a MediaKeys was already set on it, dispose of it before setting the new
 * one.
 *
 * /!\ Mutates heavily MediaKeysInfosStore
 * @param {Object} mediaKeysInfos
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */


function attachMediaKeys(mediaKeysInfos, mediaElement) {
  return rxjs_1.defer(function () {
    var keySystemOptions = mediaKeysInfos.keySystemOptions,
        mediaKeySystemAccess = mediaKeysInfos.mediaKeySystemAccess,
        mediaKeys = mediaKeysInfos.mediaKeys,
        sessionsStore = mediaKeysInfos.sessionsStore;
    var previousState = media_keys_infos_store_1.default.getState(mediaElement);
    media_keys_infos_store_1.default.setState(mediaElement, {
      keySystemOptions: keySystemOptions,
      mediaKeySystemAccess: mediaKeySystemAccess,
      mediaKeys: mediaKeys,
      sessionsStore: sessionsStore
    });
    return (previousState && previousState.sessionsStore !== sessionsStore ? previousState.sessionsStore.closeAllSessions() : rxjs_1.of(null)).pipe(operators_1.mergeMap(function () {
      if (mediaElement.mediaKeys === mediaKeys) {
        return rxjs_1.of(null);
      }

      log_1.default.debug("EME: Setting MediaKeys");
      return compat_1.setMediaKeys(mediaElement, mediaKeys);
    }));
  });
}

exports.default = attachMediaKeys;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../compat":"../../../compat/index.ts","../../log":"../../../log.ts","./media_keys_infos_store":"../../../core/eme/media_keys_infos_store.ts"}],"../../../utils/flat_map.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Map each element using a mapping function, then flat the result into
 * a new array.
 * @param {Array.<*>}Â originalArray
 * @param {Function}Â fn
 */

function flatMap(originalArray, fn) {
  /* tslint:disable no-unbound-method */
  if (typeof Array.prototype.flatMap === "function") {
    /* tslint:enable no-unbound-method */
    return originalArray.flatMap(fn);
  }

  return originalArray.reduce(function (acc, arg) {
    var r = fn(arg);

    if (Array.isArray(r)) {
      return [].concat(_toConsumableArray(acc), _toConsumableArray(r));
    }

    return [].concat(_toConsumableArray(acc), [r]);
  }, []);
}

exports.default = flatMap;
},{}],"../../../core/eme/find_key_system.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var compat_1 = require("../../compat");

var config_1 = __importDefault(require("../../config"));

var errors_1 = require("../../errors");

var log_1 = __importDefault(require("../../log"));

var array_includes_1 = __importDefault(require("../../utils/array_includes"));

var flat_map_1 = __importDefault(require("../../utils/flat_map"));

var media_keys_infos_store_1 = __importDefault(require("./media_keys_infos_store"));

var _config_1$default = config_1.default,
    EME_DEFAULT_WIDEVINE_ROBUSTNESSES = _config_1$default.EME_DEFAULT_WIDEVINE_ROBUSTNESSES,
    EME_KEY_SYSTEMS = _config_1$default.EME_KEY_SYSTEMS;
/**
 * @param {Array.<Object>} keySystems
 * @param {MediaKeySystemAccess} currentKeySystemAccess
 * @param {Object} currentKeySystemOptions
 * @returns {null|Object}
 */

function checkCachedMediaKeySystemAccess(keySystems, currentKeySystemAccess, currentKeySystemOptions) {
  var mksConfiguration = currentKeySystemAccess.getConfiguration();

  if (compat_1.shouldRenewMediaKeys() || !mksConfiguration) {
    return null;
  }

  var firstCompatibleOption = keySystems.filter(function (ks) {
    // TODO Do it with MediaKeySystemAccess.prototype.keySystem instead
    if (ks.type !== currentKeySystemOptions.type) {
      return false;
    }

    if (ks.persistentLicense && mksConfiguration.persistentState !== "required") {
      return false;
    }

    if (ks.distinctiveIdentifierRequired && mksConfiguration.distinctiveIdentifier !== "required") {
      return false;
    }

    return true;
  })[0];

  if (firstCompatibleOption) {
    return {
      keySystemOptions: firstCompatibleOption,
      keySystemAccess: currentKeySystemAccess
    };
  }

  return null;
}
/**
 * Find key system canonical name from key system type.
 * @param {string} ksType - Obtained via inversion
 * @returns {string|undefined} - Either the canonical name, or undefined.
 */


function findKeySystemCanonicalName(ksType) {
  for (var _i = 0, _Object$keys = Object.keys(EME_KEY_SYSTEMS); _i < _Object$keys.length; _i++) {
    var ksName = _Object$keys[_i];

    if (array_includes_1.default(EME_KEY_SYSTEMS[ksName], ksType)) {
      return ksName;
    }
  }

  return undefined;
}
/**
 * Build configuration for the requestMediaKeySystemAccess EME API, based
 * on the current keySystem object.
 * @param {string} [ksName] - Generic name for the key system. e.g. "clearkey",
 * "widevine", "playready". Can be used to make exceptions depending on it.
 * @param {Object} keySystem
 * @returns {Array.<Object>} - Configuration to give to the
 * requestMediaKeySystemAccess API.
 */


function buildKeySystemConfigurations(ksName, keySystem) {
  var sessionTypes = ["temporary"];
  var persistentState = "optional";
  var distinctiveIdentifier = "optional";

  if (keySystem.persistentLicense) {
    persistentState = "required";
    sessionTypes.push("persistent-license");
  }

  if (keySystem.persistentStateRequired) {
    persistentState = "required";
  }

  if (keySystem.distinctiveIdentifierRequired) {
    distinctiveIdentifier = "required";
  } // Set robustness, in order of consideration:
  //   1. the user specified its own robustnesses
  //   2. a "widevine" key system is used, in that case set the default widevine
  //      robustnesses as defined in the config
  //   3. set an undefined robustness


  var videoRobustnesses = keySystem.videoRobustnesses || (ksName === "widevine" ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : []);
  var audioRobustnesses = keySystem.audioRobustnesses || (ksName === "widevine" ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : []);

  if (!videoRobustnesses.length) {
    videoRobustnesses.push(undefined);
  }

  if (!audioRobustnesses.length) {
    audioRobustnesses.push(undefined);
  } // From the W3 EME spec, we have to provide videoCapabilities and
  // audioCapabilities.
  // These capabilities must specify a codec (even though you can use a
  // completely different codec afterward).
  // It is also strongly recommended to specify the required security
  // robustness. As we do not want to forbide any security level, we specify
  // every existing security level from highest to lowest so that the best
  // security level is selected.
  // More details here:
  // https://storage.googleapis.com/wvdocs/Chrome_EME_Changes_and_Best_Practices.pdf
  // https://www.w3.org/TR/encrypted-media/#get-supported-configuration-and-consent


  var videoCapabilities = flat_map_1.default(videoRobustnesses, function (robustness) {
    return [{
      contentType: "video/mp4;codecs=\"avc1.4d401e\"",
      robustness: robustness
    }, {
      contentType: "video/mp4;codecs=\"avc1.42e01e\"",
      robustness: robustness
    }, {
      contentType: "video/webm;codecs=\"vp8\"",
      robustness: robustness
    }];
  });
  var audioCapabilities = flat_map_1.default(audioRobustnesses, function (robustness) {
    return [{
      contentType: "audio/mp4;codecs=\"mp4a.40.2\"",
      robustness: robustness
    }, {
      contentType: "audio/webm;codecs=opus",
      robustness: robustness
    }];
  }); // TODO Re-test with a set contentType but an undefined robustness on the
  // STBs on which this problem was found.
  //
  // add another with no {audio,video}Capabilities for some legacy browsers.
  // As of today's spec, this should return NotSupported but the first
  // candidate configuration should be good, so we should have no downside
  // doing that.
  // initDataTypes: ["cenc"],
  // videoCapabilities: undefined,
  // audioCapabilities: undefined,
  // distinctiveIdentifier,
  // persistentState,
  // sessionTypes,

  return [{
    initDataTypes: ["cenc"],
    videoCapabilities: videoCapabilities,
    audioCapabilities: audioCapabilities,
    distinctiveIdentifier: distinctiveIdentifier,
    persistentState: persistentState,
    sessionTypes: sessionTypes
  }];
}
/**
 * Try to find a compatible key system from the keySystems array given.
 *
 * Returns an Observable which, when subscribed to, will request a
 * MediaKeySystemAccess based on the various keySystems provided. This
 * Observable will:
 *   - emit the MediaKeySystemAccess and the keySystems as an object, when
 *     found. The object is under this form:
 *     {
 *       keySystemAccess {MediaKeySystemAccess}
 *       keySystem {Object}
 *     }
 *   - complete immediately after emitting.
 *   - throw if no  compatible key system has been found.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystems - The keySystems you want to test.
 * @returns {Observable}
 */


function getMediaKeySystemAccess(mediaElement, keySystemsConfigs) {
  return rxjs_1.defer(function () {
    var currentState = media_keys_infos_store_1.default.getState(mediaElement);

    if (currentState) {
      // Fast way to find a compatible keySystem if the currently loaded
      // one as exactly the same compatibility options.
      var cachedKeySystemAccess = checkCachedMediaKeySystemAccess(keySystemsConfigs, currentState.mediaKeySystemAccess, currentState.keySystemOptions);

      if (cachedKeySystemAccess) {
        log_1.default.debug("EME: Found cached compatible keySystem", cachedKeySystemAccess);
        return rxjs_1.of({
          type: "reuse-media-key-system-access",
          value: {
            mediaKeySystemAccess: cachedKeySystemAccess.keySystemAccess,
            options: cachedKeySystemAccess.keySystemOptions
          }
        });
      }
    }
    /**
     * Array of set keySystems for this content.
     * Each item of this array is an object containing the following keys:
     *   - keyName {string}: keySystem canonical name (e.g. "widevine")
     *   - keyType {string}: keySystem type (e.g. "com.widevine.alpha")
     *   - keySystem {Object}: the original keySystem object
     * @type {Array.<Object>}
     */


    var keySystemsType = keySystemsConfigs.reduce(function (arr, keySystemOptions) {
      var managedRDNs = EME_KEY_SYSTEMS[keySystemOptions.type];
      var ksType;

      if (managedRDNs != null) {
        ksType = managedRDNs.map(function (keyType) {
          var keyName = keySystemOptions.type;
          return {
            keyName: keyName,
            keyType: keyType,
            keySystemOptions: keySystemOptions
          };
        });
      } else {
        var keyName = findKeySystemCanonicalName(keySystemOptions.type) || "";
        var keyType = keySystemOptions.type;
        ksType = [{
          keyName: keyName,
          keyType: keyType,
          keySystemOptions: keySystemOptions
        }];
      }

      return arr.concat(ksType);
    }, []);
    return new rxjs_1.Observable(function (obs) {
      var disposed = false;
      var sub;
      /**
       * Test the key system as defined in keySystemsType[index].
       * @param {Number} index
       */

      function testKeySystem(index) {
        // completely quit the loop if unsubscribed
        if (disposed) {
          return;
        } // if we iterated over the whole keySystemsType Array, quit on error


        if (index >= keySystemsType.length) {
          obs.error(new errors_1.EncryptedMediaError("INCOMPATIBLE_KEYSYSTEMS", "No key system compatible with your " + "wanted configuration has been found " + "in the current browser."));
          return;
        }

        var _keySystemsType$index = keySystemsType[index],
            keyName = _keySystemsType$index.keyName,
            keyType = _keySystemsType$index.keyType,
            keySystemOptions = _keySystemsType$index.keySystemOptions;
        var keySystemConfigurations = buildKeySystemConfigurations(keyName, keySystemOptions);
        log_1.default.debug("EME: Request keysystem access ".concat(keyType, ",") + "".concat(index + 1, " of ").concat(keySystemsType.length), keySystemConfigurations);

        if (compat_1.requestMediaKeySystemAccess == null) {
          throw new Error("requestMediaKeySystemAccess is not " + "implemented in your browser.");
        }

        sub = compat_1.requestMediaKeySystemAccess(keyType, keySystemConfigurations).subscribe(function (keySystemAccess) {
          log_1.default.info("EME: Found compatible keysystem", keyType, keySystemConfigurations);
          obs.next({
            type: "create-media-key-system-access",
            value: {
              options: keySystemOptions,
              mediaKeySystemAccess: keySystemAccess
            }
          });
          obs.complete();
        }, function () {
          log_1.default.debug("EME: Rejected access to keysystem", keyType, keySystemConfigurations);
          sub = null;
          testKeySystem(index + 1);
        });
      }

      testKeySystem(0);
      return function () {
        disposed = true;

        if (sub) {
          sub.unsubscribe();
        }
      };
    });
  });
}

exports.default = getMediaKeySystemAccess;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","../../compat":"../../../compat/index.ts","../../config":"../../../config.ts","../../errors":"../../../errors/index.ts","../../log":"../../../log.ts","../../utils/array_includes":"../../../utils/array_includes.ts","../../utils/flat_map":"../../../utils/flat_map.ts","./media_keys_infos_store":"../../../core/eme/media_keys_infos_store.ts"}],"../../../utils/array_find.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Array.prototype.find ponyfill.
 * @param {Array} arr
 * @param {Function} predicate
 * @param {*} context
 * @returns {boolean}
 */

function arrayFind(arr, predicate, thisArg) {
  if (typeof Array.prototype.find === "function") {
    /* tslint:disable ban */
    return arr.find(predicate, thisArg);
    /* tslint:enable ban */
  }

  var len = arr.length >>> 0;

  for (var i = 0; i < len; i++) {
    var val = arr[i];

    if (predicate.call(thisArg, val, i, arr)) {
      return val;
    }
  }

  return undefined;
}

exports.default = arrayFind;
},{}],"../../../core/eme/utils/open_sessions_store.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var compat_1 = require("../../../compat");

var errors_1 = require("../../../errors");

var log_1 = __importDefault(require("../../../log"));

var array_find_1 = __importDefault(require("../../../utils/array_find"));

var cast_to_observable_1 = __importDefault(require("../../../utils/cast_to_observable"));

var hash_buffer_1 = __importDefault(require("../../../utils/hash_buffer"));
/**
 * Create and store MediaKeySessions linked to a single MediaKeys
 * instance.
 *
 * Keep track of sessionTypes and of the initialization data each
 * MediaKeySession is created for.
 * @class MediaKeySessionsStore
 */


var MediaKeySessionsStore =
/*#__PURE__*/
function () {
  function MediaKeySessionsStore(mediaKeys) {
    _classCallCheck(this, MediaKeySessionsStore);

    this._mediaKeys = mediaKeys;
    this._entries = [];
  }
  /**
   * @returns {Array.<Object>}
   */


  _createClass(MediaKeySessionsStore, [{
    key: "getAll",
    value: function getAll() {
      return this._entries.map(function (entry) {
        return {
          session: entry.session,
          sessionType: entry.sessionType
        };
      });
    }
    /**
     * Returns an entry in this cache with the initData and initDataType given.
     * null if no such session is stored.
     *
     * @param {Uint8Array} initData
     * @param {string|undefined} initDataType
     * @returns {Object|null}
     */

  }, {
    key: "get",
    value: function get(initData, initDataType) {
      var initDataHash = hash_buffer_1.default(initData);
      var foundEntry = array_find_1.default(this._entries, function (entry) {
        return entry.initData === initDataHash && entry.initDataType === initDataType;
      });

      if (foundEntry) {
        var session = foundEntry.session,
            sessionType = foundEntry.sessionType;
        return {
          session: session,
          sessionType: sessionType
        };
      }

      return null;
    }
    /**
     * @param {Uint8Array} initData
     * @param {string|undefined} initDataType
     * @param {string} sessionType
     * @returns {MediaKeySession}
     * @throws {EncryptedMediaError}
     */

  }, {
    key: "createSession",
    value: function createSession(initData, initDataType, sessionType) {
      var _this = this;

      if (this.get(initData, initDataType)) {
        throw new errors_1.EncryptedMediaError("MULTIPLE_SESSIONS_SAME_INIT_DATA", "This initialization data was already stored.");
      }

      var session = compat_1.createSession(this._mediaKeys, sessionType);
      var entry = {
        session: session,
        sessionType: sessionType,
        initData: hash_buffer_1.default(initData),
        initDataType: initDataType
      };

      if (session.closed !== null) {
        session.closed.then(function () {
          _this._delete(session);
        }).catch(function (e) {
          log_1.default.warn("EME-MKSS: session.closed rejected: ".concat(e));
        });
      }

      log_1.default.debug("EME-MKSS: Add session", entry);

      this._entries.push(entry);

      return session;
    }
    /**
     * Close a MediaKeySession and remove its entry if it's found in the store.
     * @param {MediaKeySession} session
     * @returns {Observable}
     */

  }, {
    key: "deleteAndCloseSession",
    value: function deleteAndCloseSession(session) {
      var _this2 = this;

      return rxjs_1.defer(function () {
        _this2._delete(session);

        log_1.default.debug("EME-MKSS: Close session", session);
        return cast_to_observable_1.default(session.close()).pipe(operators_1.catchError(function () {
          return rxjs_1.of(null);
        }));
      });
    }
    /**
     * Close all sessions in this store.
     * Emit null when done
     * @returns {Observable}
     */

  }, {
    key: "closeAllSessions",
    value: function closeAllSessions() {
      var _this3 = this;

      return rxjs_1.defer(function () {
        var previousEntries = _this3._entries;
        _this3._entries = []; // clean completely the cache first

        var disposed = previousEntries.map(function (entry) {
          return _this3.deleteAndCloseSession(entry.session);
        });
        return rxjs_1.concat(rxjs_1.merge.apply(rxjs_1, _toConsumableArray(disposed)).pipe(operators_1.ignoreElements()), rxjs_1.of(null));
      });
    }
    /**
     * Remove a MediaKeySession from the Cache, without closing it.
     * Returns the entry if found, null otherwise.
     * @param {MediaKeySession} session
     * @returns {number} - index of the session in the cache. -1 of not found.
     */

  }, {
    key: "_delete",
    value: function _delete(session) {
      var entry = array_find_1.default(this._entries, function (e) {
        return e.session === session;
      });

      if (!entry) {
        return -1;
      }

      log_1.default.debug("EME-MKSS: delete session", entry);

      var idx = this._entries.indexOf(entry);

      this._entries.splice(idx, 1);

      return idx;
    }
  }]);

  return MediaKeySessionsStore;
}();

exports.default = MediaKeySessionsStore;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../../compat":"../../../compat/index.ts","../../../errors":"../../../errors/index.ts","../../../log":"../../../log.ts","../../../utils/array_find":"../../../utils/array_find.ts","../../../utils/cast_to_observable":"../../../utils/cast_to_observable.ts","../../../utils/hash_buffer":"../../../utils/hash_buffer.ts"}],"../../../core/eme/utils/persisted_session_store.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../../log"));

var array_find_1 = __importDefault(require("../../../utils/array_find"));

var assert_1 = require("../../../utils/assert");

var hash_buffer_1 = __importDefault(require("../../../utils/hash_buffer"));

function checkStorage(storage) {
  assert_1.assertInterface(storage, {
    save: "function",
    load: "function"
  }, "licenseStorage");
}
/**
 * Set representing persisted licenses. Depends on a simple local-
 * storage implementation with a `save`/`load` synchronous interface
 * to persist information on persisted sessions.
 *
 * This set is used only for a cdm/keysystem with license persistency
 * supported.
 * @class PersistedSessionsStore
 */


var PersistedSessionsStore =
/*#__PURE__*/
function () {
  /**
   * @param {Object} storage
   */
  function PersistedSessionsStore(storage) {
    _classCallCheck(this, PersistedSessionsStore);

    checkStorage(storage);
    this._entries = [];
    this._storage = storage;

    try {
      this._entries = this._storage.load();

      if (!Array.isArray(this._entries)) {
        this._entries = [];
      }
    } catch (e) {
      log_1.default.warn("EME-PSS: Could not get entries from license storage", e);
      this.dispose();
    }
  }
  /**
   * Retrieve entry (sessionId + initData) based on its initData.
   * @param {Uint8Array}  initData
   * @param {string|undefined} initDataType
   * @returns {Object|null}
   */


  _createClass(PersistedSessionsStore, [{
    key: "get",
    value: function get(initData, initDataType) {
      var hash = hash_buffer_1.default(initData);
      var entry = array_find_1.default(this._entries, function (e) {
        return e.initData === hash && e.initDataType === initDataType;
      });
      return entry || null;
    }
    /**
     * Add a new entry in the storage.
     * @param {Uint8Array}  initData
     * @param {string|undefined} initDataType
     * @param {MediaKeySession} session
     */

  }, {
    key: "add",
    value: function add(initData, initDataType, session) {
      var sessionId = session && session.sessionId;

      if (!sessionId) {
        return;
      }

      var currentEntry = this.get(initData, initDataType);

      if (currentEntry && currentEntry.sessionId === sessionId) {
        return;
      } else if (currentEntry) {
        // currentEntry has a different sessionId
        this.delete(initData, initDataType);
      }

      log_1.default.info("EME-PSS: Add new session", sessionId, session);

      this._entries.push({
        sessionId: sessionId,
        initData: hash_buffer_1.default(initData),
        initDataType: initDataType
      });

      this._save();
    }
    /**
     * Delete entry (sessionId + initData) based on its initData.
     * @param {Uint8Array}  initData
     * @param {string|undefined} initDataType
     */

  }, {
    key: "delete",
    value: function _delete(initData, initDataType) {
      var hash = hash_buffer_1.default(initData);
      var entry = array_find_1.default(this._entries, function (e) {
        return e.initData === hash && e.initDataType === initDataType;
      });

      if (entry) {
        log_1.default.warn("EME-PSS: Delete session from store", entry);

        var idx = this._entries.indexOf(entry);

        this._entries.splice(idx, 1);

        this._save();
      }
    }
    /**
     * Delete all saved entries.
     */

  }, {
    key: "dispose",
    value: function dispose() {
      this._entries = [];

      this._save();
    }
    /**
     * Use the given storage to store the current entries.
     */

  }, {
    key: "_save",
    value: function _save() {
      try {
        this._storage.save(this._entries);
      } catch (e) {
        log_1.default.warn("EME-PSS: Could not save licenses in localStorage");
      }
    }
  }]);

  return PersistedSessionsStore;
}();

exports.default = PersistedSessionsStore;
},{"../../../log":"../../../log.ts","../../../utils/array_find":"../../../utils/array_find.ts","../../../utils/assert":"../../../utils/assert.ts","../../../utils/hash_buffer":"../../../utils/hash_buffer.ts"}],"../../../core/eme/get_media_keys.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var errors_1 = require("../../errors");

var log_1 = __importDefault(require("../../log"));

var cast_to_observable_1 = __importDefault(require("../../utils/cast_to_observable"));

var rx_try_catch_1 = __importDefault(require("../../utils/rx-try_catch"));

var find_key_system_1 = __importDefault(require("./find_key_system"));

var media_keys_infos_store_1 = __importDefault(require("./media_keys_infos_store"));

var open_sessions_store_1 = __importDefault(require("./utils/open_sessions_store"));

var persisted_session_store_1 = __importDefault(require("./utils/persisted_session_store"));
/**
 * @throws {EncryptedMediaError}
 * @param {Object} keySystemOptions
 * @returns {Object|null}
 */


function createSessionStorage(keySystemOptions) {
  if (!keySystemOptions.persistentLicense) {
    return null;
  }

  var licenseStorage = keySystemOptions.licenseStorage;

  if (!licenseStorage) {
    throw new errors_1.EncryptedMediaError("INVALID_KEY_SYSTEM", "No license storage found for persistent license.");
  }

  log_1.default.info("EME: Set the given license storage");
  return new persisted_session_store_1.default(licenseStorage);
}
/**
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystemsConfigs
 * @returns {Observable}
 */


function getMediaKeysInfos(mediaElement, keySystemsConfigs) {
  return find_key_system_1.default(mediaElement, keySystemsConfigs).pipe(operators_1.mergeMap(function (evt) {
    var _evt$value = evt.value,
        options = _evt$value.options,
        mediaKeySystemAccess = _evt$value.mediaKeySystemAccess;
    var currentState = media_keys_infos_store_1.default.getState(mediaElement);
    var sessionStorage = createSessionStorage(options);

    if (currentState != null && evt.type === "reuse-media-key-system-access") {
      var mediaKeys = currentState.mediaKeys,
          sessionsStore = currentState.sessionsStore;
      return rxjs_1.of({
        mediaKeys: mediaKeys,
        sessionsStore: sessionsStore,
        mediaKeySystemAccess: mediaKeySystemAccess,
        keySystemOptions: options,
        sessionStorage: sessionStorage
      });
    }

    log_1.default.debug("EME: Calling createMediaKeys on the MediaKeySystemAccess");
    return rx_try_catch_1.default(function () {
      return cast_to_observable_1.default(mediaKeySystemAccess.createMediaKeys());
    }, undefined).pipe(operators_1.catchError(function (error) {
      var message = error instanceof Error ? error.message : "Unknown error when creating MediaKeys.";
      throw new errors_1.EncryptedMediaError("CREATE_MEDIA_KEYS_ERROR", message);
    }), operators_1.map(function (mediaKeys) {
      return {
        mediaKeys: mediaKeys,
        sessionsStore: new open_sessions_store_1.default(mediaKeys),
        mediaKeySystemAccess: mediaKeySystemAccess,
        keySystemOptions: options,
        sessionStorage: sessionStorage
      };
    }));
  }));
}

exports.default = getMediaKeysInfos;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../errors":"../../../errors/index.ts","../../log":"../../../log.ts","../../utils/cast_to_observable":"../../../utils/cast_to_observable.ts","../../utils/rx-try_catch":"../../../utils/rx-try_catch.ts","./find_key_system":"../../../core/eme/find_key_system.ts","./media_keys_infos_store":"../../../core/eme/media_keys_infos_store.ts","./utils/open_sessions_store":"../../../core/eme/utils/open_sessions_store.ts","./utils/persisted_session_store":"../../../core/eme/utils/persisted_session_store.ts"}],"../../../core/eme/init_media_keys.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var attach_media_keys_1 = __importDefault(require("./attach_media_keys"));

var get_media_keys_1 = __importDefault(require("./get_media_keys"));
/**
 * Get media keys infos from key system configs then attach media keys to media element.
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystemsConfigs
 * @returns {Observable}
 */


function initMediaKeys(mediaElement, keySystemsConfigs) {
  return get_media_keys_1.default(mediaElement, keySystemsConfigs).pipe(operators_1.mergeMap(function (mediaKeysInfos) {
    return rxjs_1.concat(rxjs_1.of({
      type: "created-media-keys",
      value: mediaKeysInfos
    }), attach_media_keys_1.default(mediaKeysInfos, mediaElement).pipe(operators_1.mapTo({
      type: "attached-media-keys",
      value: mediaKeysInfos
    })));
  }));
}

exports.default = initMediaKeys;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","./attach_media_keys":"../../../core/eme/attach_media_keys.ts","./get_media_keys":"../../../core/eme/get_media_keys.ts"}],"../../../utils/get_fuzzed_delay.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var FUZZ_FACTOR = 0.3;
/**
 * Perform "fuzzing" on the delay given.
 * @param {Number} retryDelay
 * @returns {Number}
 */

function getFuzzedDelay(retryDelay) {
  var fuzzingFactor = (Math.random() * 2 - 1) * FUZZ_FACTOR;
  return retryDelay * (fuzzingFactor + 1.0); // Max 1.3 Min 0.7
}

exports.default = getFuzzedDelay;
},{}],"../../../utils/rx-retry_with_backoff.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var get_fuzzed_delay_1 = __importDefault(require("./get_fuzzed_delay"));
/**
 * Retry the given observable (if it triggers an error) with an exponential
 * backoff.
 * The backoff behavior can be tweaked through the options given.
 *
 * @param {Observable} obs$
 * @param {Object} options - Configuration object.
 * This object contains the following properties:
 *
 *   - retryDelay {Number} - The initial delay, in ms.
 *     This delay will be fuzzed to fall under the range +-30% each time a new
 *     retry is done.
 *     Then, this delay will be multiplied by 2^(n-1), n being the counter of
 *     retry we performed (beginning at 1 for the first retry).
 *
 *   - totalRetry {Number} - The amount of time we should retry. 0
 *     means no retry, 1 means a single retry, Infinity means infinite retry
 *     etc.
 *     If the observable still fails after this number of retry, the error will
 *     be throwed through this observable.
 *
 *   - shouldRetry {Function|undefined} -  Function which will receive the
 *     observable error each time it fails, and should return a boolean. If this
 *     boolean is false, the error will be directly thrown (without anymore
 *     retry).
 *
 *   - onRetry {Function|undefined} - Function which will be triggered at
 *     each retry. Will receive two arguments:
 *       1. The observable error
 *       2. The current retry count, beginning at 1 for the first retry
 *
 * @returns {Observable}
 * TODO Take errorSelector out. Should probably be entirely managed in the
 * calling code via a catch (much simpler to use and to understand).
 */


function retryObsWithBackoff(obs$, options) {
  var baseDelay = options.baseDelay,
      maxDelay = options.maxDelay,
      totalRetry = options.totalRetry,
      shouldRetry = options.shouldRetry,
      onRetry = options.onRetry;
  var retryCount = 0;
  return obs$.pipe(operators_1.catchError(function (error, source) {
    if (shouldRetry != null && !shouldRetry(error) || retryCount++ >= totalRetry) {
      throw error;
    }

    if (onRetry) {
      onRetry(error, retryCount);
    }

    var delay = Math.min(baseDelay * Math.pow(2, retryCount - 1), maxDelay);
    var fuzzedDelay = get_fuzzed_delay_1.default(delay);
    return rxjs_1.timer(fuzzedDelay).pipe(operators_1.mergeMap(function () {
      return source;
    }));
  }));
}

exports.default = retryObsWithBackoff;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","./get_fuzzed_delay":"../../../utils/get_fuzzed_delay.ts"}],"../../../core/eme/check_key_statuses.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var errors_1 = require("../../errors");

var KEY_STATUSES = {
  EXPIRED: "expired",
  INTERNAL_ERROR: "internal-error",
  OUTPUT_RESTRICTED: "output-restricted"
};
/**
 * Look at the current key statuses in the sessions and construct the
 * appropriate warnings
 *
 * Throws if one of the keyID is on an error.
 * @param {MediaKeySession} session - The MediaKeySession from which the keys
 * will be checked.
 * @param {Object} keySystem - Configuration. Used to known on which situations
 * we can fallback.
 * @returns {Array} - Warnings to send.
 */

function checkKeyStatuses(session, keySystem) {
  var warnings = [];
  session.keyStatuses.forEach(function (_arg1, _arg2) {
    // Hack present because the order of the arguments has changed in spec
    // and is not the same between some versions of Edge and Chrome.
    var keyStatus = function () {
      return typeof _arg1 === "string" ? _arg1 : _arg2;
    }();

    switch (keyStatus) {
      case KEY_STATUSES.EXPIRED:
        {
          var error = new errors_1.EncryptedMediaError("KEY_STATUS_CHANGE_ERROR", "A decryption key expired");

          if (keySystem.throwOnLicenseExpiration !== false) {
            throw error;
          }

          warnings.push({
            type: "warning",
            value: error
          });
          break;
        }

      case KEY_STATUSES.OUTPUT_RESTRICTED:
      case KEY_STATUSES.INTERNAL_ERROR:
        throw new errors_1.EncryptedMediaError("KEY_STATUS_CHANGE_ERROR", "An invalid key status has been " + "encountered: " + keyStatus);
    }
  });
  return warnings;
}

exports.default = checkKeyStatuses;
},{"../../errors":"../../../errors/index.ts"}],"../../../core/eme/session_events_listener.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var compat_1 = require("../../compat");

var errors_1 = require("../../errors");

var log_1 = __importDefault(require("../../log"));

var cast_to_observable_1 = __importDefault(require("../../utils/cast_to_observable"));

var rx_retry_with_backoff_1 = __importDefault(require("../../utils/rx-retry_with_backoff"));

var rx_try_catch_1 = __importDefault(require("../../utils/rx-try_catch"));

var check_key_statuses_1 = __importDefault(require("./check_key_statuses"));

var _compat_1$events = compat_1.events,
    onKeyError$ = _compat_1$events.onKeyError$,
    onKeyMessage$ = _compat_1$events.onKeyMessage$,
    onKeyStatusesChange$ = _compat_1$events.onKeyStatusesChange$;
/**
 * @param {Error|Object} error
 * @returns {Error|Object}
 */

function formatGetLicenseError(error) {
  if (error instanceof rxjs_1.TimeoutError) {
    return new errors_1.EncryptedMediaError("KEY_LOAD_TIMEOUT", "The license server took too much time to " + "respond.");
  }

  var err = new errors_1.EncryptedMediaError("KEY_LOAD_ERROR", "An error occured when calling `getLicense`.");

  if (error != null && error.message) {
    err.message = error.message;
  }

  return err;
}
/**
 * listen to various events from a MediaKeySession and react accordingly
 * depending on the configuration given.
 * @param {MediaKeySession} session - The MediaKeySession concerned.
 * @param {Object} keySystem - The key system configuration.
 * @returns {Observable}
 */


function SessionEventsListener(session, keySystem) {
  log_1.default.debug("EME: Binding session events", session);

  function getKeyStatusesEvents() {
    var warnings = check_key_statuses_1.default(session, keySystem);
    var warnings$ = rxjs_1.of.apply(rxjs_1, _toConsumableArray(warnings));
    return warnings$;
  }

  var sessionWarningSubject$ = new rxjs_1.Subject();
  var _keySystem$getLicense = keySystem.getLicenseConfig,
      getLicenseConfig = _keySystem$getLicense === void 0 ? {} : _keySystem$getLicense;
  var getLicenseRetryOptions = {
    totalRetry: getLicenseConfig.retry != null ? getLicenseConfig.retry : 2,
    baseDelay: 200,
    maxDelay: 3000,
    shouldRetry: function shouldRetry(error) {
      return error instanceof rxjs_1.TimeoutError || error == null || error.noRetry !== true;
    },
    onRetry: function onRetry(error) {
      return sessionWarningSubject$.next({
        type: "warning",
        value: formatGetLicenseError(error)
      });
    }
  };
  var keyErrors = onKeyError$(session).pipe(operators_1.map(function (error) {
    throw new errors_1.EncryptedMediaError("KEY_ERROR", error.type);
  }));
  var keyStatusesChanges = onKeyStatusesChange$(session).pipe(operators_1.mergeMap(function (keyStatusesEvent) {
    log_1.default.debug("EME: keystatuseschange event", session, keyStatusesEvent);
    var keyStatusesEvents$ = getKeyStatusesEvents();
    var handledKeyStatusesChange$ = rx_try_catch_1.default(function () {
      return keySystem && keySystem.onKeyStatusesChange ? cast_to_observable_1.default(keySystem.onKeyStatusesChange(keyStatusesEvent, session)) : rxjs_1.EMPTY;
    }, undefined).pipe(operators_1.map(function (licenseObject) {
      return {
        type: "key-status-change-handled",
        value: {
          session: session,
          license: licenseObject
        }
      };
    }), operators_1.catchError(function (error) {
      var err = new errors_1.EncryptedMediaError("KEY_STATUS_CHANGE_ERROR", "Unknown `onKeyStatusesChange` error");

      if (error != null && error.message) {
        err.message = error.message;
      }

      throw err;
    }));
    return rxjs_1.concat(keyStatusesEvents$, handledKeyStatusesChange$);
  }));
  var keyMessages$ = onKeyMessage$(session).pipe(operators_1.mergeMap(function (messageEvent) {
    var message = new Uint8Array(messageEvent.message);
    var messageType = messageEvent.messageType || "license-request";
    log_1.default.debug("EME: Event message type ".concat(messageType), session, messageEvent);
    var getLicense$ = rxjs_1.defer(function () {
      var getLicense = keySystem.getLicense(message, messageType);
      var getLicenseTimeout = getLicenseConfig.timeout != null ? getLicenseConfig.timeout : 10 * 1000;
      return cast_to_observable_1.default(getLicense).pipe(getLicenseTimeout >= 0 ? operators_1.timeout(getLicenseTimeout) : rxjs_1.identity
      /* noop */
      );
    });
    return rx_retry_with_backoff_1.default(getLicense$, getLicenseRetryOptions).pipe(operators_1.map(function (licenseObject) {
      return {
        type: "key-message-handled",
        value: {
          session: session,
          license: licenseObject
        }
      };
    }), operators_1.catchError(function (err) {
      throw formatGetLicenseError(err);
    }));
  }));
  var sessionUpdates = rxjs_1.merge(keyMessages$, keyStatusesChanges).pipe(operators_1.concatMap(function (evt) {
    if (evt.type !== "key-message-handled" && evt.type !== "key-status-change-handled") {
      return rxjs_1.of(evt);
    }

    var license = evt.value.license;

    if (license == null) {
      log_1.default.info("EME: No license given, skipping session.update");
      return rxjs_1.of(evt);
    }

    log_1.default.debug("EME: Update session", evt);
    return cast_to_observable_1.default(session.update(license)).pipe(operators_1.catchError(function (error) {
      var reason = error instanceof Error ? error.toString() : "`session.update` failed";
      throw new errors_1.EncryptedMediaError("KEY_UPDATE_ERROR", reason);
    }), operators_1.mapTo({
      type: "session-updated",
      value: {
        session: session,
        license: license
      }
    }), operators_1.startWith(evt));
  }));
  var sessionEvents = rxjs_1.merge(getKeyStatusesEvents(), sessionUpdates, keyErrors, sessionWarningSubject$);
  return session.closed ? sessionEvents.pipe(operators_1.takeUntil(cast_to_observable_1.default(session.closed))) : sessionEvents;
}

exports.default = SessionEventsListener;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../compat":"../../../compat/index.ts","../../errors":"../../../errors/index.ts","../../log":"../../../log.ts","../../utils/cast_to_observable":"../../../utils/cast_to_observable.ts","../../utils/rx-retry_with_backoff":"../../../utils/rx-retry_with_backoff.ts","../../utils/rx-try_catch":"../../../utils/rx-try_catch.ts","./check_key_statuses":"../../../core/eme/check_key_statuses.ts"}],"../../../core/eme/set_server_certificate.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var errors_1 = require("../../errors");

var log_1 = __importDefault(require("../../log"));

var cast_to_observable_1 = __importDefault(require("../../utils/cast_to_observable"));
/**
 * Call the setServerCertificate API with the given certificate.
 * Complete when worked, throw when failed.
 *
 * TODO Manage success?
 * From the spec:
 *   - setServerCertificate resolves with true if everything worked
 *   - it resolves with false if the CDM does not support server
 *     certificates.
 *
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */


function setServerCertificate(mediaKeys, serverCertificate) {
  return rxjs_1.defer(function () {
    return cast_to_observable_1.default(mediaKeys.setServerCertificate(serverCertificate)).pipe(operators_1.catchError(function (error) {
      log_1.default.warn("EME: mediaKeys.setServerCertificate returned an error", error);
      var reason = error instanceof Error ? error.toString() : "`setServerCertificate` error";
      throw new errors_1.EncryptedMediaError("LICENSE_SERVER_CERTIFICATE_ERROR", reason);
    }));
  });
}

exports.setServerCertificate = setServerCertificate;
/**
 * Call the setCertificate API. If it fails just emit the error as warning
 * and complete.
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */

function trySettingServerCertificate(mediaKeys, serverCertificate) {
  if (typeof mediaKeys.setServerCertificate === "function") {
    log_1.default.debug("EME: Setting server certificate on the MediaKeys");
    return setServerCertificate(mediaKeys, serverCertificate).pipe(operators_1.ignoreElements(), operators_1.catchError(function (error) {
      return rxjs_1.of({
        type: "warning",
        value: error
      });
    }));
  }

  log_1.default.warn("EME: Could not set the server certificate." + " mediaKeys.setServerCertificate is not a function");
  return rxjs_1.EMPTY;
}

exports.default = trySettingServerCertificate;
exports.trySettingServerCertificate = trySettingServerCertificate;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../errors":"../../../errors/index.ts","../../log":"../../../log.ts","../../utils/cast_to_observable":"../../../utils/cast_to_observable.ts"}],"../../../core/eme/utils/init_data_store.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var hash_buffer_1 = __importDefault(require("../../../utils/hash_buffer"));

var simple_set_1 = __importDefault(require("../../../utils/simple_set"));
/**
 * Memorize initialization data with straightforward methods.
 * @class InitDataStore
 */


var InitDataStore =
/*#__PURE__*/
function () {
  function InitDataStore() {
    _classCallCheck(this, InitDataStore);

    this._namedTypeData = {};
    this._unnamedTypeData = new simple_set_1.default();
  }
  /**
   * Returns true if this instance has the given initData stored.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {boolean}
   */


  _createClass(InitDataStore, [{
    key: "has",
    value: function has(initData, initDataType) {
      if (!initDataType) {
        return this._unnamedTypeData.test(hash_buffer_1.default(initData));
      }

      if (!this._namedTypeData[initDataType]) {
        return false;
      }

      return this._namedTypeData[initDataType].test(hash_buffer_1.default(initData));
    }
    /**
     * Add initialization data to this memory.
     * @param {Uint8Array} initData
     * @param {string|undefined} initDataType
     */

  }, {
    key: "add",
    value: function add(initData, initDataType) {
      if (this.has(initData, initDataType)) {
        return;
      }

      if (!initDataType) {
        this._unnamedTypeData.add(hash_buffer_1.default(initData));

        return;
      }

      if (!this._namedTypeData[initDataType]) {
        this._namedTypeData[initDataType] = new simple_set_1.default();
      }

      this._namedTypeData[initDataType].add(hash_buffer_1.default(initData));
    }
    /**
     * Remove the initialization data from this memory.
     * Returns true if this instance had the given initData stored.
     * @param {Uint8Array} initData
     * @param {string|undefined} initDataType
     * @returns {boolean}
     */

  }, {
    key: "remove",
    value: function remove(initData, initDataType) {
      if (!initDataType) {
        var hashed = hash_buffer_1.default(initData);

        if (this._unnamedTypeData.test(hashed)) {
          this._unnamedTypeData.remove(hashed);

          return true;
        }

        return false;
      } else {
        if (!this._namedTypeData[initDataType]) {
          return false;
        }

        var _hashed = hash_buffer_1.default(initData);

        var simpleSet = this._namedTypeData[initDataType];

        if (simpleSet.test(_hashed)) {
          simpleSet.remove(_hashed);
          return true;
        }

        return false;
      }
    }
  }]);

  return InitDataStore;
}();

exports.default = InitDataStore;
},{"../../../utils/hash_buffer":"../../../utils/hash_buffer.ts","../../../utils/simple_set":"../../../utils/simple_set.ts"}],"../../../core/eme/eme_manager.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var compat_1 = require("../../compat/");

var errors_1 = require("../../errors");

var log_1 = __importDefault(require("../../log"));

var get_session_1 = __importDefault(require("./get_session"));

var init_media_keys_1 = __importDefault(require("./init_media_keys"));

var session_events_listener_1 = __importDefault(require("./session_events_listener"));

var set_server_certificate_1 = __importDefault(require("./set_server_certificate"));

var init_data_store_1 = __importDefault(require("./utils/init_data_store"));

var onEncrypted$ = compat_1.events.onEncrypted$;
/**
 * EME abstraction and event handler used to communicate with the Content-
 * Description-Module (CDM).
 *
 * The EME handler can be given one or multiple systems and will choose the
 * appropriate one supported by the user's browser.
 * @param {HTMLMediaElement} mediaElement - The MediaElement which will be
 * associated to a MediaKeys object
 * @param {Array.<Object>} keySystems - key system configuration
 * @returns {Observable}
 */

function EMEManager(mediaElement, keySystemsConfigs) {
  log_1.default.debug("EME: Starting EMEManager logic."); // Keep track of all initialization data handled here.
  // This is to avoid handling multiple times the same encrypted events.

  var handledInitData = new init_data_store_1.default(); // store the mediaKeys when ready

  var mediaKeysInfos$ = init_media_keys_1.default(mediaElement, keySystemsConfigs).pipe(operators_1.shareReplay()); // cache success

  var attachedMediaKeys$ = mediaKeysInfos$.pipe(operators_1.filter(function (evt) {
    return evt.type === "attached-media-keys";
  }));
  var encryptedEvents$ = onEncrypted$(mediaElement).pipe(operators_1.tap(function (evt) {
    log_1.default.debug("EME: Encrypted event received from media element.", evt);
  }), operators_1.map(function (evt) {
    var _compat_1$getInitData = compat_1.getInitData(evt),
        initData = _compat_1$getInitData.initData,
        initDataType = _compat_1$getInitData.initDataType;

    return {
      type: initDataType,
      data: initData
    };
  }));
  var bindSession$ = rxjs_1.combineLatest([encryptedEvents$, attachedMediaKeys$]).pipe(
  /* Attach server certificate and create/reuse MediaKeySession */
  operators_1.mergeMap(function (_ref, i) {
    var _ref2 = _slicedToArray(_ref, 2),
        encryptedEvent = _ref2[0],
        mediaKeysEvent = _ref2[1];

    var mediaKeysInfos = mediaKeysEvent.value;
    var keySystemOptions = mediaKeysInfos.keySystemOptions,
        mediaKeys = mediaKeysInfos.mediaKeys;
    var serverCertificate = keySystemOptions.serverCertificate;
    var initDataType = encryptedEvent.type,
        initData = encryptedEvent.data;

    if (handledInitData.has(initData, initDataType)) {
      log_1.default.debug("EME: Init data already received. Skipping it.");
      return rxjs_1.EMPTY; // Already handled, quit
    }

    handledInitData.add(initData, initDataType);
    var session$ = get_session_1.default(encryptedEvent, mediaKeysInfos).pipe(operators_1.map(function (evt) {
      return {
        type: evt.type,
        value: {
          initData: evt.value.initData,
          initDataType: evt.value.initDataType,
          mediaKeySession: evt.value.mediaKeySession,
          sessionType: evt.value.sessionType,
          keySystemOptions: mediaKeysInfos.keySystemOptions,
          sessionStorage: mediaKeysInfos.sessionStorage
        }
      };
    }));

    if (i === 0) {
      // first encrypted event for the current content
      return rxjs_1.merge(serverCertificate != null ? rxjs_1.concat(set_server_certificate_1.default(mediaKeys, serverCertificate), session$) : session$);
    }

    return session$;
  }),
  /* Trigger license request and manage MediaKeySession events */
  operators_1.mergeMap(function (sessionInfosEvt) {
    if (sessionInfosEvt.type === "warning") {
      return rxjs_1.of(sessionInfosEvt);
    }

    var _sessionInfosEvt$valu = sessionInfosEvt.value,
        initData = _sessionInfosEvt$valu.initData,
        initDataType = _sessionInfosEvt$valu.initDataType,
        mediaKeySession = _sessionInfosEvt$valu.mediaKeySession,
        sessionType = _sessionInfosEvt$valu.sessionType,
        keySystemOptions = _sessionInfosEvt$valu.keySystemOptions,
        sessionStorage = _sessionInfosEvt$valu.sessionStorage;
    var generateRequest$ = sessionInfosEvt.type !== "created-session" ? rxjs_1.EMPTY : compat_1.generateKeyRequest(mediaKeySession, initData, initDataType).pipe(operators_1.tap(function () {
      if (sessionType === "persistent-license" && sessionStorage != null) {
        sessionStorage.add(initData, initDataType, mediaKeySession);
      }
    }), operators_1.catchError(function (error) {
      throw new errors_1.EncryptedMediaError("KEY_GENERATE_REQUEST_ERROR", error instanceof Error ? error.toString() : "Unknown error");
    }), operators_1.ignoreElements());
    return rxjs_1.merge(session_events_listener_1.default(mediaKeySession, keySystemOptions), generateRequest$);
  }));
  return rxjs_1.merge(mediaKeysInfos$, bindSession$);
}

exports.default = EMEManager;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../compat/":"../../../compat/index.ts","../../errors":"../../../errors/index.ts","../../log":"../../../log.ts","./get_session":"../../../core/eme/get_session.ts","./init_media_keys":"../../../core/eme/init_media_keys.ts","./session_events_listener":"../../../core/eme/session_events_listener.ts","./set_server_certificate":"../../../core/eme/set_server_certificate.ts","./utils/init_data_store":"../../../core/eme/utils/init_data_store.ts"}],"../../../core/init/create_media_source.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var compat_1 = require("../../compat");

var errors_1 = require("../../errors");

var log_1 = __importDefault(require("../../log"));

var onSourceOpen$ = compat_1.events.onSourceOpen$;
/**
 * Set the media duration in the mediaSource.
 * @param {MediaSource} mediaSource
 * @param {number} duration
 */

function setDurationToMediaSource(mediaSource, duration) {
  var newDuration = duration === Infinity ? Number.MAX_VALUE : duration;

  if (mediaSource.duration !== newDuration) {
    log_1.default.info("Init: Setting duration", newDuration);
    mediaSource.duration = newDuration;
  }
}

exports.setDurationToMediaSource = setDurationToMediaSource;
/**
 * Dispose of ressources taken by the MediaSource:
 *   - Clear the MediaSource' SourceBuffers
 *   - Clear the mediaElement's src (stop the mediaElement)
 *   - Revoke MediaSource' URL
 * @param {HTMLMediaElement} mediaElement
 * @param {MediaSource|null|undefined} mediaSource
 * @param {string|null|undefined} mediaSourceURL
 */

function resetMediaSource(mediaElement, mediaSource, mediaSourceURL) {
  if (mediaSource && mediaSource.readyState !== "closed") {
    var readyState = mediaSource.readyState,
        sourceBuffers = mediaSource.sourceBuffers;

    for (var i = sourceBuffers.length - 1; i >= 0; i--) {
      var sourceBuffer = sourceBuffers[i];

      try {
        if (readyState === "open") {
          log_1.default.info("Init: Removing SourceBuffer from mediaSource", sourceBuffer);
          sourceBuffer.abort();
        }

        mediaSource.removeSourceBuffer(sourceBuffer);
      } catch (e) {
        log_1.default.warn("Init: Error while disposing SourceBuffer", e);
      }
    }

    if (sourceBuffers.length) {
      log_1.default.warn("Init: Not all SourceBuffers could have been removed.");
    }
  }

  compat_1.clearElementSrc(mediaElement);

  if (mediaSourceURL) {
    try {
      log_1.default.debug("Init: Revoking previous URL");
      URL.revokeObjectURL(mediaSourceURL);
    } catch (e) {
      log_1.default.warn("Init: Error while revoking the media source URL", e);
    }
  }
}
/**
 * Create, on subscription, a MediaSource instance and attach it to the given
 * mediaElement element's src attribute.
 *
 * Returns an Observable which emits the MediaSource when created and attached
 * to the mediaElement element.
 * This Observable never completes. It can throw if MediaSource is not
 * available in the current environment.
 *
 * On unsubscription, the mediaElement.src is cleaned, MediaSource sourceBuffers
 * and customBuffers are aborted and some minor cleaning is done.
 *
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */


function createMediaSource(mediaElement) {
  return new rxjs_1.Observable(function (observer) {
    if (!compat_1.MediaSource_) {
      throw new errors_1.MediaError("MEDIA_SOURCE_NOT_SUPPORTED", "No MediaSource Object was found in the current browser.");
    } // make sure the media has been correctly reset


    resetMediaSource(mediaElement, null, mediaElement.src || null);
    log_1.default.info("Init: Creating MediaSource");
    var mediaSource = new compat_1.MediaSource_();
    var objectURL = URL.createObjectURL(mediaSource);
    log_1.default.info("Init: Attaching MediaSource URL to the media element", objectURL);
    mediaElement.src = objectURL;
    observer.next(mediaSource);
    return function () {
      resetMediaSource(mediaElement, mediaSource, objectURL);
    };
  });
}
/**
 * Create and open a new MediaSource object on the given media element.
 * Emit the MediaSource when done.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */


function openMediaSource(mediaElement) {
  return createMediaSource(mediaElement).pipe(operators_1.mergeMap(function (mediaSource) {
    return onSourceOpen$(mediaSource).pipe(operators_1.take(1), operators_1.mapTo(mediaSource));
  }));
}

exports.default = openMediaSource;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../compat":"../../../compat/index.ts","../../errors":"../../../errors/index.ts","../../log":"../../../log.ts"}],"apis/drm/keySystems.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2019 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var eme_manager_1 = __importDefault(require("../../../../../core/eme/eme_manager"));

var create_media_source_1 = __importDefault(require("../../../../../core/init/create_media_source"));
/**
 * Get the licence when keysSystems are specified
 *
 * @remarks
 * This function is basically reproducing the getLicence from the rx-player, but we are
 * adding an additional step to catch the licence and resolve a promise with the licence
 * To get the challenge we need to retrieve the licence
 * we are instanciating a minimal rxPlayer
 * @param ILicenceOptions - The parameters we need to get the licence
 * @returns The licence under a buffer form
 *
 */


function getLicense(settingsKeySystem, externalSettings) {
  var video = document.createElement("video");
  var keySystems = [Object.assign(Object.assign({}, settingsKeySystem), {
    licenseStorage: {
      save: function save(sessionsIDS) {
        externalSettings.storageUtils.db.add("drm", {
          contentID: externalSettings.contentID,
          appMetadata: {
            downloaded: Date.now()
          },
          keySystems: {
            sessionsIDS: sessionsIDS,
            type: settingsKeySystem.type
          }
        }).catch(function (err) {
          throw new Error(err);
        });
      },
      load: function load() {
        return [];
      }
    },
    persistentLicense: true,
    persistentStateRequired: true
  })];
  return create_media_source_1.default(video).pipe(operators_1.mergeMap(function (mediaSource) {
    var emeManager$ = eme_manager_1.default(video, keySystems);
    var sessionsUpdate$ = emeManager$.pipe(operators_1.filter(function (evt) {
      return evt.type === "session-updated";
    }));
    var sourceBuffer = mediaSource.addSourceBuffer(externalSettings.codec);
    var appendedSegment$ = rxjs_1.of(externalSettings.initSegment).pipe(operators_1.tap(function (segmentData) {
      return sourceBuffer.appendBuffer(segmentData);
    }));
    return rxjs_1.combineLatest([sessionsUpdate$, appendedSegment$]).pipe(operators_1.finalize(function () {
      return video.remove();
    }));
  }), operators_1.take(1));
}

exports.default = getLicense;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../../../../core/eme/eme_manager":"../../../core/eme/eme_manager.ts","../../../../../core/init/create_media_source":"../../../core/init/create_media_source.ts"}],"../../../transports/utils/call_custom_manifest_loader.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

function callCustomManifestLoader(customManifestLoader, fallbackManifestLoader) {
  return function (args) {
    return new rxjs_1.Observable(function (obs) {
      var url = args.url;
      var timeAPIsDelta = Date.now() - performance.now();
      var hasFinished = false;
      var hasFallbacked = false;
      /**
       * Callback triggered when the custom manifest loader has a response.
       * @param {Object} args
       */

      var resolve = function resolve(_args) {
        if (!hasFallbacked) {
          hasFinished = true;
          var receivedTime = _args.receivingTime != null ? _args.receivingTime - timeAPIsDelta : undefined;
          var sendingTime = _args.sendingTime != null ? _args.sendingTime - timeAPIsDelta : undefined;
          obs.next({
            type: "data-loaded",
            value: {
              responseData: _args.data,
              size: _args.size,
              duration: _args.duration,
              url: _args.url,
              receivedTime: receivedTime,
              sendingTime: sendingTime
            }
          });
          obs.complete();
        }
      };
      /**
       * Callback triggered when the custom manifest loader fails
       * @param {*} err - The corresponding error encountered
       */


      var reject = function reject(err) {
        if (!hasFallbacked) {
          hasFinished = true;
          obs.error(err);
        }
      };
      /**
       * Callback triggered when the custom manifest loader wants to fallback to
       * the "regular" implementation
       */


      var fallback = function fallback() {
        hasFallbacked = true;
        fallbackManifestLoader(args).subscribe(obs);
      };

      var callbacks = {
        reject: reject,
        resolve: resolve,
        fallback: fallback
      };
      var abort = customManifestLoader(url, callbacks);
      return function () {
        if (!hasFinished && !hasFallbacked && typeof abort === "function") {
          abort();
        }
      };
    });
  };
}

exports.default = callCustomManifestLoader;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js"}],"../../../transports/utils/document_manifest_loader.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var request_1 = __importDefault(require("../../utils/request"));

var call_custom_manifest_loader_1 = __importDefault(require("./call_custom_manifest_loader"));
/**
 * Manifest loader triggered if there was no custom-defined one in the API.
 * @param {string} url
 * @returns {Observable}
 */


function regularManifestLoader(_ref) {
  var url = _ref.url;

  if (url == null) {
    throw new Error("Cannot perform HTTP(s) request. URL not known");
  }

  return request_1.default({
    url: url,
    responseType: "document"
  });
}
/**
 * Generate a manifest loader for the application
 * @param {Function} [customManifestLoader]
 * @returns {Function}
 */


function generateManifestLoader(_ref2) {
  var customManifestLoader = _ref2.customManifestLoader;

  if (customManifestLoader == null) {
    return regularManifestLoader;
  }

  return call_custom_manifest_loader_1.default(customManifestLoader, regularManifestLoader);
}

exports.default = generateManifestLoader;
},{"../../utils/request":"../../../utils/request/index.ts","./call_custom_manifest_loader":"../../../transports/utils/call_custom_manifest_loader.ts"}],"../../../features/add_features.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIE OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var index_1 = __importDefault(require("./index"));
/**
 * @param {Array.<Object>} featureFuncList
 */


function addFeatures(featureFuncList) {
  for (var i = 0; i < featureFuncList.length; i++) {
    var addFeature = featureFuncList[i];

    if (typeof addFeature !== "function") {
      throw new Error("Unrecognized feature");
    }

    addFeature(index_1.default);
  }
}

exports.default = addFeatures;
},{"./index":"../../../features/index.ts"}],"../../../features/types.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../../../features/index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * File allowing feature-switching.
 *
 * Every optional feature is included here.
 * They all should subsequently be accessed in the code through the exported
 * `features` object.
 *
 * The then exported features object will be used dynamically to know which
 * features are activated.
 *
 * This also lazy-feature loading, where this exported object can be updated
 * at runtime, to allow some new features even if the player instance has
 * already have been instanciated.
 */

var add_features_1 = __importDefault(require("./add_features"));

exports.addFeatures = add_features_1.default;

var types_1 = require("./types");

exports.IFeatureFunction = types_1.IFeatureFunction;
/**
 * Initial features object, with no feature activated by default.
 * @type {Object}
 */

var features = {
  transports: {},
  imageBuffer: null,
  imageParser: null,
  nativeTextTracksBuffer: null,
  nativeTextTracksParsers: {},
  htmlTextTracksBuffer: null,
  htmlTextTracksParsers: {},
  emeManager: null,
  directfile: null
};
exports.default = features;
},{"./add_features":"../../../features/add_features.ts","./types":"../../../features/types.ts"}],"../../../transports/dash/image_pipelines.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var features_1 = __importDefault(require("../../features"));

var request_1 = __importDefault(require("../../utils/request"));
/**
 * @param {Object} args
 * @returns {Observable}
 */


function imageLoader(_ref) {
  var segment = _ref.segment;

  if (segment.isInit || segment.mediaURL == null) {
    return rxjs_1.of({
      type: "data-created",
      value: {
        responseData: null
      }
    });
  }

  var mediaURL = segment.mediaURL;
  return request_1.default({
    url: mediaURL,
    responseType: "arraybuffer",
    sendProgressEvents: true
  });
}

exports.imageLoader = imageLoader;
/**
 * @param {Object} args
 * @returns {Observable}
 */

function imageParser(_ref2) {
  var response = _ref2.response,
      content = _ref2.content;
  var segment = content.segment,
      period = content.period;
  var data = response.data,
      isChunked = response.isChunked;

  if (isChunked) {
    throw new Error("Image data should not be downloaded in chunks");
  } // TODO image Parsing should be more on the sourceBuffer side, no?


  if (data === null || features_1.default.imageParser == null) {
    return rxjs_1.of({
      chunkData: null,
      chunkInfos: segment.timescale > 0 ? {
        duration: segment.isInit ? 0 : segment.duration,
        time: segment.isInit ? -1 : segment.time,
        timescale: segment.timescale
      } : null,
      chunkOffset: segment.timestampOffset || 0,
      appendWindow: [period.start, period.end]
    });
  }

  var bifObject = features_1.default.imageParser(new Uint8Array(data));
  var thumbsData = bifObject.thumbs;
  return rxjs_1.of({
    chunkData: {
      data: thumbsData,
      start: 0,
      end: Number.MAX_VALUE,
      timescale: 1,
      type: "bif"
    },
    chunkInfos: {
      time: 0,
      duration: Number.MAX_VALUE,
      timescale: bifObject.timescale
    },
    chunkOffset: segment.timestampOffset || 0,
    appendWindow: [period.start, period.end]
  });
}

exports.imageParser = imageParser;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","../../features":"../../../features/index.ts","../../utils/request":"../../../utils/request/index.ts"}],"../../../../node_modules/object-assign/index.js":[function(require,module,exports) {
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
'use strict';
/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};
},{}],"../../../utils/languages/ISO_639-1_to_ISO_639-3.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Translate ISO 639-1 language codes into ISO 639-3 ones.
 */

var ISO_MAP_1_TO_3 = {
  aa: "aar",
  ab: "abk",
  ae: "ave",
  af: "afr",
  ak: "aka",
  am: "amh",
  an: "arg",
  ar: "ara",
  as: "asm",
  av: "ava",
  ay: "aym",
  az: "aze",
  ba: "bak",
  be: "bel",
  bg: "bul",
  bi: "bis",
  bm: "bam",
  bn: "ben",
  bo: "bod",
  br: "bre",
  bs: "bos",
  ca: "cat",
  ce: "che",
  ch: "cha",
  co: "cos",
  cr: "cre",
  cs: "ces",
  cu: "chu",
  // Old Slavonic, Old Bulgarian
  cv: "chv",
  cy: "cym",
  da: "dan",
  de: "deu",
  dv: "div",
  dz: "dzo",
  ee: "ewe",
  el: "ell",
  en: "eng",
  eo: "epo",
  es: "spa",
  et: "est",
  eu: "eus",
  fa: "fas",
  ff: "ful",
  fi: "fin",
  fj: "fij",
  fo: "fao",
  fr: "fra",
  fy: "fry",
  ga: "gle",
  gd: "gla",
  gl: "glg",
  gn: "grn",
  gu: "guj",
  gv: "glv",
  ha: "hau",
  he: "heb",
  hi: "hin",
  ho: "hmo",
  hr: "hrv",
  ht: "hat",
  hu: "hun",
  hy: "hye",
  hz: "her",
  ia: "ina",
  id: "ind",
  ie: "ile",
  ig: "ibo",
  ii: "iii",
  ik: "ipk",
  io: "ido",
  is: "isl",
  it: "ita",
  iu: "iku",
  ja: "jpn",
  jv: "jav",
  ka: "kat",
  kg: "kon",
  ki: "kik",
  kj: "kua",
  kk: "kaz",
  kl: "kal",
  km: "khm",
  kn: "kan",
  ko: "kor",
  kr: "kau",
  ks: "kas",
  ku: "kur",
  kv: "kom",
  kw: "cor",
  ky: "kir",
  la: "lat",
  lb: "ltz",
  lg: "lug",
  li: "lim",
  ln: "lin",
  lo: "lao",
  lt: "lit",
  lu: "lub",
  lv: "lav",
  mg: "mlg",
  mh: "mah",
  mi: "mri",
  mk: "mkd",
  ml: "mal",
  mn: "mon",
  mr: "mar",
  ms: "msa",
  mt: "mlt",
  my: "mya",
  na: "nau",
  nb: "nob",
  nd: "nde",
  ne: "nep",
  ng: "ndo",
  nl: "nld",
  nn: "nno",
  no: "nor",
  nr: "nbl",
  nv: "nav",
  ny: "nya",
  oc: "oci",
  oj: "oji",
  om: "orm",
  or: "ori",
  os: "oss",
  pa: "pan",
  pi: "pli",
  pl: "pol",
  ps: "pus",
  pt: "por",
  qu: "que",
  rm: "roh",
  rn: "run",
  ro: "ron",
  ru: "rus",
  rw: "kin",
  sa: "san",
  sc: "srd",
  sd: "snd",
  se: "sme",
  sg: "sag",
  si: "sin",
  sk: "slk",
  sl: "slv",
  sm: "smo",
  sn: "sna",
  so: "som",
  sq: "sqi",
  sr: "srp",
  ss: "ssw",
  st: "sot",
  su: "sun",
  sv: "swe",
  sw: "swa",
  ta: "tam",
  te: "tel",
  tg: "tgk",
  th: "tha",
  ti: "tir",
  tk: "tuk",
  tl: "tgl",
  tn: "tsn",
  to: "ton",
  tr: "tur",
  ts: "tso",
  tt: "tat",
  tw: "twi",
  ty: "tah",
  ug: "uig",
  uk: "ukr",
  ur: "urd",
  uz: "uzb",
  ve: "ven",
  vi: "vie",
  vo: "vol",
  wa: "wln",
  wo: "wol",
  xh: "xho",
  yi: "yid",
  yo: "yor",
  za: "zha",
  zh: "zho",
  zu: "zul"
};
exports.default = ISO_MAP_1_TO_3;
},{}],"../../../utils/languages/ISO_639-2_to_ISO_639-3.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Translate ISO 639-2 synonyms to their ISO 639-3 counterparts.
 */

var ISO_MAP_2_TO_3 = {
  alb: "sqi",
  arm: "hye",
  baq: "eus",
  bur: "mya",
  chi: "zho",
  cze: "ces",
  dut: "nld",
  fre: "fra",
  geo: "kat",
  ger: "deu",
  gre: "ell",
  ice: "isl",
  mac: "mkd",
  mao: "mri",
  may: "msa",
  per: "fas",
  slo: "slk",
  rum: "ron",
  tib: "bod",
  wel: "cym"
};
exports.default = ISO_MAP_2_TO_3;
},{}],"../../../utils/languages/normalize.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var ISO_639_1_to_ISO_639_3_1 = __importDefault(require("./ISO_639-1_to_ISO_639-3"));

var ISO_639_2_to_ISO_639_3_1 = __importDefault(require("./ISO_639-2_to_ISO_639-3"));
/**
 * Normalize language given.
 * Basically:
 *   - converts it to lowercase.
 *   - normalize "base" (what is before the possible first "-") to an ISO639-3
 *     compatible string.
 * @param {string} _language
 * @returns {string}
 */


function normalizeLanguage(_language) {
  if (_language == null || _language === "") {
    return "";
  }

  var fields = ("" + _language).toLowerCase().split("-");

  var base = fields[0];
  var normalizedBase = normalizeBase(base);

  if (normalizedBase) {
    return normalizedBase;
  }

  return _language;
}
/**
 * Normalize language into an ISO639-3 format.
 * Returns undefined if it failed to do so
 * @param {string} base
 * @returns {string}
 */


function normalizeBase(base) {
  var result;

  switch (base.length) {
    case 2:
      result = ISO_639_1_to_ISO_639_3_1.default[base];
      break;

    case 3:
      result = ISO_639_2_to_ISO_639_3_1.default[base];
      break;
  }

  return result;
}
/**
 * Normalize text track from a user given input into an object
 * with three properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - closedCaption {Boolean}: Whether the track is a closed caption track
 * @param {Object|string|null|undefined} _language
 * @returns {Object|null|undefined}
 */


function normalizeTextTrack(_language) {
  if (_language != null) {
    var language;
    var closedCaption;

    if (typeof _language === "string") {
      language = _language;
      closedCaption = false;
    } else {
      language = _language.language;
      closedCaption = !!_language.closedCaption;
    }

    return {
      language: language,
      closedCaption: closedCaption,
      normalized: normalizeLanguage(language)
    };
  }

  return _language;
}

exports.normalizeTextTrack = normalizeTextTrack;
/**
 * Normalize audio track from a user given input into an object
 * with three properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - audioDescription {Boolean}: Whether the track is a closed caption track
 * @param {Object|string|null|undefined} _language
 * @returns {Object|null|undefined}
 */

function normalizeAudioTrack(_language) {
  if (_language != null) {
    var language;
    var audioDescription;

    if (typeof _language === "string") {
      language = _language;
      audioDescription = false;
    } else {
      language = _language.language;
      audioDescription = !!_language.audioDescription;
    }

    return {
      language: language,
      audioDescription: audioDescription,
      normalized: normalizeLanguage(language)
    };
  }

  return _language;
}

exports.normalizeAudioTrack = normalizeAudioTrack;
exports.default = normalizeLanguage;
},{"./ISO_639-1_to_ISO_639-3":"../../../utils/languages/ISO_639-1_to_ISO_639-3.ts","./ISO_639-2_to_ISO_639-3":"../../../utils/languages/ISO_639-2_to_ISO_639-3.ts"}],"../../../utils/languages/index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var normalize_1 = __importStar(require("./normalize"));

exports.INormalizedAudioTrackObject = normalize_1.INormalizedAudioTrackObject;
exports.INormalizedTextTrackObject = normalize_1.INormalizedTextTrackObject;
exports.normalizeAudioTrack = normalize_1.normalizeAudioTrack;
exports.normalizeTextTrack = normalize_1.normalizeTextTrack;
exports.default = normalize_1.default;
},{"./normalize":"../../../utils/languages/normalize.ts"}],"../../../utils/uniq.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Uniq implementation by combining a filter and an indexOf.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */

function uniqFromFilter(arr) {
  return arr.filter(function (val, i, self) {
    return self.indexOf(val) === i;
  });
}

exports.uniqFromFilter = uniqFromFilter;
/**
 * Uniq implementation by using the Set browser API.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */

function uniqFromSet(arr) {
  return Array.from(new Set(arr));
}

exports.uniqFromSet = uniqFromSet;
/**
 * Returns the input array without duplicates values.
 * All values are unique.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */

exports.default = typeof window.Set === "function" ? uniqFromSet : uniqFromFilter;
},{}],"../../../manifest/filter_supported_representations.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var compat_1 = require("../compat");
/**
 * Only keep Representations for which the codec is currently supported.
 * @param {string} adaptationType
 * @param {Array.<Object>} representations
 * @returns {Array.<Object>}
 */


function filterSupportedRepresentations(adaptationType, representations) {
  if (adaptationType === "audio" || adaptationType === "video") {
    return representations.filter(function (representation) {
      return compat_1.isCodecSupported(getCodec(representation));
    });
  }

  return representations; // TODO for the other types?
}

exports.default = filterSupportedRepresentations;
/**
 * Construct the codec string from given codecs and mimetype.
 * @param {Object} representation
 * @returns {string}
 */

function getCodec(representation) {
  var _representation$codec = representation.codecs,
      codecs = _representation$codec === void 0 ? "" : _representation$codec,
      _representation$mimeT = representation.mimeType,
      mimeType = _representation$mimeT === void 0 ? "" : _representation$mimeT;
  return "".concat(mimeType, ";codecs=\"").concat(codecs, "\"");
}
},{"../compat":"../../../compat/index.ts"}],"../../../manifest/representation.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Normalized Representation structure.
 * @class Representation
 */

var Representation =
/*#__PURE__*/
function () {
  /**
   * @param {Object} args
   */
  function Representation(args) {
    _classCallCheck(this, Representation);

    this.id = args.id;
    this.bitrate = args.bitrate;
    this.codec = args.codecs;

    if (args.height != null) {
      this.height = args.height;
    }

    if (args.width != null) {
      this.width = args.width;
    }

    if (args.mimeType != null) {
      this.mimeType = args.mimeType;
    }

    if (args.contentProtections) {
      this.contentProtections = args.contentProtections;
    }

    if (args.frameRate) {
      this.frameRate = args.frameRate;
    }

    this.index = args.index;
  }
  /**
   * Returns "mime-type string" which includes both the mime-type and the codec,
   * which is often needed when interacting with the browser's APIs.
   * @returns {string}
   */


  _createClass(Representation, [{
    key: "getMimeTypeString",
    value: function getMimeTypeString() {
      return "".concat(this.mimeType, ";codecs=\"").concat(this.codec, "\"");
    }
  }]);

  return Representation;
}();

exports.default = Representation;
},{}],"../../../manifest/adaptation.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var errors_1 = require("../errors");

var log_1 = __importDefault(require("../log"));

var array_find_1 = __importDefault(require("../utils/array_find"));

var array_includes_1 = __importDefault(require("../utils/array_includes"));

var languages_1 = __importDefault(require("../utils/languages"));

var uniq_1 = __importDefault(require("../utils/uniq"));

var filter_supported_representations_1 = __importDefault(require("./filter_supported_representations"));

var representation_1 = __importDefault(require("./representation"));

exports.SUPPORTED_ADAPTATIONS_TYPE = ["audio", "video", "text", "image"];

function isSupportedAdaptationType(adaptationType) {
  return array_includes_1.default(exports.SUPPORTED_ADAPTATIONS_TYPE, adaptationType);
}
/**
 * Normalized Adaptation structure.
 * An Adaptation describes a single `Track`. For example a specific audio
 * track (in a given language) or a specific video track.
 * It istelf can be represented in different qualities, which we call here
 * `Representation`.
 * @class Adaptation
 */


var Adaptation =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {Object} parsedAdaptation
   * @param {Object|undefined} [options]
   */
  function Adaptation(parsedAdaptation) {
    var _this = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Adaptation);

    var representationFilter = options.representationFilter,
        isManuallyAdded = options.isManuallyAdded;
    this.parsingErrors = [];
    this.id = parsedAdaptation.id;

    if (!isSupportedAdaptationType(parsedAdaptation.type)) {
      log_1.default.info("Manifest: Not supported adaptation type", parsedAdaptation.type);
      throw new errors_1.MediaError("MANIFEST_UNSUPPORTED_ADAPTATION_TYPE", "\"".concat(parsedAdaptation.type, "\" is not a valid ") + "Adaptation type.");
    }

    this.type = parsedAdaptation.type;
    var hadRepresentations = !!parsedAdaptation.representations.length;
    var argsRepresentations = filter_supported_representations_1.default(parsedAdaptation.type, parsedAdaptation.representations);

    if (hadRepresentations && argsRepresentations.length === 0) {
      log_1.default.warn("Incompatible codecs for adaptation", parsedAdaptation);
      var error = new errors_1.MediaError("MANIFEST_INCOMPATIBLE_CODECS_ERROR", "An Adaptation contains only incompatible codecs.");
      this.parsingErrors.push(error);
    }

    if (parsedAdaptation.language != null) {
      this.language = parsedAdaptation.language;
      this.normalizedLanguage = languages_1.default(parsedAdaptation.language);
    }

    if (parsedAdaptation.closedCaption != null) {
      this.isClosedCaption = parsedAdaptation.closedCaption;
    }

    if (parsedAdaptation.audioDescription != null) {
      this.isAudioDescription = parsedAdaptation.audioDescription;
    }

    this.representations = argsRepresentations.map(function (representation) {
      return new representation_1.default(representation);
    }).sort(function (a, b) {
      return a.bitrate - b.bitrate;
    }).filter(function (representation) {
      if (representationFilter == null) {
        return true;
      }

      return representationFilter(representation, {
        bufferType: _this.type,
        language: _this.language,
        normalizedLanguage: _this.normalizedLanguage,
        isClosedCaption: _this.isClosedCaption,
        isAudioDescription: _this.isAudioDescription
      });
    }); // for manuallyAdded adaptations (not in the manifest)

    this.manuallyAdded = !!isManuallyAdded;
  }
  /**
   * Returns unique bitrate for every Representation in this Adaptation.
   * @returns {Array.<Number>}
   */


  _createClass(Adaptation, [{
    key: "getAvailableBitrates",
    value: function getAvailableBitrates() {
      var bitrates = this.representations.map(function (r) {
        return r.bitrate;
      });
      return uniq_1.default(bitrates);
    }
    /**
     * Returns the Representation linked to the given ID.
     * @param {number|string} wantedId
     * @returns {Object|undefined}
     */

  }, {
    key: "getRepresentation",
    value: function getRepresentation(wantedId) {
      return array_find_1.default(this.representations, function (_ref) {
        var id = _ref.id;
        return wantedId === id;
      });
    }
  }]);

  return Adaptation;
}();

exports.default = Adaptation;
},{"../errors":"../../../errors/index.ts","../log":"../../../log.ts","../utils/array_find":"../../../utils/array_find.ts","../utils/array_includes":"../../../utils/array_includes.ts","../utils/languages":"../../../utils/languages/index.ts","../utils/uniq":"../../../utils/uniq.ts","./filter_supported_representations":"../../../manifest/filter_supported_representations.ts","./representation":"../../../manifest/representation.ts"}],"../../../manifest/are_same_content.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Check if two contents are the same
 * @param {Object} content1
 * @param {Object} content2
 * @returns {boolean}
 */

function areSameContent(content1, content2) {
  return content1.segment.id === content2.segment.id && content1.representation.id === content2.representation.id && content1.adaptation.id === content2.adaptation.id && content1.period.id === content2.period.id;
}

exports.default = areSameContent;
},{}],"../../../utils/id_generator.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Creates an ID generator which generates an ID each time you call it.
 * @returns {Function}
 */

function idGenerator() {
  var lastID = 0;
  return function generateNewId() {
    return "" + lastID++;
  };
}

exports.default = idGenerator;
},{}],"../../../utils/warn_once.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var array_includes_1 = __importDefault(require("./array_includes"));

var WARNED_MESSAGES = [];
/**
 * Perform a console.warn only once in the application lifetime.
 *
 * Useful for deprecated messages, for example.
 *
 * @param {string} message
 */

function warnOnce(message) {
  if (!array_includes_1.default(WARNED_MESSAGES, message)) {
    /* tslint:disable no-console */
    console.warn(message);
    /* tslint:enable no-console */

    WARNED_MESSAGES.push(message);
  }
}

exports.default = warnOnce;
},{"./array_includes":"../../../utils/array_includes.ts"}],"../../../utils/object_values.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @param {Object|Array} o
 * @returns {Array.<*>}
 */

function objectValues(o) {
  return Object.keys(o).map(function (k) {
    return o[k];
  });
}

exports.objectValues = objectValues;
/* tslint:disable no-unbound-method */

exports.default = typeof Object.values === "function" ? Object.values : objectValues;
},{}],"../../../manifest/period.ts":[function(require,module,exports) {
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var errors_1 = require("../errors");

var array_find_1 = __importDefault(require("../utils/array_find"));

var object_values_1 = __importDefault(require("../utils/object_values"));

var adaptation_1 = __importDefault(require("./adaptation"));
/**
 * Class representing a single `Period` of the Manifest.
 * A Period contains every information about the content available for a
 * specific period in time.
 * @class Period
 */


var Period =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {Object} args
   * @param {function|undefined} [representationFilter]
   */
  function Period(args, representationFilter) {
    var _this = this;

    _classCallCheck(this, Period);

    this.parsingErrors = [];
    this.id = args.id;
    this.adaptations = Object.keys(args.adaptations).reduce(function (acc, type) {
      var adaptationsForType = args.adaptations[type];

      if (!adaptationsForType) {
        return acc;
      }

      var filteredAdaptations = adaptationsForType.map(function (adaptation) {
        var _this$parsingErrors;

        var newAdaptation = null;

        try {
          newAdaptation = new adaptation_1.default(adaptation, {
            representationFilter: representationFilter
          });
        } catch (err) {
          if (err.code === "MANIFEST_UNSUPPORTED_ADAPTATION_TYPE") {
            _this.parsingErrors.push(err);

            return null;
          }

          throw err;
        }

        (_this$parsingErrors = _this.parsingErrors).push.apply(_this$parsingErrors, _toConsumableArray(newAdaptation.parsingErrors));

        return newAdaptation;
      }).filter(function (adaptation) {
        return adaptation != null && adaptation.representations.length > 0;
      });

      if (filteredAdaptations.length === 0 && adaptationsForType.length > 0 && (type === "video" || type === "audio")) {
        throw new errors_1.MediaError("MANIFEST_PARSE_ERROR", "No supported " + type + " adaptations");
      }

      if (filteredAdaptations.length) {
        acc[type] = filteredAdaptations;
      }

      return acc;
    }, {});

    if (!this.adaptations.video && !this.adaptations.audio) {
      throw new errors_1.MediaError("MANIFEST_PARSE_ERROR", "No supported audio and video tracks.");
    }

    this.duration = args.duration;
    this.start = args.start;

    if (this.duration != null && this.start != null) {
      this.end = this.start + this.duration;
    }
  }
  /**
   * Returns every `Adaptations` (or `tracks`) linked to that Period, in an
   * Array.
   * @returns {Array.<Object>}
   */


  _createClass(Period, [{
    key: "getAdaptations",
    value: function getAdaptations() {
      var adaptationsByType = this.adaptations;
      return object_values_1.default(adaptationsByType).reduce(function (acc, adaptations) {
        return (// Note: the second case cannot happen. TS is just being dumb here
          adaptations != null ? acc.concat(adaptations) : acc
        );
      }, []);
    }
    /**
     * Returns every `Adaptations` (or `tracks`) linked to that Period for a
     * given type.
     * @param {string} adaptationType
     * @returns {Array.<Object>}
     */

  }, {
    key: "getAdaptationsForType",
    value: function getAdaptationsForType(adaptationType) {
      return this.adaptations[adaptationType] || [];
    }
    /**
     * Returns the Adaptation linked to the given ID.
     * @param {number|string} wantedId
     * @returns {Object|undefined}
     */

  }, {
    key: "getAdaptation",
    value: function getAdaptation(wantedId) {
      return array_find_1.default(this.getAdaptations(), function (_ref) {
        var id = _ref.id;
        return wantedId === id;
      });
    }
  }]);

  return Period;
}();

exports.default = Period;
},{"../errors":"../../../errors/index.ts","../utils/array_find":"../../../utils/array_find.ts","../utils/object_values":"../../../utils/object_values.ts","./adaptation":"../../../manifest/adaptation.ts"}],"../../../manifest/representation_index/static.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../log"));
/**
 * Simple RepresentationIndex implementation for static files.
 * @class StaticRepresentationIndex
 */


var StaticRepresentationIndex =
/*#__PURE__*/
function () {
  /**
   * @param {Object} infos
   */
  function StaticRepresentationIndex(infos) {
    _classCallCheck(this, StaticRepresentationIndex);

    this._mediaURL = infos.media;
  }
  /**
   * Static contents do not have any initialization segments.
   * Just return null.
   * @returns {null}
   */


  _createClass(StaticRepresentationIndex, [{
    key: "getInitSegment",
    value: function getInitSegment() {
      return null;
    }
    /**
     * Returns the only Segment available here.
     * @returns {Array.<Object>}
     */

  }, {
    key: "getSegments",
    value: function getSegments() {
      return [{
        id: "0",
        isInit: false,
        number: 0,
        time: 0,
        duration: Number.MAX_VALUE,
        timescale: 1,
        mediaURL: this._mediaURL
      }];
    }
    /**
     * Returns first position in index.
     * @returns {undefined}
     */

  }, {
    key: "getFirstPosition",
    value: function getFirstPosition() {
      return;
      /* tslint:enable return-undefined */
    }
    /**
     * Returns last position in index.
     * @returns {undefined}
     */

  }, {
    key: "getLastPosition",
    value: function getLastPosition() {
      return;
    }
    /**
     * Returns false as a static file never need to be refreshed.
     * @returns {Boolean}
     */

  }, {
    key: "shouldRefresh",
    value: function shouldRefresh() {
      return false;
    }
    /**
     * @returns {Number}
     */

  }, {
    key: "checkDiscontinuity",
    value: function checkDiscontinuity() {
      return -1;
    }
    /**
     * Returns true as a static file should never need lose availability.
     * @returns {Boolean}
     */

  }, {
    key: "isSegmentStillAvailable",
    value: function isSegmentStillAvailable() {
      return true;
    }
    /**
     * @returns {Boolean}
     */

  }, {
    key: "canBeOutOfSyncError",
    value: function canBeOutOfSyncError() {
      return false;
    }
    /**
     * @returns {Boolean}
     */

  }, {
    key: "isFinished",
    value: function isFinished() {
      return true;
    }
  }, {
    key: "_addSegments",
    value: function _addSegments() {
      log_1.default.warn("Tried add Segments to a static RepresentationIndex");
    }
  }, {
    key: "_update",
    value: function _update() {
      log_1.default.warn("Tried to update a static RepresentationIndex");
    }
  }]);

  return StaticRepresentationIndex;
}();

exports.default = StaticRepresentationIndex;
},{"../../log":"../../../log.ts"}],"../../../manifest/representation_index/types.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../../../manifest/representation_index/index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var static_1 = __importDefault(require("./static"));

exports.StaticRepresentationIndex = static_1.default;

var types_1 = __importStar(require("./types"));

exports.IBaseContentInfos = types_1.IBaseContentInfos;
exports.IMetaPlaylistPrivateInfos = types_1.IMetaPlaylistPrivateInfos;
exports.ISegment = types_1.ISegment;
exports.default = types_1.default;
},{"./static":"../../../manifest/representation_index/static.ts","./types":"../../../manifest/representation_index/types.ts"}],"../../../manifest/update_period_in_place.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../log"));

var array_find_1 = __importDefault(require("../utils/array_find"));
/**
 * Update oldPeriod attributes with the one from newPeriod (e.g. when updating
 * the Manifest).
 * @param {Object} oldPeriod
 * @param {Object} newPeriod
 */


function updatePeriodInPlace(oldPeriod, newPeriod) {
  oldPeriod.start = newPeriod.start;
  oldPeriod.end = newPeriod.end;
  oldPeriod.duration = newPeriod.duration;
  var oldAdaptations = oldPeriod.getAdaptations();
  var newAdaptations = newPeriod.getAdaptations();

  var _loop = function _loop(j) {
    var oldAdaptation = oldAdaptations[j];
    var newAdaptation = array_find_1.default(newAdaptations, function (a) {
      return a.id === oldAdaptation.id;
    });

    if (!newAdaptation) {
      log_1.default.warn("Manifest: Adaptation \"" + oldAdaptations[j].id + "\" not found when merging.");
    } else {
      var oldRepresentations = oldAdaptations[j].representations;
      var newRepresentations = newAdaptation.representations;

      var _loop2 = function _loop2(k) {
        var oldRepresentation = oldRepresentations[k];
        var newRepresentation = array_find_1.default(newRepresentations, function (representation) {
          return representation.id === oldRepresentation.id;
        });

        if (!newRepresentation) {
          log_1.default.warn("Manifest: Representation \"" + oldRepresentations[k].id + "\" not found when merging.");
        } else {
          oldRepresentation.index._update(newRepresentation.index);
        }
      };

      for (var k = 0; k < oldRepresentations.length; k++) {
        _loop2(k);
      }
    }
  };

  for (var j = 0; j < oldAdaptations.length; j++) {
    _loop(j);
  }
}

exports.default = updatePeriodInPlace;
},{"../log":"../../../log.ts","../utils/array_find":"../../../utils/array_find.ts"}],"../../../manifest/update_periods.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../log"));

var update_period_in_place_1 = __importDefault(require("./update_period_in_place"));
/**
 * Update old periods by adding new periods and removing
 * not available ones.
 * @param {Array.<Object>} oldPeriods
 * @param {Array.<Object>} newPeriods
 */


function updatePeriods(oldPeriods, newPeriods) {
  var firstUnhandledPeriodIdx = 0; // Example :
  //
  // old periods : [p0] [p2] [pX] [pF]
  // new periods : [p1] [p2] [pM] [pX] [pU]
  //
  // The `for` loop will remove old periods and replace new ones
  // between the common periods between the two, in the old periods array.
  //
  // - Step 1 : Handle common period p2
  //    - the p0 is removed the p2
  //    - the p1 is added before the p2
  //
  //                   First unhandled period index
  //                             |
  //                             v
  //    old periods : [p1] [p2] [pX] [pF]
  //    new periods : [p1] [p2] [pM] [pX] [pU]
  //
  // - Step 2 : Handle common period pX
  //    - the pM is added before the pX
  //
  //                              First unhandled period index
  //                                        |
  //                                        v
  // old periods : [p1]  [p2]  [pM]  [pX]  [pF]
  // new periods : [p1]  [p2]  [pM]  [pX]  [pU]

  for (var i = 0; i < newPeriods.length; i++) {
    var newPeriod = newPeriods[i];
    var j = firstUnhandledPeriodIdx;
    var oldPeriod = oldPeriods[j];

    while (oldPeriod != null && oldPeriod.id !== newPeriod.id) {
      j++;
      oldPeriod = oldPeriods[j];
    }

    if (oldPeriod != null) {
      update_period_in_place_1.default(oldPeriod, newPeriod);
      var periodsToInclude = newPeriods.slice(firstUnhandledPeriodIdx, i);
      oldPeriods.splice.apply(oldPeriods, [j, 0].concat(_toConsumableArray(periodsToInclude)));
      firstUnhandledPeriodIdx = i + 1;
    }
  }

  if (firstUnhandledPeriodIdx > oldPeriods.length) {
    log_1.default.error("Manifest: error when updating Periods");
    return;
  } // At this point, the first unhandled period index refers to the first
  // position from which :
  // - there are only undesired periods in old periods array.
  // - there only new wanted periods in new periods array.
  //
  //                              First unhandled period index
  //                                        |
  //                                        v
  // old periods : [p1]  [p2]  [pM]  [pX]  [pF (undesired)]
  // new periods : [p1]  [p2]  [pM]  [pX]  [pU (wanted)]
  //
  // final array (old periods array) : [p1]  [p2]  [pM]  [pX]  [pU]


  if (firstUnhandledPeriodIdx < oldPeriods.length) {
    oldPeriods.splice(firstUnhandledPeriodIdx, oldPeriods.length - firstUnhandledPeriodIdx);
  }

  var remainingNewPeriods = newPeriods.slice(firstUnhandledPeriodIdx, newPeriods.length);

  if (remainingNewPeriods.length > 0) {
    oldPeriods.push.apply(oldPeriods, _toConsumableArray(remainingNewPeriods));
  }
}

exports.default = updatePeriods;
},{"../log":"../../../log.ts","./update_period_in_place":"../../../manifest/update_period_in_place.ts"}],"../../../manifest/manifest.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../log"));

var array_find_1 = __importDefault(require("../utils/array_find"));

var event_emitter_1 = __importDefault(require("../utils/event_emitter"));

var id_generator_1 = __importDefault(require("../utils/id_generator"));

var warn_once_1 = __importDefault(require("../utils/warn_once"));

var adaptation_1 = __importDefault(require("./adaptation"));

var period_1 = __importDefault(require("./period"));

var representation_index_1 = require("./representation_index");

var update_periods_1 = __importDefault(require("./update_periods"));

var generateNewId = id_generator_1.default();
/**
 * Normalized Manifest structure.
 * Details the current content being played:
 *   - the duration of the content
 *   - the available tracks
 *   - the available qualities
 *   - the segments defined in those qualities
 *   - ...
 * while staying agnostic of the transport protocol used (Smooth or DASH).
 *
 * The Manifest and its contained information can evolve over time (like when
 * updating a dynamic manifest of when right management forbid some tracks from
 * being played).
 * To perform actions on those changes, any module using this Manifest can
 * listen to its sent events and react accordingly.
 * @class Manifest
 */

var Manifest =
/*#__PURE__*/
function (_event_emitter_1$defa) {
  _inherits(Manifest, _event_emitter_1$defa);

  /**
   * @param {Object} args
   */
  function Manifest(args, options) {
    var _this;

    _classCallCheck(this, Manifest);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Manifest).call(this));
    var _options$supplementar = options.supplementaryTextTracks,
        supplementaryTextTracks = _options$supplementar === void 0 ? [] : _options$supplementar,
        _options$supplementar2 = options.supplementaryImageTracks,
        supplementaryImageTracks = _options$supplementar2 === void 0 ? [] : _options$supplementar2,
        representationFilter = options.representationFilter;
    _this.parsingErrors = [];
    _this.id = args.id;
    _this.transport = args.transportType;
    _this._clockOffset = args.clockOffset;
    _this.periods = args.periods.map(function (period) {
      var _this$parsingErrors;

      var parsedPeriod = new period_1.default(period, representationFilter);

      (_this$parsingErrors = _this.parsingErrors).push.apply(_this$parsingErrors, _toConsumableArray(parsedPeriod.parsingErrors));

      return parsedPeriod;
    }).sort(function (a, b) {
      return a.start - b.start;
    });
    /**
     * @deprecated It is here to ensure compatibility with the way the
     * v3.x.x manages adaptations at the Manifest level
     */

    /* tslint:disable:deprecation */

    _this.adaptations = _this.periods[0] && _this.periods[0].adaptations || {};
    /* tslint:enable:deprecation */

    _this.minimumTime = args.minimumTime;
    _this.isDynamic = args.isDynamic;
    _this.isLive = args.isLive;
    _this.uris = args.uris || [];
    _this.lifetime = args.lifetime;
    _this.suggestedPresentationDelay = args.suggestedPresentationDelay;
    _this.availabilityStartTime = args.availabilityStartTime;
    _this.maximumTime = args.maximumTime;
    _this.baseURL = args.baseURL;

    if (!args.isDynamic && args.duration == null) {
      log_1.default.warn("Manifest: non dynamic content and duration is null.");
    }

    _this._duration = args.duration;

    if (supplementaryImageTracks.length) {
      _this.addSupplementaryImageAdaptations(supplementaryImageTracks);
    }

    if (supplementaryTextTracks.length) {
      _this.addSupplementaryTextAdaptations(supplementaryTextTracks);
    }

    return _this;
  }
  /**
   * Returns Period encountered at the given time.
   * Returns undefined if there is no Period exactly at the given time.
   * @param {number} time
   * @returns {Period|undefined}
   */


  _createClass(Manifest, [{
    key: "getPeriodForTime",
    value: function getPeriodForTime(time) {
      return array_find_1.default(this.periods, function (period) {
        return time >= period.start && (period.end == null || period.end > time);
      });
    }
    /**
     * Returns period coming just after a given period.
     * Returns undefined if not found.
     * @param {Period} period
     * @returns {Period|null}
     */

  }, {
    key: "getPeriodAfter",
    value: function getPeriodAfter(period) {
      var endOfPeriod = period.end;

      if (endOfPeriod == null) {
        return null;
      }

      return array_find_1.default(this.periods, function (_period) {
        return _period.end == null || endOfPeriod < _period.end;
      }) || null;
    }
    /**
     * Returns the duration of the whole content described by that Manifest.
     * @returns {Number}
     */

  }, {
    key: "getDuration",
    value: function getDuration() {
      return this._duration;
    }
    /**
     * Returns the most important URL from which the Manifest can be refreshed.
     * @returns {string|undefined}
     */

  }, {
    key: "getUrl",
    value: function getUrl() {
      return this.uris[0];
    }
    /**
     * @deprecated only returns adaptations for the first period
     * @returns {Array.<Object>}
     */

  }, {
    key: "getAdaptations",
    value: function getAdaptations() {
      warn_once_1.default("manifest.getAdaptations() is deprecated." + " Please use manifest.period[].getAdaptations() instead");
      var firstPeriod = this.periods[0];

      if (!firstPeriod) {
        return [];
      }

      var adaptationsByType = firstPeriod.adaptations;
      var adaptationsList = [];

      for (var adaptationType in adaptationsByType) {
        if (adaptationsByType.hasOwnProperty(adaptationType)) {
          var adaptations = adaptationsByType[adaptationType];
          adaptationsList.push.apply(adaptationsList, _toConsumableArray(adaptations));
        }
      }

      return adaptationsList;
    }
    /**
     * @deprecated only returns adaptations for the first period
     * @returns {Array.<Object>}
     */

  }, {
    key: "getAdaptationsForType",
    value: function getAdaptationsForType(adaptationType) {
      warn_once_1.default("manifest.getAdaptationsForType(type) is deprecated." + " Please use manifest.period[].getAdaptationsForType(type) instead");
      var firstPeriod = this.periods[0];

      if (!firstPeriod) {
        return [];
      }

      return firstPeriod.adaptations[adaptationType] || [];
    }
    /**
     * @deprecated only returns adaptations for the first period
     * @returns {Array.<Object>}
     */

  }, {
    key: "getAdaptation",
    value: function getAdaptation(wantedId) {
      warn_once_1.default("manifest.getAdaptation(id) is deprecated." + " Please use manifest.period[].getAdaptation(id) instead");
      /* tslint:disable:deprecation */

      return array_find_1.default(this.getAdaptations(), function (_ref) {
        var id = _ref.id;
        return wantedId === id;
      });
      /* tslint:enable:deprecation */
    }
    /**
     * Update the current manifest properties
     * @param {Object} Manifest
     */

  }, {
    key: "update",
    value: function update(newManifest) {
      this._duration = newManifest.getDuration();
      /* tslint:disable:deprecation */

      this.adaptations = newManifest.adaptations;
      /* tslint:enable:deprecation */

      this.availabilityStartTime = newManifest.availabilityStartTime;
      this.baseURL = newManifest.baseURL;
      this.id = newManifest.id;
      this.isDynamic = newManifest.isDynamic;
      this.isLive = newManifest.isLive;
      this.lifetime = newManifest.lifetime;
      this.maximumTime = newManifest.maximumTime;
      this.minimumTime = newManifest.minimumTime;
      this.parsingErrors = newManifest.parsingErrors;
      this.suggestedPresentationDelay = newManifest.suggestedPresentationDelay;
      this.transport = newManifest.transport;
      this.uris = newManifest.uris;
      update_periods_1.default(this.periods, newManifest.periods);
      this.trigger("manifestUpdate", null);
    }
    /**
     * Get minimum position currently defined by the Manifest, in seconds.
     * @returns {number}
     */

  }, {
    key: "getMinimumPosition",
    value: function getMinimumPosition() {
      var minimumTime = this.minimumTime;

      if (minimumTime == null) {
        return 0;
      }

      if (!minimumTime.isContinuous) {
        return minimumTime.value;
      }

      var timeDiff = performance.now() - minimumTime.time;
      return minimumTime.value + timeDiff / 1000;
    }
    /**
     * Get maximum position currently defined by the Manifest, in seconds.
     * @returns {number}
     */

  }, {
    key: "getMaximumPosition",
    value: function getMaximumPosition() {
      if (!this.isDynamic) {
        var duration = this.getDuration();
        return duration == null ? Infinity : duration;
      }

      var maximumTime = this.maximumTime;

      if (maximumTime == null) {
        var ast = this.availabilityStartTime || 0;

        if (this._clockOffset == null) {
          // server's time not known, rely on user's clock
          return Date.now() / 1000 - ast;
        }

        var serverTime = performance.now() + this._clockOffset;

        return serverTime / 1000 - ast;
      }

      if (!maximumTime.isContinuous) {
        return maximumTime.value;
      }

      var timeDiff = performance.now() - maximumTime.time;
      return maximumTime.value + timeDiff / 1000;
    }
    /**
     * If true, this Manifest is currently synchronized with the server's clock.
     * @returns {Boolean}
     */

  }, {
    key: "getClockOffset",
    value: function getClockOffset() {
      return this._clockOffset;
    }
    /**
     * Add supplementary image Adaptation(s) to the manifest.
     * @private
     * @param {Object|Array.<Object>} imageTracks
     */

  }, {
    key: "addSupplementaryImageAdaptations",
    value: function addSupplementaryImageAdaptations(imageTracks) {
      var _this2 = this;

      var _imageTracks = Array.isArray(imageTracks) ? imageTracks : [imageTracks];

      var newImageTracks = _imageTracks.map(function (_ref2) {
        var _this2$parsingErrors;

        var mimeType = _ref2.mimeType,
            url = _ref2.url;
        var adaptationID = "gen-image-ada-" + generateNewId();
        var representationID = "gen-image-rep-" + generateNewId();
        var newAdaptation = new adaptation_1.default({
          id: adaptationID,
          type: "image",
          representations: [{
            bitrate: 0,
            id: representationID,
            mimeType: mimeType,
            index: new representation_index_1.StaticRepresentationIndex({
              media: url
            })
          }]
        }, {
          isManuallyAdded: true
        });

        (_this2$parsingErrors = _this2.parsingErrors).push.apply(_this2$parsingErrors, _toConsumableArray(newAdaptation.parsingErrors));

        return newAdaptation;
      });

      if (newImageTracks.length && this.periods.length) {
        var adaptations = this.periods[0].adaptations;
        adaptations.image = adaptations.image ? adaptations.image.concat(newImageTracks) : newImageTracks;
      }
    }
    /**
     * Add supplementary text Adaptation(s) to the manifest.
     * @private
     * @param {Object|Array.<Object>} textTracks
     */

  }, {
    key: "addSupplementaryTextAdaptations",
    value: function addSupplementaryTextAdaptations(textTracks) {
      var _this3 = this;

      var _textTracks = Array.isArray(textTracks) ? textTracks : [textTracks];

      var newTextAdaptations = _textTracks.reduce(function (allSubs, _ref3) {
        var mimeType = _ref3.mimeType,
            codecs = _ref3.codecs,
            url = _ref3.url,
            language = _ref3.language,
            languages = _ref3.languages,
            closedCaption = _ref3.closedCaption;
        var langsToMapOn = language ? [language] : languages || [];
        return allSubs.concat(langsToMapOn.map(function (_language) {
          var _this3$parsingErrors;

          var adaptationID = "gen-text-ada-" + generateNewId();
          var representationID = "gen-text-rep-" + generateNewId();
          var newAdaptation = new adaptation_1.default({
            id: adaptationID,
            type: "text",
            language: _language,
            closedCaption: closedCaption,
            representations: [{
              bitrate: 0,
              id: representationID,
              mimeType: mimeType,
              codecs: codecs,
              index: new representation_index_1.StaticRepresentationIndex({
                media: url
              })
            }]
          }, {
            isManuallyAdded: true
          });

          (_this3$parsingErrors = _this3.parsingErrors).push.apply(_this3$parsingErrors, _toConsumableArray(newAdaptation.parsingErrors));

          return newAdaptation;
        }));
      }, []);

      if (newTextAdaptations.length && this.periods.length) {
        var adaptations = this.periods[0].adaptations;
        adaptations.text = adaptations.text ? adaptations.text.concat(newTextAdaptations) : newTextAdaptations;
      }
    }
  }]);

  return Manifest;
}(event_emitter_1.default);

exports.default = Manifest;
},{"../log":"../../../log.ts","../utils/array_find":"../../../utils/array_find.ts","../utils/event_emitter":"../../../utils/event_emitter.ts","../utils/id_generator":"../../../utils/id_generator.ts","../utils/warn_once":"../../../utils/warn_once.ts","./adaptation":"../../../manifest/adaptation.ts","./period":"../../../manifest/period.ts","./representation_index":"../../../manifest/representation_index/index.ts","./update_periods":"../../../manifest/update_periods.ts"}],"../../../manifest/index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var adaptation_1 = __importStar(require("./adaptation"));

exports.Adaptation = adaptation_1.default;
exports.IAdaptationType = adaptation_1.IAdaptationType;
exports.IRepresentationFilter = adaptation_1.IRepresentationFilter;
exports.SUPPORTED_ADAPTATIONS_TYPE = adaptation_1.SUPPORTED_ADAPTATIONS_TYPE;

var are_same_content_1 = __importDefault(require("./are_same_content"));

exports.areSameContent = are_same_content_1.default;

var manifest_1 = __importStar(require("./manifest"));

exports.IManifestParsingOptions = manifest_1.IManifestParsingOptions;
exports.ISupplementaryImageTrack = manifest_1.ISupplementaryImageTrack;
exports.ISupplementaryTextTrack = manifest_1.ISupplementaryTextTrack;

var period_1 = __importDefault(require("./period"));

exports.Period = period_1.default;

var representation_1 = __importDefault(require("./representation"));

exports.Representation = representation_1.default;

var representation_index_1 = __importStar(require("./representation_index"));

exports.IRepresentationIndex = representation_index_1.default;
exports.IBaseContentInfos = representation_index_1.IBaseContentInfos;
exports.IMetaPlaylistPrivateInfos = representation_index_1.IMetaPlaylistPrivateInfos;
exports.ISegment = representation_index_1.ISegment;
exports.StaticRepresentationIndex = representation_index_1.StaticRepresentationIndex;
exports.default = manifest_1.default;
},{"./adaptation":"../../../manifest/adaptation.ts","./are_same_content":"../../../manifest/are_same_content.ts","./manifest":"../../../manifest/manifest.ts","./period":"../../../manifest/period.ts","./representation":"../../../manifest/representation.ts","./representation_index":"../../../manifest/representation_index/index.ts"}],"../../../utils/resolve_url.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
}); // Scheme part of an url (e.g. "http://").

var schemeRe = /^(?:[a-z]+:)?\/\//i; // Captures "/../" or "/./".

var selfDirRe = /\/\.{1,2}\//;
/**
 * Resolve self directory and previous directory references to obtain a
 * "normalized" url.
 * @example "https://foo.bar/baz/booz/../biz" => "https://foo.bar/baz/biz"
 * @param {string} url
 * @returns {string}
 */

function _normalizeUrl(url) {
  // fast path if no ./ or ../ are present in the url
  if (!selfDirRe.test(url)) {
    return url;
  }

  var newUrl = [];
  var oldUrl = url.split("/");

  for (var i = 0, l = oldUrl.length; i < l; i++) {
    if (oldUrl[i] === "..") {
      newUrl.pop();
    } else if (oldUrl[i] === ".") {
      continue;
    } else {
      newUrl.push(oldUrl[i]);
    }
  }

  return newUrl.join("/");
}
/**
 * Construct an url from the arguments given.
 * Basically:
 *   - The last arguments that contains a scheme (e.g. "http://") is the base
 *     of the url.
 *   - every subsequent string arguments are concatened to it.
 * @param {...string|undefined} args
 * @returns {string}
 */


function resolveURL() {
  var len = arguments.length;

  if (len === 0) {
    return "";
  }

  var base = "";

  for (var i = 0; i < len; i++) {
    var part = i < 0 || arguments.length <= i ? undefined : arguments[i];

    if (typeof part !== "string" || part === "") {
      continue;
    }

    if (schemeRe.test(part)) {
      base = part;
    } else {
      // trim if begins with "/"
      if (part[0] === "/") {
        part = part.substring(1);
      } // trim if ends with "/"


      if (base[base.length - 1] === "/") {
        base = base.substring(0, base.length - 1);
      }

      base = base + "/" + part;
    }
  }

  return _normalizeUrl(base);
}

exports.default = resolveURL;
/**
 * Remove string after the last '/'.
 * @param {string} url
 * @returns {string}
 */

function normalizeBaseURL(url) {
  var slash = url.lastIndexOf("/");

  if (slash >= 0) {
    return url.substring(0, slash + 1);
  } else {
    return url;
  }
}

exports.normalizeBaseURL = normalizeBaseURL;
},{}],"../../../parsers/manifest/utils/check_manifest_ids.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../../log"));

var array_includes_1 = __importDefault(require("../../../utils/array_includes"));
/**
 * Ensure that no two periods, adaptations from the same period and
 * representations from the same adaptation, have the same ID.
 *
 * Log and mutate their ID if not until this is verified.
 *
 * @param {Object} manifest
 */


function checkManifestIDs(manifest) {
  var periodIDS = [];
  manifest.periods.forEach(function (period) {
    var periodID = period.id;

    if (array_includes_1.default(periodIDS, periodID)) {
      log_1.default.warn("Two periods with the same ID found. Updating.");
      var newID = periodID + "-dup";
      period.id = newID;
      checkManifestIDs(manifest);
      periodIDS.push(newID);
    } else {
      periodIDS.push(periodID);
    }

    var adaptations = period.adaptations;
    var adaptationIDs = [];
    Object.keys(adaptations).forEach(function (type) {
      (adaptations[type] || []).forEach(function (adaptation) {
        var adaptationID = adaptation.id;

        if (array_includes_1.default(adaptationIDs, adaptationID)) {
          log_1.default.warn("Two adaptations with the same ID found. Updating.", adaptationID);

          var _newID = adaptationID + "-dup";

          adaptation.id = _newID;
          checkManifestIDs(manifest);
          adaptationIDs.push(_newID);
        } else {
          adaptationIDs.push(adaptationID);
        }

        var representationIDs = [];
        adaptation.representations.forEach(function (representation) {
          var representationID = representation.id;

          if (array_includes_1.default(representationIDs, representationID)) {
            log_1.default.warn("Two representations with the same ID found. Updating.", representationID);

            var _newID2 = representationID + "-dup";

            representation.id = _newID2;
            checkManifestIDs(manifest);
            representationIDs.push(_newID2);
          } else {
            representationIDs.push(representationID);
          }
        });
      });
    });
  });
}

exports.default = checkManifestIDs;
},{"../../../log":"../../../log.ts","../../../utils/array_includes":"../../../utils/array_includes.ts"}],"../../../parsers/manifest/dash/get_clock_offset.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../../log"));
/**
 * Get difference between the server's clock, in milliseconds and the return of
 * the JS function `performance.now`.
 * This property allows to calculate the server time at any moment.
 *
 * `undefined` if we could not define such offset (in which case, you could have
 * to rely on the user's clock instead).
 *
 * For example, a response of 1000 would mean that performance.now() is 1 second
 * behind the server's time.
 * @param {string} serverClock
 * @returns {number|undefined}
 */


function getClockOffset(serverClock) {
  var httpOffset = Date.parse(serverClock) - performance.now();

  if (isNaN(httpOffset)) {
    log_1.default.warn("DASH Parser: Invalid clock received: ", serverClock);
    return undefined;
  }

  return httpOffset;
}

exports.default = getClockOffset;
},{"../../../log":"../../../log.ts"}],"../../../parsers/manifest/dash/get_http_utc-timing_url.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @param {Object} mpdIR
 * @returns {string|undefined}
 */

function getHTTPUTCTimingURL(mpdIR) {
  var UTCTimingHTTP = mpdIR.children.utcTimings.filter(function (utcTiming) {
    return utcTiming.schemeIdUri === "urn:mpeg:dash:utc:http-iso:2014" && utcTiming.value != null;
  });
  return UTCTimingHTTP.length > 0 ? UTCTimingHTTP[0].value : undefined;
}

exports.default = getHTTPUTCTimingURL;
},{}],"../../../parsers/manifest/dash/get_last_time_from_adaptation.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Returns "last time of reference" from the adaptation given, considering a
 * dynamic content.
 * Undefined if a time could not be found.
 * Null if the Adaptation has no segments (it could be that it didn't started or
 * that it already finished for example).
 *
 * We consider the earliest last time from every representations in the given
 * adaptation.
 * @param {Object} adaptation
 * @returns {Number|undefined|null}
 */

function getLastPositionFromAdaptation(adaptation) {
  var representations = adaptation.representations;
  var min = null;

  for (var i = 0; i < representations.length; i++) {
    var lastPosition = representations[i].index.getLastPosition();

    if (lastPosition === undefined) {
      // we cannot tell
      return undefined;
    }

    if (lastPosition !== null) {
      min = min == null ? lastPosition : Math.min(min, lastPosition);
    }
  }

  if (min === null) {
    // It means that all positions were null === no segments (yet?)
    return null;
  }

  return min;
}

exports.default = getLastPositionFromAdaptation;
},{}],"../../../parsers/manifest/dash/get_maximum_position.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../../log"));

var get_last_time_from_adaptation_1 = __importDefault(require("./get_last_time_from_adaptation"));
/**
 * @param {Object} manifest
 * @returns {number | undefined}
 */


function getMaximumPosition(manifest) {
  for (var i = manifest.periods.length - 1; i >= 0; i--) {
    var periodAdaptations = manifest.periods[i].adaptations;
    var firstAudioAdaptationFromPeriod = periodAdaptations.audio == null ? undefined : periodAdaptations.audio[0];
    var firstVideoAdaptationFromPeriod = periodAdaptations.video == null ? undefined : periodAdaptations.video[0];

    if (firstAudioAdaptationFromPeriod != null || firstVideoAdaptationFromPeriod != null) {
      // null == no segment
      var maximumAudioPosition = null;
      var maximumVideoPosition = null;

      if (firstAudioAdaptationFromPeriod != null) {
        var lastPosition = get_last_time_from_adaptation_1.default(firstAudioAdaptationFromPeriod);

        if (lastPosition === undefined) {
          return undefined;
        }

        maximumAudioPosition = lastPosition;
      }

      if (firstVideoAdaptationFromPeriod != null) {
        var _lastPosition = get_last_time_from_adaptation_1.default(firstVideoAdaptationFromPeriod);

        if (_lastPosition === undefined) {
          return undefined;
        }

        maximumVideoPosition = _lastPosition;
      }

      if (firstAudioAdaptationFromPeriod != null && maximumAudioPosition === null || firstVideoAdaptationFromPeriod != null && maximumVideoPosition === null) {
        log_1.default.info("DASH Parser: found Period with no segment. ", "Going to previous one to calculate last position");
        return undefined;
      }

      if (maximumVideoPosition != null) {
        if (maximumAudioPosition != null) {
          return Math.min(maximumAudioPosition, maximumVideoPosition);
        }

        return maximumVideoPosition;
      }

      if (maximumAudioPosition != null) {
        return maximumAudioPosition;
      }
    }
  }
}

exports.default = getMaximumPosition;
},{"../../../log":"../../../log.ts","./get_last_time_from_adaptation":"../../../parsers/manifest/dash/get_last_time_from_adaptation.ts"}],"../../../parsers/manifest/dash/get_first_time_from_adaptation.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Returns "first time of reference" from the adaptation given, considering a
 * dynamic content.
 * Undefined if a time could not be found.
 *
 * We consider the latest first time from every representations in the given
 * adaptation.
 * @param {Object} adaptation
 * @returns {Number|undefined}
 */

function getFirstPositionFromAdaptation(adaptation) {
  var representations = adaptation.representations;
  var max = null;

  for (var i = 0; i < representations.length; i++) {
    var firstPosition = representations[i].index.getFirstPosition();

    if (firstPosition === undefined) {
      // we cannot tell
      return undefined;
    }

    if (firstPosition !== null) {
      max = max == null ? firstPosition : Math.max(max, firstPosition);
    }
  }

  if (max === null) {
    // It means that all positions were null === no segments (yet?)
    return null;
  }

  return max;
}

exports.default = getFirstPositionFromAdaptation;
},{}],"../../../parsers/manifest/dash/get_minimum_position.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../../log"));

var get_first_time_from_adaptation_1 = __importDefault(require("./get_first_time_from_adaptation"));
/**
 * @param {Object} manifest
 * @returns {number | undefined}
 */


function getMinimumPosition(manifest) {
  for (var i = 0; i <= manifest.periods.length - 1; i++) {
    var periodAdaptations = manifest.periods[i].adaptations;
    var firstAudioAdaptationFromPeriod = periodAdaptations.audio == null ? undefined : periodAdaptations.audio[0];
    var firstVideoAdaptationFromPeriod = periodAdaptations.video == null ? undefined : periodAdaptations.video[0];

    if (firstAudioAdaptationFromPeriod != null || firstVideoAdaptationFromPeriod != null) {
      // null == no segment
      var minimumAudioPosition = null;
      var minimumVideoPosition = null;

      if (firstAudioAdaptationFromPeriod != null) {
        var firstPosition = get_first_time_from_adaptation_1.default(firstAudioAdaptationFromPeriod);

        if (firstPosition === undefined) {
          return undefined;
        }

        minimumAudioPosition = firstPosition;
      }

      if (firstVideoAdaptationFromPeriod != null) {
        var _firstPosition = get_first_time_from_adaptation_1.default(firstVideoAdaptationFromPeriod);

        if (_firstPosition === undefined) {
          return undefined;
        }

        minimumVideoPosition = _firstPosition;
      }

      if (firstAudioAdaptationFromPeriod != null && minimumAudioPosition === null || firstVideoAdaptationFromPeriod != null && minimumVideoPosition === null) {
        log_1.default.info("DASH Parser: found Period with no segment. ", "Going to next one to calculate first position");
        return undefined;
      }

      if (minimumVideoPosition != null) {
        if (minimumAudioPosition != null) {
          return Math.max(minimumAudioPosition, minimumVideoPosition);
        }

        return minimumVideoPosition;
      }

      if (minimumAudioPosition != null) {
        return minimumAudioPosition;
      }
    }
  }
}

exports.default = getMinimumPosition;
},{"../../../log":"../../../log.ts","./get_first_time_from_adaptation":"../../../parsers/manifest/dash/get_first_time_from_adaptation.ts"}],"../../../parsers/manifest/dash/get_minimum_and_maximum_positions.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var get_maximum_position_1 = __importDefault(require("./get_maximum_position"));

var get_minimum_position_1 = __importDefault(require("./get_minimum_position"));
/**
 * @param {Object} manifest
 * @returns {Array.<number>}
 */


function getMinimumAndMaximumPosition(manifest) {
  if (manifest.periods.length === 0) {
    throw new Error("DASH Parser: no period available for a dynamic content");
  }

  return [get_minimum_position_1.default(manifest), get_maximum_position_1.default(manifest)];
}

exports.default = getMinimumAndMaximumPosition;
},{"./get_maximum_position":"../../../parsers/manifest/dash/get_maximum_position.ts","./get_minimum_position":"../../../parsers/manifest/dash/get_minimum_position.ts"}],"../../../parsers/manifest/dash/node_parsers/ContentComponent.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Parse a "ContentComponent" Element in a DASH MPD.
 * @param {Element} root
 * @returns {Object}
 */

function parseContentComponent(root) {
  var ret = {};

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "id":
        ret.id = attribute.value;
        break;

      case "lang":
        ret.language = attribute.value;
        break;

      case "contentType":
        ret.contentType = attribute.value;
        break;

      case "par":
        ret.par = attribute.value;
        break;
    }
  }

  return ret;
}

exports.default = parseContentComponent;
},{}],"../../../parsers/manifest/dash/node_parsers/ContentProtection.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var byte_parsing_1 = require("../../../../utils/byte_parsing");
/**
 * Parse the "ContentProtection" node of a MPD.
 * @param {Element} root
 * @returns {Object}
 */


function parseContentProtection(root) {
  var schemeIdUri;
  var value;
  var keyId;

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "schemeIdUri":
        schemeIdUri = attribute.value;
        break;

      case "value":
        value = attribute.value;
        break;

      case "cenc:default_KID":
        keyId = byte_parsing_1.hexToBytes(attribute.value.replace(/-/g, ""));
    }
  }

  return {
    schemeIdUri: schemeIdUri,
    value: value,
    keyId: keyId
  };
}

exports.default = parseContentProtection;
},{"../../../../utils/byte_parsing":"../../../utils/byte_parsing.ts"}],"../../../parsers/manifest/dash/node_parsers/utils.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var iso8601Duration = /^P(([\d.]*)Y)?(([\d.]*)M)?(([\d.]*)D)?T?(([\d.]*)H)?(([\d.]*)M)?(([\d.]*)S)?/;
var rangeRe = /([0-9]+)-([0-9]+)/;
/**
 * Parse MPD boolean attributes.
 * @param {string} str
 * @returns {Boolean}
 */

function parseBoolean(str) {
  return str === "true";
}

exports.parseBoolean = parseBoolean;
/**
 * Parse some MPD attributes.
 * @param {string} str
 * @returns {Boolean|Number}
 */

function parseIntOrBoolean(str) {
  if (str === "true") {
    return true;
  }

  if (str === "false") {
    return false;
  }

  return parseInt(str, 10);
}

exports.parseIntOrBoolean = parseIntOrBoolean;
/**
 * Parse MPD date attributes.
 * @param {string} str
 * @returns {Date}
 */

function parseDateTime(str) {
  return new Date(Date.parse(str)).getTime() / 1000;
}

exports.parseDateTime = parseDateTime;
/**
 * Parse MPD ISO8601 duration attributes into seconds.
 * @param {string} date
 * @returns {Number}
 */

function parseDuration(date) {
  if (!date) {
    return 0;
  }

  var match = iso8601Duration.exec(date);

  if (match == null) {
    throw new Error("".concat(date, " is not a valid ISO8601 duration"));
  }

  return parseFloat(match[2] || "0") * 365 * 24 * 60 * 60 + parseFloat(match[4] || "0") * 30 * 24 * 60 * 60 + // not precise +
  parseFloat(match[6] || "0") * 24 * 60 * 60 + parseFloat(match[8] || "0") * 60 * 60 + parseFloat(match[10] || "0") * 60 + parseFloat(match[12] || "0");
}

exports.parseDuration = parseDuration;
/**
 * Parse MPD byterange attributes into arrays of two elements: the start and
 * the end.
 * @param {string} str
 * @returns {Array.<Number>}
 */

function parseByteRange(str) {
  var match = rangeRe.exec(str);

  if (!match) {
    return null;
  } else {
    return [+match[1], +match[2]];
  }
}

exports.parseByteRange = parseByteRange;
/**
 * @param {Element} root
 * @returns {Object}
 */

function parseScheme(root) {
  var schemeIdUri;
  var value;

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "schemeIdUri":
        schemeIdUri = attribute.value;
        break;

      case "value":
        value = attribute.value;
        break;
    }
  }

  return {
    schemeIdUri: schemeIdUri,
    value: value
  };
}

exports.parseScheme = parseScheme;
},{}],"../../../parsers/manifest/dash/node_parsers/Initialization.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../../../log"));

var utils_1 = require("./utils");
/**
 * @param {Element} root
 * @returns {Object}
 */


function parseInitialization(root) {
  var parsedInitialization = {};

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "range":
        {
          var range = utils_1.parseByteRange(attribute.value);

          if (range == null) {
            log_1.default.warn("DASH: invalid range (\"".concat(attribute.value, "\")"));
          } else {
            parsedInitialization.range = range;
          }
        }
        break;

      case "sourceURL":
        parsedInitialization.media = attribute.value;
        break;
    }
  }

  return parsedInitialization;
}

exports.default = parseInitialization;
},{"../../../../log":"../../../log.ts","./utils":"../../../parsers/manifest/dash/node_parsers/utils.ts"}],"../../../parsers/manifest/dash/node_parsers/SegmentBase.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var object_assign_1 = __importDefault(require("object-assign"));

var log_1 = __importDefault(require("../../../../log"));

var Initialization_1 = __importDefault(require("./Initialization"));

var utils_1 = require("./utils");
/**
 * @param {Element} root
 * @returns {Object}
 */


function parseSegmentBase(root) {
  var attributes = {};
  var segmentBaseChildren = root.childNodes;

  for (var i = 0; i < segmentBaseChildren.length; i++) {
    if (segmentBaseChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentNode = segmentBaseChildren[i];

      if (currentNode.nodeName === "Initialization") {
        attributes.initialization = Initialization_1.default(currentNode);
      }
    }
  }

  for (var _i = 0; _i < root.attributes.length; _i++) {
    var attribute = root.attributes[_i];

    switch (attribute.name) {
      case "timescale":
        {
          var _timescale = parseInt(attribute.value, 10);

          if (isNaN(_timescale)) {
            log_1.default.warn("DASH: invalid timescale (\"".concat(attribute.value, "\")"));
          } else {
            attributes.timescale = _timescale;
          }
        }
        break;

      case "presentationTimeOffset":
        {
          var _presentationTimeOffset = parseFloat(attribute.value);

          if (isNaN(_presentationTimeOffset)) {
            log_1.default.warn("DASH: invalid presentationTimeOffset (\"".concat(attribute.value, "\")"));
          } else {
            attributes.presentationTimeOffset = _presentationTimeOffset;
          }
        }
        break;

      case "indexRange":
        attributes.indexRange = utils_1.parseByteRange(attribute.value) || undefined;
        break;

      case "indexRangeExact":
        attributes.indexRangeExact = utils_1.parseBoolean(attribute.value);
        break;

      case "availabilityTimeOffset":
        {
          var availabilityTimeOffset = parseFloat(attribute.value);

          if (isNaN(availabilityTimeOffset)) {
            log_1.default.warn("DASH: invalid availabilityTimeOffset (\"".concat(attribute.value, "\")"));
          } else {
            attributes.availabilityTimeOffset = availabilityTimeOffset;
          }
        }
        break;

      case "availabilityTimeComplete":
        attributes.availabilityTimeComplete = utils_1.parseBoolean(attribute.value);
        break;

      case "duration":
        {
          var duration = parseInt(attribute.value, 10);

          if (isNaN(duration)) {
            log_1.default.warn("DASH: invalid duration (\"".concat(attribute.value, "\")"));
          } else {
            attributes.duration = duration;
          }
        }
        break;

      case "startNumber":
        {
          var startNumber = parseInt(attribute.value, 10);

          if (isNaN(startNumber)) {
            log_1.default.warn("DASH: invalid startNumber (\"".concat(attribute.value, "\")"));
          } else {
            attributes.startNumber = startNumber;
          }
        }
        break;
    }
  }

  var timescale = attributes.timescale == null ? 1 : attributes.timescale;
  var indexRangeExact = !!attributes.indexRangeExact;
  var availabilityTimeComplete = attributes.availabilityTimeComplete == null ? true : attributes.availabilityTimeComplete;
  return object_assign_1.default(attributes, {
    availabilityTimeComplete: availabilityTimeComplete,
    indexRangeExact: indexRangeExact,
    timeline: [],
    timescale: timescale
  });
}

exports.default = parseSegmentBase;
},{"object-assign":"../../../../node_modules/object-assign/index.js","../../../../log":"../../../log.ts","./Initialization":"../../../parsers/manifest/dash/node_parsers/Initialization.ts","./utils":"../../../parsers/manifest/dash/node_parsers/utils.ts"}],"../../../parsers/manifest/dash/node_parsers/SegmentURL.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../../../log"));

var utils_1 = require("./utils");
/**
 * @param {Element} root
 * @returns {Object}
 */


function parseSegmentURL(root) {
  var parsedSegmentURL = {};

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "media":
        parsedSegmentURL.media = attribute.value;
        break;

      case "indexRange":
        {
          var indexRange = utils_1.parseByteRange(attribute.value) || undefined;

          if (!indexRange) {
            log_1.default.warn("DASH: invalid indexRange (\"".concat(attribute.value, "\")"));
          } else {
            parsedSegmentURL.indexRange = indexRange;
          }
        }
        break;

      case "index":
        parsedSegmentURL.index = attribute.value;
        break;

      case "mediaRange":
        {
          var mediaRange = utils_1.parseByteRange(attribute.value) || undefined;

          if (!mediaRange) {
            log_1.default.warn("DASH: invalid mediaRange (\"".concat(attribute.value, "\")"));
          } else {
            parsedSegmentURL.mediaRange = mediaRange;
          }
        }
        break;
    }
  }

  return parsedSegmentURL;
}

exports.default = parseSegmentURL;
},{"../../../../log":"../../../log.ts","./utils":"../../../parsers/manifest/dash/node_parsers/utils.ts"}],"../../../parsers/manifest/dash/node_parsers/SegmentList.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var object_assign_1 = __importDefault(require("object-assign"));

var SegmentBase_1 = __importDefault(require("./SegmentBase"));

var SegmentURL_1 = __importDefault(require("./SegmentURL"));
/**
 * @param {Element} root
 * @returns {Object}
 */


function parseSegmentList(root) {
  var base = SegmentBase_1.default(root);
  var list = [];
  var segmentListChildren = root.childNodes;

  for (var i = 0; i < segmentListChildren.length; i++) {
    if (segmentListChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentNode = segmentListChildren[i];

      if (currentNode.nodeName === "SegmentURL") {
        var segmentURL = SegmentURL_1.default(currentNode);
        list.push(segmentURL);
      }
    }
  }

  var baseDuration = base.duration;

  if (baseDuration == null) {
    throw new Error("Invalid SegmentList: no duration");
  }

  return object_assign_1.default(base, {
    list: list,
    duration: baseDuration
  });
}

exports.default = parseSegmentList;
},{"object-assign":"../../../../node_modules/object-assign/index.js","./SegmentBase":"../../../parsers/manifest/dash/node_parsers/SegmentBase.ts","./SegmentURL":"../../../parsers/manifest/dash/node_parsers/SegmentURL.ts"}],"../../../parsers/manifest/dash/node_parsers/S.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../../../log"));
/**
 * @param {Element} root
 * @returns {Object}
 */


function parseS(root) {
  var parsedS = {};

  for (var j = 0; j < root.attributes.length; j++) {
    var attribute = root.attributes[j];

    switch (attribute.name) {
      case "t":
        var start = parseInt(attribute.value, 10);

        if (isNaN(start)) {
          log_1.default.warn("DASH: invalid t (\"".concat(attribute.value, "\")"));
        } else {
          parsedS.start = start;
        }

        break;

      case "d":
        var duration = parseInt(attribute.value, 10);

        if (isNaN(duration)) {
          log_1.default.warn("DASH: invalid d (\"".concat(attribute.value, "\")"));
        } else {
          parsedS.duration = duration;
        }

        break;

      case "r":
        var repeatCount = parseInt(attribute.value, 10);

        if (isNaN(repeatCount)) {
          log_1.default.warn("DASH: invalid r (\"".concat(attribute.value, "\")"));
        } else {
          parsedS.repeatCount = repeatCount;
        }

        break;
    }
  }

  return parsedS;
}

exports.default = parseS;
},{"../../../../log":"../../../log.ts"}],"../../../parsers/manifest/dash/node_parsers/SegmentTimeline.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var S_1 = __importDefault(require("./S"));
/**
 * @param {Element} root
 * @returns {Array.<Object>}
 */


function parseSegmentTimeline(root) {
  var parsedS = [];
  var timelineChildren = root.childNodes;

  for (var i = 0; i < timelineChildren.length; i++) {
    if (timelineChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentElement = timelineChildren[i];

      if (currentElement.nodeName === "S") {
        var s = S_1.default(currentElement);
        parsedS.push(s);
      }
    }
  }

  return parsedS;
}

exports.default = parseSegmentTimeline;
},{"./S":"../../../parsers/manifest/dash/node_parsers/S.ts"}],"../../../parsers/manifest/dash/node_parsers/SegmentTemplate.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var object_assign_1 = __importDefault(require("object-assign"));

var SegmentBase_1 = __importDefault(require("./SegmentBase"));

var SegmentTimeline_1 = __importDefault(require("./SegmentTimeline"));

var utils_1 = require("./utils");
/**
 * Parse initialization attribute found in segment Template to
 * correspond to the initialization found in a regular segmentBase.
 * @param {string} attrValue
 * @returns {Object}
 */


function parseInitializationAttribute(attrValue) {
  return {
    media: attrValue
  };
}
/**
 * @param {Element} root
 * @returns {Object}
 */


function parseSegmentTemplate(root) {
  var base = SegmentBase_1.default(root);
  var ret;
  var index;
  var media;
  var bitstreamSwitching;
  var timeline;

  for (var i = 0; i < root.childNodes.length; i++) {
    if (root.childNodes[i].nodeType === Node.ELEMENT_NODE) {
      var currentNode = root.childNodes[i];

      if (currentNode.nodeName === "SegmentTimeline") {
        timeline = SegmentTimeline_1.default(currentNode);
      }
    }
  }

  for (var _i = 0; _i < root.attributes.length; _i++) {
    var attribute = root.attributes[_i];

    switch (attribute.nodeName) {
      case "initialization":
        if (base.initialization == null) {
          base.initialization = parseInitializationAttribute(attribute.value);
        }

        break;

      case "index":
        index = attribute.value;
        break;

      case "media":
        media = attribute.value;
        break;

      case "bitstreamSwitching":
        bitstreamSwitching = utils_1.parseBoolean(attribute.value);
        break;
    }
  }

  if (timeline != null) {
    ret = object_assign_1.default({}, base, {
      indexType: "timeline",
      timeline: timeline
    });
  } else {
    var segmentDuration = base.duration;

    if (segmentDuration == null) {
      throw new Error("Invalid SegmentTemplate: no duration");
    }

    ret = object_assign_1.default({}, base, {
      indexType: "template",
      duration: segmentDuration
    });
  }

  if (index != null) {
    ret.index = index;
  }

  if (media != null) {
    ret.media = media;
  }

  if (bitstreamSwitching != null) {
    ret.bitstreamSwitching = bitstreamSwitching;
  }

  return ret;
}

exports.default = parseSegmentTemplate;
},{"object-assign":"../../../../node_modules/object-assign/index.js","./SegmentBase":"../../../parsers/manifest/dash/node_parsers/SegmentBase.ts","./SegmentTimeline":"../../../parsers/manifest/dash/node_parsers/SegmentTimeline.ts","./utils":"../../../parsers/manifest/dash/node_parsers/utils.ts"}],"../../../parsers/manifest/dash/node_parsers/Representation.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../../../log"));

var SegmentBase_1 = __importDefault(require("./SegmentBase"));

var SegmentList_1 = __importDefault(require("./SegmentList"));

var SegmentTemplate_1 = __importDefault(require("./SegmentTemplate"));

var utils_1 = require("./utils");
/**
 * @param {NodeList} representationChildren
 * @returns {Object}
 */


function parseRepresentationChildren(representationChildren) {
  var children = {
    baseURL: ""
  };

  for (var i = 0; i < representationChildren.length; i++) {
    if (representationChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentElement = representationChildren[i];

      switch (currentElement.nodeName) {
        case "BaseURL":
          children.baseURL = currentElement.textContent || "";
          break;

        case "SegmentBase":
          children.segmentBase = SegmentBase_1.default(currentElement);
          break;

        case "SegmentList":
          children.segmentList = SegmentList_1.default(currentElement);
          break;

        case "SegmentTemplate":
          children.segmentTemplate = SegmentTemplate_1.default(currentElement);
          break;
      }
    }
  }

  return children;
}
/**
 * @param {Element} representationElement
 * @returns {Object}
 */


function parseRepresentationAttributes(representationElement) {
  var attributes = {};

  for (var i = 0; i < representationElement.attributes.length; i++) {
    var attribute = representationElement.attributes[i];

    switch (attribute.name) {
      case "audioSamplingRate":
        attributes.audioSamplingRate = attribute.value;
        break;

      case "bandwidth":
        {
          var bitrate = parseInt(attribute.value, 10);

          if (isNaN(bitrate)) {
            log_1.default.warn("DASH: invalid bandwidth (\"".concat(attribute.value, "\")"));
          } else {
            attributes.bitrate = bitrate;
          }
        }
        break;

      case "codecs":
        attributes.codecs = attribute.value;
        break;

      case "codingDependency":
        attributes.codingDependency = utils_1.parseBoolean(attribute.value);
        break;

      case "frameRate":
        attributes.frameRate = attribute.value;
        break;

      case "height":
        {
          var height = parseInt(attribute.value, 10);

          if (isNaN(height)) {
            log_1.default.warn("DASH: invalid height (\"".concat(attribute.value, "\")"));
          } else {
            attributes.height = height;
          }
        }
        break;

      case "id":
        attributes.id = attribute.value;
        break;

      case "maxPlayoutRate":
        {
          var maxPlayoutRate = parseFloat(attribute.value);

          if (isNaN(maxPlayoutRate)) {
            log_1.default.warn("DASH: invalid maxPlayoutRate (\"".concat(attribute.value, "\")"));
          } else {
            attributes.maxPlayoutRate = maxPlayoutRate;
          }
        }
        break;

      case "maximumSAPPeriod":
        {
          var maximumSAPPeriod = parseFloat(attribute.value);

          if (isNaN(maximumSAPPeriod)) {
            log_1.default.warn("DASH: invalid maximumSAPPeriod (\"".concat(attribute.value, "\")"));
          } else {
            attributes.maximumSAPPeriod = maximumSAPPeriod;
          }
        }
        break;

      case "mimeType":
        attributes.mimeType = attribute.value;
        break;

      case "profiles":
        attributes.profiles = attribute.value;
        break;

      case "qualityRanking":
        {
          var qualityRanking = parseInt(attribute.value, 10);

          if (isNaN(qualityRanking)) {
            log_1.default.warn("DASH: invalid qualityRanking (\"".concat(attribute.value, "\")"));
          } else {
            attributes.qualityRanking = qualityRanking;
          }
        }
        break;

      case "segmentProfiles":
        attributes.segmentProfiles = attribute.value;
        break;

      case "width":
        {
          var width = parseInt(attribute.value, 10);

          if (isNaN(width)) {
            log_1.default.warn("DASH: invalid width (\"".concat(attribute.value, "\")"));
          } else {
            attributes.width = width;
          }
        }
        break;
    }
  }

  return attributes;
}

function createRepresentationIntermediateRepresentation(representationElement) {
  return {
    children: parseRepresentationChildren(representationElement.childNodes),
    attributes: parseRepresentationAttributes(representationElement)
  };
}

exports.createRepresentationIntermediateRepresentation = createRepresentationIntermediateRepresentation;
},{"../../../../log":"../../../log.ts","./SegmentBase":"../../../parsers/manifest/dash/node_parsers/SegmentBase.ts","./SegmentList":"../../../parsers/manifest/dash/node_parsers/SegmentList.ts","./SegmentTemplate":"../../../parsers/manifest/dash/node_parsers/SegmentTemplate.ts","./utils":"../../../parsers/manifest/dash/node_parsers/utils.ts"}],"../../../parsers/manifest/dash/node_parsers/AdaptationSet.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../../../log"));

var ContentComponent_1 = __importDefault(require("./ContentComponent"));

var ContentProtection_1 = __importDefault(require("./ContentProtection"));

var Representation_1 = require("./Representation");

var SegmentBase_1 = __importDefault(require("./SegmentBase"));

var SegmentList_1 = __importDefault(require("./SegmentList"));

var SegmentTemplate_1 = __importDefault(require("./SegmentTemplate"));

var utils_1 = require("./utils");

function parseAdaptationSetChildren(adaptationSetChildren) {
  var children = {
    baseURL: "",
    representations: []
  };
  var contentProtections = [];

  for (var i = 0; i < adaptationSetChildren.length; i++) {
    if (adaptationSetChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentElement = adaptationSetChildren[i];

      switch (currentElement.nodeName) {
        case "Accessibility":
          children.accessibility = utils_1.parseScheme(currentElement);
          break;

        case "BaseURL":
          children.baseURL = currentElement.textContent || "";
          break;

        case "ContentComponent":
          children.contentComponent = ContentComponent_1.default(currentElement);
          break;

        case "Representation":
          var representation = Representation_1.createRepresentationIntermediateRepresentation(currentElement);
          children.representations.push(representation);
          break;

        case "Role":
          if (children.roles == null) {
            children.roles = [utils_1.parseScheme(currentElement)];
          } else {
            children.roles.push(utils_1.parseScheme(currentElement));
          }

          break;

        case "SupplementalProperty":
          if (children.supplementalProperties == null) {
            children.supplementalProperties = [utils_1.parseScheme(currentElement)];
          } else {
            children.supplementalProperties.push(utils_1.parseScheme(currentElement));
          }

          break;

        case "SegmentBase":
          children.segmentBase = SegmentBase_1.default(currentElement);
          break;

        case "SegmentList":
          children.segmentList = SegmentList_1.default(currentElement);
          break;

        case "SegmentTemplate":
          children.segmentTemplate = SegmentTemplate_1.default(currentElement);
          break;

        case "ContentProtection":
          var contentProtection = ContentProtection_1.default(currentElement);

          if (contentProtection) {
            contentProtections.push(contentProtection);
          }

          break;
        // case "Rating":
        //   children.rating = currentElement;
        //   break;
        // case "Viewpoint":
        //   children.viewpoint = currentElement;
        //   break;
      }
    }
  }

  if (contentProtections.length) {
    children.contentProtections = contentProtections;
  }

  return children;
}

function parseAdaptationSetAttributes(root) {
  var parsedAdaptation = {};

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "id":
        parsedAdaptation.id = attribute.value;
        break;

      case "group":
        {
          var group = parseInt(attribute.value, 10);

          if (isNaN(group)) {
            log_1.default.warn("DASH: invalid group (\"".concat(attribute.value, "\")"));
          } else {
            parsedAdaptation.group = group;
          }
        }
        break;

      case "lang":
        parsedAdaptation.language = attribute.value;
        break;

      case "contentType":
        parsedAdaptation.contentType = attribute.value;
        break;

      case "par":
        parsedAdaptation.par = attribute.value;
        break;

      case "minBandwidth":
        {
          var minBitrate = parseInt(attribute.value, 10);

          if (isNaN(minBitrate)) {
            log_1.default.warn("DASH: invalid minBandwidth (\"".concat(attribute.value, "\")"));
          } else {
            parsedAdaptation.minBitrate = minBitrate;
          }
        }
        break;

      case "maxBandwidth":
        {
          var maxBitrate = parseInt(attribute.value, 10);

          if (isNaN(maxBitrate)) {
            log_1.default.warn("DASH: invalid maxBandwidth (\"".concat(attribute.value, "\")"));
          } else {
            parsedAdaptation.maxBitrate = maxBitrate;
          }
        }
        break;

      case "minWidth":
        {
          var minWidth = parseInt(attribute.value, 10);

          if (isNaN(minWidth)) {
            log_1.default.warn("DASH: invalid minWidth (\"".concat(attribute.value, "\")"));
          } else {
            parsedAdaptation.minWidth = minWidth;
          }
        }
        break;

      case "maxWidth":
        {
          var maxWidth = parseInt(attribute.value, 10);

          if (isNaN(maxWidth)) {
            log_1.default.warn("DASH: invalid maxWidth (\"".concat(attribute.value, "\")"));
          } else {
            parsedAdaptation.maxWidth = maxWidth;
          }
        }
        break;

      case "minHeight":
        {
          var minHeight = parseInt(attribute.value, 10);

          if (isNaN(minHeight)) {
            log_1.default.warn("DASH: invalid minHeight (\"".concat(attribute.value, "\")"));
          } else {
            parsedAdaptation.minHeight = minHeight;
          }
        }
        break;

      case "maxHeight":
        {
          var maxHeight = parseInt(attribute.value, 10);

          if (isNaN(maxHeight)) {
            log_1.default.warn("DASH: invalid maxHeight (\"".concat(attribute.value, "\")"));
          } else {
            parsedAdaptation.maxHeight = maxHeight;
          }
        }
        break;

      case "minFrameRate":
        {
          parsedAdaptation.minFrameRate = attribute.value;
        }
        break;

      case "maxFrameRate":
        parsedAdaptation.maxFrameRate = attribute.value;
        break;

      case "segmentAlignment":
        {
          var segmentAlignment = utils_1.parseIntOrBoolean(attribute.value);

          if (typeof segmentAlignment === "number" && isNaN(segmentAlignment)) {
            log_1.default.warn("DASH: invalid segmentAlignment (\"".concat(attribute.value, "\")"));
          } else {
            parsedAdaptation.segmentAlignment = segmentAlignment;
          }
        }
        break;

      case "subsegmentAlignment":
        {
          var subsegmentAlignment = utils_1.parseIntOrBoolean(attribute.value);

          if (typeof subsegmentAlignment === "number" && isNaN(subsegmentAlignment)) {
            log_1.default.warn("DASH: invalid subsegmentAlignment (\"".concat(attribute.value, "\")"));
          } else {
            parsedAdaptation.subsegmentAlignment = subsegmentAlignment;
          }
        }
        break;

      case "bitstreamSwitching":
        parsedAdaptation.bitstreamSwitching = utils_1.parseBoolean(attribute.value);
        break;

      case "audioSamplingRate":
        parsedAdaptation.audioSamplingRate = attribute.value;
        break;

      case "codecs":
        parsedAdaptation.codecs = attribute.value;
        break;

      case "codingDependency":
        parsedAdaptation.codingDependency = utils_1.parseBoolean(attribute.value);
        break;

      case "frameRate":
        parsedAdaptation.frameRate = attribute.value;
        break;

      case "height":
        {
          var height = parseInt(attribute.value, 10);

          if (isNaN(height)) {
            log_1.default.warn("DASH: invalid height (\"".concat(attribute.value, "\")"));
          } else {
            parsedAdaptation.height = height;
          }
        }
        break;

      case "maxPlayoutRate":
        {
          var maxPlayoutRate = parseFloat(attribute.value);

          if (isNaN(maxPlayoutRate)) {
            log_1.default.warn("DASH: invalid maxPlayoutRate (\"".concat(attribute.value, "\")"));
          } else {
            parsedAdaptation.maxPlayoutRate = maxPlayoutRate;
          }
        }
        break;

      case "maximumSAPPeriod":
        {
          var maximumSAPPeriod = parseFloat(attribute.value);

          if (isNaN(maximumSAPPeriod)) {
            log_1.default.warn("DASH: invalid maximumSAPPeriod (\"".concat(attribute.value, "\")"));
          } else {
            parsedAdaptation.maximumSAPPeriod = maximumSAPPeriod;
          }
        }
        break;

      case "mimeType":
        parsedAdaptation.mimeType = attribute.value;
        break;

      case "profiles":
        parsedAdaptation.profiles = attribute.value;
        break;

      case "segmentProfiles":
        parsedAdaptation.segmentProfiles = attribute.value;
        break;

      case "width":
        {
          var width = parseInt(attribute.value, 10);

          if (isNaN(width)) {
            log_1.default.warn("DASH: invalid width (\"".concat(attribute.value, "\")"));
          } else {
            parsedAdaptation.width = width;
          }
        }
        break;
    }
  }

  return parsedAdaptation;
}

function createAdaptationSetIntermediateRepresentation(adaptationSetElement) {
  return {
    children: parseAdaptationSetChildren(adaptationSetElement.childNodes),
    attributes: parseAdaptationSetAttributes(adaptationSetElement)
  };
}

exports.createAdaptationSetIntermediateRepresentation = createAdaptationSetIntermediateRepresentation;
},{"../../../../log":"../../../log.ts","./ContentComponent":"../../../parsers/manifest/dash/node_parsers/ContentComponent.ts","./ContentProtection":"../../../parsers/manifest/dash/node_parsers/ContentProtection.ts","./Representation":"../../../parsers/manifest/dash/node_parsers/Representation.ts","./SegmentBase":"../../../parsers/manifest/dash/node_parsers/SegmentBase.ts","./SegmentList":"../../../parsers/manifest/dash/node_parsers/SegmentList.ts","./SegmentTemplate":"../../../parsers/manifest/dash/node_parsers/SegmentTemplate.ts","./utils":"../../../parsers/manifest/dash/node_parsers/utils.ts"}],"../../../parsers/manifest/dash/node_parsers/Period.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../../../log"));

var AdaptationSet_1 = require("./AdaptationSet");

var utils_1 = require("./utils");
/**
 * @param {NodeList} periodChildren
 * @returns {Object}
 */


function parsePeriodChildren(periodChildren) {
  var baseURL = "";
  var adaptations = [];

  for (var i = 0; i < periodChildren.length; i++) {
    if (periodChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentElement = periodChildren[i];

      switch (currentElement.nodeName) {
        case "BaseURL":
          baseURL = currentElement.textContent || "";
          break;

        case "AdaptationSet":
          var adaptation = AdaptationSet_1.createAdaptationSetIntermediateRepresentation(currentElement);
          adaptations.push(adaptation);
          break;
      }
    }
  }

  return {
    baseURL: baseURL,
    adaptations: adaptations
  };
}
/**
 * @param {Element} periodElement
 * @returns {Object}
 */


function parsePeriodAttributes(periodElement) {
  var res = {};

  for (var i = 0; i < periodElement.attributes.length; i++) {
    var attribute = periodElement.attributes[i];

    switch (attribute.name) {
      case "id":
        res.id = attribute.value;
        break;

      case "start":
        {
          var tempStart = utils_1.parseDuration(attribute.value);

          if (!isNaN(tempStart)) {
            res.start = tempStart;
          } else {
            log_1.default.warn("DASH: Unrecognized start in the mpd:", attribute.value);
          }
        }
        break;

      case "duration":
        {
          var tempDuration = utils_1.parseDuration(attribute.value);

          if (!isNaN(tempDuration)) {
            res.duration = tempDuration;
          } else {
            log_1.default.warn("DASH: Unrecognized duration in the mpd:", attribute.value);
          }
        }
        break;

      case "bitstreamSwitching":
        res.bitstreamSwitching = utils_1.parseBoolean(attribute.value);
        break;

      case "xlink:href":
        res.xlinkHref = attribute.value;
        break;

      case "xlink:actuate":
        res.xlinkActuate = attribute.value;
        break;
    }
  }

  return res;
}

function createPeriodIntermediateRepresentation(periodElement) {
  return {
    children: parsePeriodChildren(periodElement.childNodes),
    attributes: parsePeriodAttributes(periodElement)
  };
}

exports.createPeriodIntermediateRepresentation = createPeriodIntermediateRepresentation;
},{"../../../../log":"../../../log.ts","./AdaptationSet":"../../../parsers/manifest/dash/node_parsers/AdaptationSet.ts","./utils":"../../../parsers/manifest/dash/node_parsers/utils.ts"}],"../../../parsers/manifest/dash/node_parsers/MPD.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var Period_1 = require("./Period");

var utils_1 = require("./utils");
/**
 * Parse children of the MPD's root into a simple object.
 * @param {NodeList} mpdChildren
 * @returns {Object}
 */


function parseMPDChildren(mpdChildren) {
  var baseURL = "";
  var locations = [];
  var periods = [];
  var utcTimings = [];

  for (var i = 0; i < mpdChildren.length; i++) {
    if (mpdChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentNode = mpdChildren[i];

      switch (currentNode.nodeName) {
        case "BaseURL":
          baseURL = currentNode.textContent || "";
          break;

        case "Location":
          locations.push(currentNode.textContent || "");
          break;

        case "Period":
          var period = Period_1.createPeriodIntermediateRepresentation(currentNode);
          periods.push(period);
          break;

        case "UTCTiming":
          var utcTiming = utils_1.parseScheme(currentNode);
          utcTimings.push(utcTiming);
          break;
      }
    }
  }

  return {
    baseURL: baseURL,
    locations: locations,
    periods: periods,
    utcTimings: utcTimings
  };
}
/**
 * @param {Element} root
 * @returns {Object}
 */


function parseMPDAttributes(root) {
  var res = {};

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "id":
        res.id = attribute.value;
        break;

      case "profiles":
        res.profiles = attribute.value;
        break;

      case "type":
        res.type = attribute.value;
        break;

      case "availabilityStartTime":
        res.availabilityStartTime = +utils_1.parseDateTime(attribute.value);
        break;

      case "availabilityEndTime":
        res.availabilityEndTime = +utils_1.parseDateTime(attribute.value);
        break;

      case "publishTime":
        res.publishTime = +utils_1.parseDateTime(attribute.value);
        break;

      case "mediaPresentationDuration":
        res.duration = utils_1.parseDuration(attribute.value);
        break;

      case "minimumUpdatePeriod":
        res.minimumUpdatePeriod = utils_1.parseDuration(attribute.value);
        break;

      case "minBufferTime":
        res.minBufferTime = utils_1.parseDuration(attribute.value);
        break;

      case "timeShiftBufferDepth":
        res.timeShiftBufferDepth = utils_1.parseDuration(attribute.value);
        break;

      case "suggestedPresentationDelay":
        res.suggestedPresentationDelay = utils_1.parseDuration(attribute.value);
        break;

      case "maxSegmentDuration":
        res.maxSegmentDuration = utils_1.parseDuration(attribute.value);
        break;

      case "maxSubsegmentDuration":
        res.maxSubsegmentDuration = utils_1.parseDuration(attribute.value);
        break;
    }
  }

  return res;
}

function createMPDIntermediateRepresentation(root) {
  return {
    children: parseMPDChildren(root.childNodes),
    attributes: parseMPDAttributes(root)
  };
}

exports.createMPDIntermediateRepresentation = createMPDIntermediateRepresentation;
},{"./Period":"../../../parsers/manifest/dash/node_parsers/Period.ts","./utils":"../../../parsers/manifest/dash/node_parsers/utils.ts"}],"../../../parsers/manifest/dash/parse_availability_start_time.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

function parseAvailabilityStartTime(rootAttributes, referenceDateTime) {
  if (rootAttributes.type !== "dynamic") {
    return 0;
  }

  if (rootAttributes.availabilityStartTime == null) {
    return referenceDateTime == null ? 0 : referenceDateTime;
  }

  return rootAttributes.availabilityStartTime;
}

exports.default = parseAvailabilityStartTime;
},{}],"../../../parsers/manifest/dash/parse_duration.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

function parseDuration(rootAttributes, parsedPeriods) {
  if (rootAttributes.duration != null) {
    return rootAttributes.duration;
  }

  if (rootAttributes.type === "dynamic") {
    return undefined;
  }

  if (parsedPeriods.length) {
    var lastPeriod = parsedPeriods[parsedPeriods.length - 1];

    if (lastPeriod.end != null) {
      return lastPeriod.end;
    } else if (lastPeriod.duration != null) {
      return lastPeriod.start + lastPeriod.duration;
    }
  }

  return undefined;
}

exports.default = parseDuration;
},{}],"../../../parsers/manifest/dash/flatten_overlapping_periods.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../../log"));
/**
 * Avoid periods to overlap.
 *
 * According to DASH guidelines, if a period has media duration longer than
 * the distance between the start of this period and the start of the next period,
 * use of start times implies that the client will start the playout of the next
 * period at the time stated, rather than finishing the playout of the last period.
 *
 * Even if that case if defined when period last(s) segment(s) is/are a bit longer,
 * it can be meaningful when two periods are overlapping. We will always shorten
 * the first period, and even erase it if its duration is equal to zero.
 *
 * Example (Periods are numbered under their manifest order) :
 *
 * [ Period 1 ][ Period 2 ]       ------>  [ Period 1 ][ Period 3 ]
 *             [ Period 3 ]
 *
 * [ Period 1 ][ Period 2 ]       ------>  [ Period 1 ][  2  ][ Period 3 ]
 *                  [ Period 3 ]
 *
 * [ Period 1 ][ Period 2 ]       ------>  [  1  ][      Period 3     ]
 *        [      Period 3     ]
 *
 * @param {Array.<Object>} parsedPeriods
 * @return {Array.<Object>}
 */


function flattenOverlappingPeriods(parsedPeriods) {
  if (parsedPeriods.length === 0) {
    return [];
  }

  var flattenedPeriods = [parsedPeriods[0]];

  for (var i = 1; i < parsedPeriods.length; i++) {
    var parsedPeriod = parsedPeriods[i];
    var lastFlattenedPeriod = flattenedPeriods[flattenedPeriods.length - 1];

    while (lastFlattenedPeriod.duration == null || lastFlattenedPeriod.start + lastFlattenedPeriod.duration > parsedPeriod.start) {
      log_1.default.warn("DASH: Updating overlapping Periods.", lastFlattenedPeriod, parsedPeriod);
      lastFlattenedPeriod.duration = parsedPeriod.start - lastFlattenedPeriod.start;
      lastFlattenedPeriod.end = parsedPeriod.start;

      if (lastFlattenedPeriod.duration <= 0) {
        flattenedPeriods.pop();
        lastFlattenedPeriod = flattenedPeriods[flattenedPeriods.length - 1];
      }
    }

    flattenedPeriods.push(parsedPeriod);
  }

  return flattenedPeriods;
}

exports.default = flattenOverlappingPeriods;
},{"../../../log":"../../../log.ts"}],"../../../parsers/manifest/dash/get_periods_time_infos.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Get periods time information from current, next and previous
 * periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} manifestInfos
 * @return {Array.<Object>}
 */

function getPeriodsTimeInformation(periodsIR, manifestInfos) {
  var periodsTimeInformation = [];
  periodsIR.forEach(function (currentPeriod, i) {
    var periodStart;

    if (currentPeriod.attributes.start != null) {
      periodStart = currentPeriod.attributes.start;
    } else {
      if (i === 0) {
        periodStart = !manifestInfos.isDynamic || manifestInfos.availabilityStartTime == null ? 0 : manifestInfos.availabilityStartTime;
      } else {
        // take time information from previous period
        var prevPeriodInfos = periodsTimeInformation[periodsTimeInformation.length - 1];

        if (prevPeriodInfos != null && prevPeriodInfos.periodEnd != null) {
          periodStart = prevPeriodInfos.periodEnd;
        } else {
          throw new Error("Missing start time when parsing periods.");
        }
      }
    }

    var periodDuration;
    var nextPeriod = periodsIR[i + 1];

    if (currentPeriod.attributes.duration != null) {
      periodDuration = currentPeriod.attributes.duration;
    } else if (i === periodsIR.length - 1) {
      periodDuration = manifestInfos.duration;
    } else if (nextPeriod.attributes.start != null) {
      periodDuration = nextPeriod.attributes.start - periodStart;
    }

    var periodEnd = periodDuration != null ? periodStart + periodDuration : undefined;
    periodsTimeInformation.push({
      periodStart: periodStart,
      periodDuration: periodDuration,
      periodEnd: periodEnd
    });
  });
  return periodsTimeInformation;
}

exports.default = getPeriodsTimeInformation;
},{}],"../../../parsers/manifest/dash/manifest_bounds_calculator.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * This class allows to easily calculate the first and last available positions
 * in a content at any time.
 *
 * That task can be an hard for dynamic DASH contents: it depends on a
 * `timeShiftBufferDepth` defined in the MPD and on the maximum possible
 * position.
 *
 * The latter can come from either a clock synchronization mechanism or the
 * indexing schemes (e.g. SegmentTemplate, SegmentTimeline etc.) of the last
 * Periods.
 * As such, it might only be known once a large chunk of the MPD has already
 * been parsed.
 *
 * By centralizing the manifest bounds calculation in this class and by giving
 * an instance of it to each parsed elements which might depend on it, we
 * ensure that we can provide it once it is known to every one of those
 * elements without needing to parse a second time the MPD.
 *
 * @example
 * ```js
 * const manifestBoundsCalculator = new ManifestBoundsCalculator();
 *
 * // let's imagine a property `index` on a Representation which need to obtain
 * // the last position at any time
 * someRepresentation.index = new TemplateRepresentationIndex({
 *   // ...
 *   manifestBoundsCalculator // for now, `getLastPosition` will return `undefined`
 * });
 *
 * // ...
 * // Let's imagine a function which try to guess the last position based on a
 * // given parsed period
 * const lastPosition = getMaximumBound(somePeriod);
 * if (lastPosition != null) {
 *   const positionTime = performance.now() / 1000;
 *   manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);
 *   // `getLastPosition` will now be correctly communicate the last position
 *   // (it returned `undefined` until then).
 * }
 * ```
 * @class ManifestBoundsCalculator
 */

var ManifestBoundsCalculator =
/*#__PURE__*/
function () {
  function ManifestBoundsCalculator(args) {
    _classCallCheck(this, ManifestBoundsCalculator);

    this._isDynamic = args.isDynamic;
    this._timeShiftBufferDepth = !args.isDynamic || args.timeShiftBufferDepth == null ? null : args.timeShiftBufferDepth;
  }
  /**
   * Set the last position and the position time (the value of `performance.now()`
   * at the time that position was true converted into seconds).
   *
   * @example
   * Example if you trust `Date.now()` to give you a reliable offset:
   * ```js
   * const lastPosition = Date.now();
   * const positionTime = performance.now() / 1000;
   * manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);
   * ```
   *
   * @param {number} lastPositionOffset
   */


  _createClass(ManifestBoundsCalculator, [{
    key: "setLastPosition",
    value: function setLastPosition(lastPosition, positionTime) {
      this._lastPosition = lastPosition;
      this._positionTime = positionTime;
    }
    /**
     * Returns `true` if the last position and the position time
     * (for dynamic content only) have been comunicated.
     * `false` otherwise.
     * @returns {boolean}
     */

  }, {
    key: "lastPositionIsKnown",
    value: function lastPositionIsKnown() {
      if (this._isDynamic) {
        return this._positionTime != null && this._lastPosition != null;
      }

      return this._lastPosition != null;
    }
    /**
     * Get minimum bound of content.
     * @return {number|undefined}
     */

  }, {
    key: "getMinimumBound",
    value: function getMinimumBound() {
      if (!this._isDynamic || this._timeShiftBufferDepth === null) {
        return 0;
      }

      var maximumBound = this.getMaximumBound();

      if (maximumBound === undefined) {
        return undefined;
      }

      var minimumBound = maximumBound - this._timeShiftBufferDepth;
      return minimumBound;
    }
    /**
     * Calculate the current maximum bound by using both the calculated
     * last position and the timeshift buffer depth.
     * `undefined` if the last position has never been communicated.
     * @return {number|undefined}
     */

  }, {
    key: "getMaximumBound",
    value: function getMaximumBound() {
      if (this._isDynamic && this._positionTime != null && this._lastPosition != null) {
        return Math.max(this._lastPosition - this._positionTime + performance.now() / 1000, 0);
      }

      return this._lastPosition;
    }
  }]);

  return ManifestBoundsCalculator;
}();

exports.default = ManifestBoundsCalculator;
},{}],"../../../parsers/manifest/dash/infer_adaptation_type.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var array_find_1 = __importDefault(require("../../../utils/array_find"));

var array_includes_1 = __importDefault(require("../../../utils/array_includes"));

var KNOWN_ADAPTATION_TYPES = ["audio", "video", "text", "image"];
var SUPPORTED_TEXT_TYPES = ["subtitle", "caption"];
/**
 * Infers the type of adaptation from codec and mimetypes found in it.
 *
 * This follows the guidelines defined by the DASH-IF IOP:
 *   - one adaptation set contains a single media type
 *   - The order of verifications are:
 *       1. mimeType
 *       2. Role
 *       3. codec
 *
 * Note: This is based on DASH-IF-IOP-v4.0 with some more freedom.
 * @param {Object} adaptation
 * @returns {string} - "audio"|"video"|"text"|"image"|"metadata"|"unknown"
 */

function inferAdaptationType(representations, adaptationMimeType, adaptationCodecs, adaptationRoles) {
  function fromMimeType(mimeType, roles) {
    var topLevel = mimeType.split("/")[0];

    if (array_includes_1.default(KNOWN_ADAPTATION_TYPES, topLevel)) {
      return topLevel;
    }

    if (mimeType === "application/bif") {
      return "image";
    }

    if (mimeType === "application/ttml+xml") {
      return "text";
    } // manage DASH-IF mp4-embedded subtitles and metadata


    if (mimeType === "application/mp4") {
      if (roles != null) {
        if (array_find_1.default(roles, function (role) {
          return role.schemeIdUri === "urn:mpeg:dash:role:2011" && array_includes_1.default(SUPPORTED_TEXT_TYPES, role.value);
        }) != null) {
          return "text";
        }
      }

      return "metadata";
    }
  }

  function fromCodecs(codecs) {
    switch (codecs.substring(0, 3)) {
      case "avc":
      case "hev":
      case "hvc":
      case "vp8":
      case "vp9":
      case "av1":
        return "video";

      case "vtt":
        return "text";

      case "bif":
        return "image";
    }

    switch (codecs.substring(0, 4)) {
      case "mp4a":
        return "audio";

      case "wvtt":
      case "stpp":
        return "text";
    }
  }

  if (adaptationMimeType != null) {
    var typeFromMimeType = fromMimeType(adaptationMimeType, adaptationRoles);

    if (typeFromMimeType != null) {
      return typeFromMimeType;
    }
  }

  if (adaptationCodecs != null) {
    var typeFromCodecs = fromCodecs(adaptationCodecs);

    if (typeFromCodecs != null) {
      return typeFromCodecs;
    }
  }

  var representationMimeTypes = representations.map(function (representation) {
    return representation.attributes.mimeType;
  }).filter(function (mimeType) {
    return mimeType != null;
  });
  var representationCodecs = representations.map(function (representation) {
    return representation.attributes.codecs;
  }).filter(function (codecs) {
    return codecs != null;
  });

  for (var i = 0; i < representationMimeTypes.length; i++) {
    var representationMimeType = representationMimeTypes[i];

    if (representationMimeType != null) {
      var _typeFromMimeType = fromMimeType(representationMimeType, adaptationRoles);

      if (_typeFromMimeType != null) {
        return _typeFromMimeType;
      }
    }
  }

  for (var _i = 0; _i < representationCodecs.length; _i++) {
    var codecs = representationCodecs[_i];

    if (codecs != null) {
      var _typeFromMimeType2 = fromCodecs(codecs);

      if (_typeFromMimeType2 != null) {
        return _typeFromMimeType2;
      }
    }
  }

  return "unknown";
}

exports.default = inferAdaptationType;
},{"../../../utils/array_find":"../../../utils/array_find.ts","../../../utils/array_includes":"../../../utils/array_includes.ts"}],"../../../parsers/manifest/utils/index_helpers.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
}); // byte-range

/**
 * Calculate the number of times a timeline element repeats based on the next
 * element.
 * @param {Object} element
 * @param {Object} nextElement
 * @param {number} maxPosition
 * @returns {Number}
 */

function calculateRepeat(element, nextElement, maxPosition) {
  var repeatCount = element.repeatCount;

  if (repeatCount >= 0) {
    return repeatCount;
  } // A negative value of the @r attribute of the S element indicates
  // that the duration indicated in @d attribute repeats until the
  // start of the next S element, the end of the Period or until the
  // next MPD update.


  var segmentEnd;

  if (nextElement != null) {
    segmentEnd = nextElement.start;
  } else if (maxPosition != null) {
    segmentEnd = maxPosition;
  } else {
    segmentEnd = Number.MAX_VALUE;
  }

  return Math.ceil((segmentEnd - element.start) / element.duration) - 1;
}

exports.calculateRepeat = calculateRepeat;
/**
 * Returns end of the segment given, in index time.
 * @param {Object} segment
 * @param {Object|null} [nextSegment]
 * @param {number} maxPosition
 * @returns {Number}
 */

function getIndexSegmentEnd(segment, nextSegment, maxPosition) {
  var start = segment.start,
      duration = segment.duration;

  if (duration <= 0) {
    return start;
  }

  var repeat = calculateRepeat(segment, nextSegment, maxPosition);
  return start + (repeat + 1) * duration;
}

exports.getIndexSegmentEnd = getIndexSegmentEnd;
/**
 * Convert from `presentationTime`, the time of the segment at the moment it
 * is decoded to `mediaTime`, the original time the segments point at.
 * @param {number} time
 * @param {Object} indexOptions
 * @returns {number}
 */

function toIndexTime(time, indexOptions) {
  return time * indexOptions.timescale + indexOptions.indexTimeOffset;
}

exports.toIndexTime = toIndexTime;
/**
 * Convert from `mediaTime`, the original time the segments point at to
 * `presentationTime`, the time of the segment at the moment it is decoded.
 * @param {number} time
 * @param {Object} indexOptions
 * @returns {number}
 */

function fromIndexTime(time, indexOptions) {
  return (time - indexOptions.indexTimeOffset) / indexOptions.timescale;
}

exports.fromIndexTime = fromIndexTime;
/**
 * @param {Number} start
 * @param {Number} duration
 * @param {Number} timescale
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */

function getTimescaledRange(start, duration, timescale) {
  return [start * timescale, (start + duration) * timescale];
}

exports.getTimescaledRange = getTimescaledRange;
},{}],"../../../parsers/manifest/dash/indexes/get_init_segment.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Construct init segment for the given index.
 * @param {Object} index
 * @returns {Object}
 */

function getInitSegment(index) {
  var initialization = index.initialization;
  return {
    id: "init",
    isInit: true,
    time: 0,
    duration: 0,
    range: initialization ? initialization.range || undefined : undefined,
    indexRange: index.indexRange || undefined,
    mediaURL: initialization ? initialization.mediaURL : null,
    timescale: index.timescale,
    timestampOffset: -(index.indexTimeOffset / index.timescale)
  };
}

exports.default = getInitSegment;
},{}],"../../../parsers/manifest/dash/indexes/tokens.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var resolve_url_1 = __importDefault(require("../../../../utils/resolve_url"));
/**
 * Pad with 0 in the left of the given n argument to reach l length
 * @param {Number|string} n
 * @param {Number} l
 * @returns {string}
 */


function padLeftWithZeros(n, l) {
  var nToString = n.toString();

  if (nToString.length >= l) {
    return nToString;
  }

  var arr = new Array(l + 1).join("0") + nToString;
  return arr.slice(-l);
}

function processFormatedToken(replacer) {
  return function (_match, _format, widthStr) {
    var width = widthStr ? parseInt(widthStr, 10) : 1;
    return padLeftWithZeros("" + replacer, width);
  };
}
/**
 * @param {string} representationURL
 * @param {string|undefined} media
 * @param {string|undefined} id
 * @param {number|undefined} bitrate
 * @returns {string}
 */


function createIndexURL(representationURL, media, id, bitrate) {
  return replaceRepresentationDASHTokens(resolve_url_1.default(representationURL, media), id, bitrate);
}

exports.createIndexURL = createIndexURL;
/**
 * Replace "tokens" written in a given path (e.g. $RepresentationID$) by the corresponding
 * infos, taken from the given segment.
 * @param {string} path
 * @param {string|undefined} id
 * @param {number|undefined} bitrate
 * @returns {string}
 */

function replaceRepresentationDASHTokens(path, id, bitrate) {
  if (path.indexOf("$") === -1) {
    return path;
  } else {
    return path.replace(/\$\$/g, "$").replace(/\$RepresentationID\$/g, String(id)).replace(/\$Bandwidth(|\%0(\d+)d)\$/g, processFormatedToken(bitrate || 0));
  }
}

exports.replaceRepresentationDASHTokens = replaceRepresentationDASHTokens;
/**
 * Replace "tokens" written in a given path (e.g. $Time$) by the corresponding
 * infos, taken from the given segment.
 * @param {string} path
 * @param {number} time
 * @param {number} number
 * @returns {string}
 *
 * @throws Error - Throws if we do not have enough data to construct the URL
 */

function replaceSegmentDASHTokens(path, time, number) {
  if (path.indexOf("$") === -1) {
    return path;
  } else {
    return path.replace(/\$\$/g, "$").replace(/\$Number(|\%0(\d+)d)\$/g, function (_x, _y, widthStr) {
      if (number == null) {
        throw new Error("Segment number not defined in a $Number$ scheme");
      }

      return processFormatedToken(number)(_x, _y, widthStr);
    }).replace(/\$Time(|\%0(\d+)d)\$/g, function (_x, _y, widthStr) {
      if (time == null) {
        throw new Error("Segment time not defined in a $Time$ scheme");
      }

      return processFormatedToken(time)(_x, _y, widthStr);
    });
  }
}

exports.replaceSegmentDASHTokens = replaceSegmentDASHTokens;
},{"../../../../utils/resolve_url":"../../../utils/resolve_url.ts"}],"../../../parsers/manifest/dash/indexes/get_segments_from_timeline.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var index_helpers_1 = require("../../utils/index_helpers");

var tokens_1 = require("./tokens");
/**
 * For the given start time and duration of a timeline element, calculate how
 * much this element should be repeated to contain the time given.
 * 0 being the same element, 1 being the next one etc.
 * @param {Number} segmentStartTime
 * @param {Number} segmentDuration
 * @param {Number} wantedTime
 * @returns {Number}
 */


function getWantedRepeatIndex(segmentStartTime, segmentDuration, wantedTime) {
  var diff = wantedTime - segmentStartTime;
  return diff > 0 ? Math.floor(diff / segmentDuration) : 0;
}
/**
 * Get a list of Segments for the time range wanted.
 * @param {Object} index - index object, constructed by parsing the manifest.
 * @param {number} from - starting timestamp wanted, in seconds
 * @param {number} durationWanted - duration wanted, in seconds
 * @returns {Array.<Object>}
 */


function getSegmentsFromTimeline(index, from, durationWanted, maximumTime) {
  var scaledUp = index_helpers_1.toIndexTime(from, index);
  var scaledTo = index_helpers_1.toIndexTime(from + durationWanted, index);
  var timeline = index.timeline,
      timescale = index.timescale,
      mediaURL = index.mediaURL,
      startNumber = index.startNumber;
  var currentNumber = startNumber != null ? startNumber : undefined;
  var segments = [];
  var timelineLength = timeline.length; // TODO(pierre): use @maxSegmentDuration if possible

  var maxEncounteredDuration = timeline.length && timeline[0].duration || 0;

  for (var i = 0; i < timelineLength; i++) {
    var timelineItem = timeline[i];
    var duration = timelineItem.duration,
        start = timelineItem.start,
        range = timelineItem.range;
    maxEncounteredDuration = Math.max(maxEncounteredDuration, duration);
    var repeat = index_helpers_1.calculateRepeat(timelineItem, timeline[i + 1], maximumTime);
    var segmentNumberInCurrentRange = getWantedRepeatIndex(start, duration, scaledUp);
    var segmentTime = start + segmentNumberInCurrentRange * duration;

    while (segmentTime < scaledTo && segmentNumberInCurrentRange <= repeat) {
      var segmentNumber = currentNumber != null ? currentNumber + segmentNumberInCurrentRange : undefined;
      var segment = {
        id: "" + segmentTime,
        time: segmentTime - index.indexTimeOffset,
        isInit: false,
        range: range,
        duration: duration,
        timescale: timescale,
        mediaURL: tokens_1.replaceSegmentDASHTokens(mediaURL, segmentTime, segmentNumber),
        number: segmentNumber,
        timestampOffset: -(index.indexTimeOffset / timescale)
      };
      segments.push(segment); // update segment number and segment time for the next segment

      segmentNumberInCurrentRange++;
      segmentTime = start + segmentNumberInCurrentRange * duration;
    }

    if (segmentTime >= scaledTo) {
      // we reached ``scaledTo``, we're done
      return segments;
    }

    if (currentNumber != null) {
      currentNumber += repeat + 1;
    }
  }

  return segments;
}

exports.default = getSegmentsFromTimeline;
},{"../../utils/index_helpers":"../../../parsers/manifest/utils/index_helpers.ts","./tokens":"../../../parsers/manifest/dash/indexes/tokens.ts"}],"../../../parsers/manifest/dash/indexes/base.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var index_helpers_1 = require("../../utils/index_helpers");

var get_init_segment_1 = __importDefault(require("./get_init_segment"));

var get_segments_from_timeline_1 = __importDefault(require("./get_segments_from_timeline"));

var tokens_1 = require("./tokens");
/**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} segmentInfos
 * @returns {Boolean} - true if the segment has been added
 */


function _addSegmentInfos(index, segmentInfos) {
  if (segmentInfos.timescale !== index.timescale) {
    var timescale = index.timescale;
    index.timeline.push({
      start: segmentInfos.time / segmentInfos.timescale * timescale,
      duration: segmentInfos.duration / segmentInfos.timescale * timescale,
      repeatCount: segmentInfos.count || 0,
      range: segmentInfos.range
    });
  } else {
    index.timeline.push({
      start: segmentInfos.time,
      duration: segmentInfos.duration,
      repeatCount: segmentInfos.count || 0,
      range: segmentInfos.range
    });
  }

  return true;
}
/**
 * Provide helpers for SegmentBase-based indexes.
 * @type {Object}
 */


var BaseRepresentationIndex =
/*#__PURE__*/
function () {
  /**
   * @param {Object} index
   * @param {Object} context
   */
  function BaseRepresentationIndex(index, context) {
    _classCallCheck(this, BaseRepresentationIndex);

    var periodStart = context.periodStart,
        periodEnd = context.periodEnd,
        representationBaseURL = context.representationBaseURL,
        representationId = context.representationId,
        representationBitrate = context.representationBitrate;
    var timescale = index.timescale;
    var presentationTimeOffset = index.presentationTimeOffset != null ? index.presentationTimeOffset : 0;
    var indexTimeOffset = presentationTimeOffset - periodStart * timescale;
    var mediaURL = tokens_1.createIndexURL(representationBaseURL, index.initialization !== undefined ? index.initialization.media : undefined, representationId, representationBitrate); // TODO If indexRange is either undefined or behind the initialization segment
    // the following logic will not work.
    // However taking the nth first bytes like `dash.js` does (where n = 1500) is
    // not straightforward as we would need to clean-up the segment after that.
    // The following logic corresponds to 100% of tested cases, so good enough for
    // now.

    var range = index.initialization !== undefined ? index.initialization.range : index.indexRange !== undefined ? [0, index.indexRange[0] - 1] : undefined;
    this._index = {
      indexRange: index.indexRange,
      indexTimeOffset: indexTimeOffset,
      initialization: {
        mediaURL: mediaURL,
        range: range
      },
      mediaURL: tokens_1.createIndexURL(representationBaseURL, index.media, representationId, representationBitrate),
      startNumber: index.startNumber,
      timeline: index.timeline,
      timescale: timescale
    };
    this._scaledPeriodEnd = periodEnd == null ? undefined : index_helpers_1.toIndexTime(periodEnd, this._index);
  }
  /**
   * Construct init Segment.
   * @returns {Object}
   */


  _createClass(BaseRepresentationIndex, [{
    key: "getInitSegment",
    value: function getInitSegment() {
      return get_init_segment_1.default(this._index);
    }
    /**
     * @param {Number} _up
     * @param {Number} _to
     * @returns {Array.<Object>}
     */

  }, {
    key: "getSegments",
    value: function getSegments(_up, _to) {
      return get_segments_from_timeline_1.default(this._index, _up, _to, this._scaledPeriodEnd);
    }
    /**
     * Returns false as no Segment-Base based index should need to be refreshed.
     * @returns {Boolean}
     */

  }, {
    key: "shouldRefresh",
    value: function shouldRefresh() {
      return false;
    }
    /**
     * Returns first position in index.
     * @returns {Number|null}
     */

  }, {
    key: "getFirstPosition",
    value: function getFirstPosition() {
      var index = this._index;

      if (index.timeline.length === 0) {
        return null;
      }

      return index_helpers_1.fromIndexTime(index.timeline[0].start, index);
    }
    /**
     * Returns last position in index.
     * @returns {Number|null}
     */

  }, {
    key: "getLastPosition",
    value: function getLastPosition() {
      var timeline = this._index.timeline;

      if (timeline.length === 0) {
        return null;
      }

      var lastTimelineElement = timeline[timeline.length - 1];
      var lastTime = index_helpers_1.getIndexSegmentEnd(lastTimelineElement, null, this._scaledPeriodEnd);
      return index_helpers_1.fromIndexTime(lastTime, this._index);
    }
    /**
     * Segments in a segmentBase scheme should stay available.
     * @returns {Boolean|undefined}
     */

  }, {
    key: "isSegmentStillAvailable",
    value: function isSegmentStillAvailable() {
      return true;
    }
    /**
     * We do not check for discontinuity in SegmentBase-based indexes.
     * @returns {Number}
     */

  }, {
    key: "checkDiscontinuity",
    value: function checkDiscontinuity() {
      return -1;
    }
    /**
     * @param {Array.<Object>} nextSegments
     * @returns {Array.<Object>}
     */

  }, {
    key: "_addSegments",
    value: function _addSegments(nextSegments) {
      for (var i = 0; i < nextSegments.length; i++) {
        _addSegmentInfos(this._index, nextSegments[i]);
      }
    }
    /**
     * SegmentBase should not be updated.
     * @returns {Boolean}
     */

  }, {
    key: "canBeOutOfSyncError",
    value: function canBeOutOfSyncError() {
      return false;
    }
    /**
     * @returns {Boolean}
     */

  }, {
    key: "isFinished",
    value: function isFinished() {
      return true;
    }
    /**
     * @param {Object} newIndex
     */

  }, {
    key: "_update",
    value: function _update(newIndex) {
      this._index = newIndex._index;
    }
  }]);

  return BaseRepresentationIndex;
}();

exports.default = BaseRepresentationIndex;
},{"../../utils/index_helpers":"../../../parsers/manifest/utils/index_helpers.ts","./get_init_segment":"../../../parsers/manifest/dash/indexes/get_init_segment.ts","./get_segments_from_timeline":"../../../parsers/manifest/dash/indexes/get_segments_from_timeline.ts","./tokens":"../../../parsers/manifest/dash/indexes/tokens.ts"}],"../../../parsers/manifest/dash/indexes/list.ts":[function(require,module,exports) {
"use strict";
/*
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../../../log"));

var index_helpers_1 = require("../../utils/index_helpers");

var get_init_segment_1 = __importDefault(require("./get_init_segment"));

var tokens_1 = require("./tokens");
/**
 * Provide helpers for SegmentList-based DASH indexes.
 * @type {Object}
 */


var ListRepresentationIndex =
/*#__PURE__*/
function () {
  /**
   * @param {Object} index
   * @param {Object} context
   */
  function ListRepresentationIndex(index, context) {
    _classCallCheck(this, ListRepresentationIndex);

    var periodStart = context.periodStart,
        representationBaseURL = context.representationBaseURL,
        representationId = context.representationId,
        representationBitrate = context.representationBitrate;
    this._periodStart = periodStart;
    var presentationTimeOffset = index.presentationTimeOffset != null ? index.presentationTimeOffset : 0;
    var indexTimeOffset = presentationTimeOffset - periodStart * index.timescale;
    var list = index.list.map(function (lItem) {
      return {
        mediaURL: tokens_1.createIndexURL(representationBaseURL, lItem.media, representationId, representationBitrate),
        mediaRange: lItem.mediaRange
      };
    });
    this._index = {
      list: list,
      timescale: index.timescale,
      duration: index.duration,
      indexTimeOffset: indexTimeOffset,
      indexRange: index.indexRange,
      initialization: index.initialization && {
        mediaURL: tokens_1.createIndexURL(representationBaseURL, index.initialization.media, representationId, representationBitrate),
        range: index.initialization.range
      }
    };
  }
  /**
   * Construct init Segment.
   * @returns {Object}
   */


  _createClass(ListRepresentationIndex, [{
    key: "getInitSegment",
    value: function getInitSegment() {
      return get_init_segment_1.default(this._index);
    }
    /**
     * @param {Number} fromTime
     * @param {Number} duration
     * @returns {Array.<Object>}
     */

  }, {
    key: "getSegments",
    value: function getSegments(fromTime, dur) {
      var index = this._index;
      var duration = index.duration,
          list = index.list,
          timescale = index.timescale;
      var fromTimeInPeriod = fromTime - this._periodStart;

      var _index_helpers_1$getT = index_helpers_1.getTimescaledRange(fromTimeInPeriod, dur, timescale),
          _index_helpers_1$getT2 = _slicedToArray(_index_helpers_1$getT, 2),
          up = _index_helpers_1$getT2[0],
          to = _index_helpers_1$getT2[1];

      var scaledStart = this._periodStart * timescale;
      var length = Math.min(list.length - 1, Math.floor(to / duration));
      var segments = [];
      var i = Math.floor(up / duration);

      while (i <= length) {
        var range = list[i].mediaRange;
        var mediaURL = list[i].mediaURL;
        var args = {
          id: "" + i,
          time: i * duration + scaledStart,
          isInit: false,
          range: range,
          duration: duration,
          timescale: timescale,
          mediaURL: mediaURL,
          timestampOffset: -(index.indexTimeOffset / timescale)
        };
        segments.push(args);
        i++;
      }

      return segments;
    }
    /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * (If we should re-fetch the manifest)
     * @param {Number} _fromTime
     * @param {Number} toTime
     * @returns {Boolean}
     */

  }, {
    key: "shouldRefresh",
    value: function shouldRefresh(_fromTime, toTime) {
      var _this$_index = this._index,
          timescale = _this$_index.timescale,
          duration = _this$_index.duration,
          list = _this$_index.list;
      var scaledTo = toTime * timescale;
      var i = Math.floor(scaledTo / duration);
      return i < 0 || i >= list.length;
    }
    /**
     * Returns first position in index.
     * @returns {Number}
     */

  }, {
    key: "getFirstPosition",
    value: function getFirstPosition() {
      return this._periodStart;
    }
    /**
     * Returns last position in index.
     * @returns {Number}
     */

  }, {
    key: "getLastPosition",
    value: function getLastPosition() {
      var index = this._index;
      var duration = index.duration,
          list = index.list;
      return list.length * duration / index.timescale + this._periodStart;
    }
    /**
     * Returns true if a Segment returned by this index is still considered
     * available.
     * @param {Object} segment
     * @returns {Boolean|undefined}
     */

  }, {
    key: "isSegmentStillAvailable",
    value: function isSegmentStillAvailable(segment) {
      if (segment.isInit) {
        return true;
      }

      var index = this._index;
      var scaledStart = this._periodStart * index.timescale;
      var scaledSegmentStartInPeriod = segment.timescale !== index.timescale ? segment.time * index.timescale / segment.timescale + scaledStart : segment.time - scaledStart;
      var duration = index.duration;
      var segmentNb = scaledSegmentStartInPeriod / duration;
      return segmentNb > 0 && segmentNb % 1 === 0;
    }
    /**
     * We do not check for discontinuity in SegmentList-based indexes.
     * @returns {Number}
     */

  }, {
    key: "checkDiscontinuity",
    value: function checkDiscontinuity() {
      return -1;
    }
    /**
     * SegmentList should not be updated.
     * @returns {Boolean}
     */

  }, {
    key: "canBeOutOfSyncError",
    value: function canBeOutOfSyncError() {
      return false;
    }
    /**
     * @returns {Boolean}
     */

  }, {
    key: "isFinished",
    value: function isFinished() {
      return true;
    }
    /**
     * @param {Object} newIndex
     */

  }, {
    key: "_update",
    value: function _update(newIndex) {
      this._index = newIndex._index;
    }
    /**
     * We do not have to add new segments to SegmentList-based indexes.
     * @returns {Array}
     */

  }, {
    key: "_addSegments",
    value: function _addSegments() {
      if (__DEV__) {
        log_1.default.warn("Tried to add Segments to a list RepresentationIndex");
      }
    }
  }]);

  return ListRepresentationIndex;
}();

exports.default = ListRepresentationIndex;
},{"../../../../log":"../../../log.ts","../../utils/index_helpers":"../../../parsers/manifest/utils/index_helpers.ts","./get_init_segment":"../../../parsers/manifest/dash/indexes/get_init_segment.ts","./tokens":"../../../parsers/manifest/dash/indexes/tokens.ts"}],"../../../parsers/manifest/dash/indexes/template.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var config_1 = __importDefault(require("../../../../config"));

var log_1 = __importDefault(require("../../../../log"));

var get_init_segment_1 = __importDefault(require("./get_init_segment"));

var tokens_1 = require("./tokens");

var MINIMUM_SEGMENT_SIZE = config_1.default.MINIMUM_SEGMENT_SIZE;
/**
 * IRepresentationIndex implementation for DASH' SegmentTemplate without a
 * SegmentTimeline.
 * @class TemplateRepresentationIndex
 */

var TemplateRepresentationIndex =
/*#__PURE__*/
function () {
  /**
   * @param {Object} index
   * @param {Object} context
   */
  function TemplateRepresentationIndex(index, context) {
    _classCallCheck(this, TemplateRepresentationIndex);

    var timescale = index.timescale;
    var aggressiveMode = context.aggressiveMode,
        manifestBoundsCalculator = context.manifestBoundsCalculator,
        isDynamic = context.isDynamic,
        periodEnd = context.periodEnd,
        periodStart = context.periodStart,
        representationBaseURL = context.representationBaseURL,
        representationId = context.representationId,
        representationBitrate = context.representationBitrate;
    this._manifestBoundsCalculator = manifestBoundsCalculator;
    this._aggressiveMode = aggressiveMode;
    var presentationTimeOffset = index.presentationTimeOffset != null ? index.presentationTimeOffset : 0;
    var scaledStart = periodStart * timescale;
    var indexTimeOffset = presentationTimeOffset - scaledStart;
    this._index = {
      duration: index.duration,
      timescale: timescale,
      indexRange: index.indexRange,
      indexTimeOffset: indexTimeOffset,
      initialization: index.initialization && {
        mediaURL: tokens_1.createIndexURL(representationBaseURL, index.initialization.media, representationId, representationBitrate),
        range: index.initialization.range
      },
      mediaURL: tokens_1.createIndexURL(representationBaseURL, index.media, representationId, representationBitrate),
      presentationTimeOffset: presentationTimeOffset,
      startNumber: index.startNumber
    };
    this._isDynamic = isDynamic;
    this._periodStart = periodStart;
    this._relativePeriodEnd = periodEnd == null ? undefined : periodEnd - periodStart;
  }
  /**
   * Construct init Segment.
   * @returns {Object}
   */


  _createClass(TemplateRepresentationIndex, [{
    key: "getInitSegment",
    value: function getInitSegment() {
      return get_init_segment_1.default(this._index);
    }
    /**
     * @param {Number} fromTime
     * @param {Number} dur
     * @returns {Array.<Object>}
     */

  }, {
    key: "getSegments",
    value: function getSegments(fromTime, dur) {
      var index = this._index;
      var duration = index.duration,
          startNumber = index.startNumber,
          timescale = index.timescale,
          mediaURL = index.mediaURL;
      var scaledStart = this._periodStart * timescale;
      var scaledEnd = this._relativePeriodEnd == null ? undefined : this._relativePeriodEnd * timescale; // Convert the asked position to the right timescales, and consider them
      // relatively to the Period's start.

      var upFromPeriodStart = fromTime * timescale - scaledStart;
      var toFromPeriodStart = (fromTime + dur) * timescale - scaledStart;

      var firstSegmentStart = this._getFirstSegmentStart();

      var lastSegmentStart = this._getLastSegmentStart();

      if (firstSegmentStart == null || lastSegmentStart == null) {
        return [];
      }

      var startPosition = Math.max(firstSegmentStart, upFromPeriodStart);
      var lastWantedStartPosition = Math.min(lastSegmentStart, toFromPeriodStart);

      if (lastWantedStartPosition + duration <= startPosition) {
        return [];
      }

      var segments = []; // number corresponding to the Period's start

      var numberOffset = startNumber == null ? 1 : startNumber; // calcul initial time from Period start, where the first segment would have
      // the `0` number

      var numberIndexedToZero = Math.floor(startPosition / duration);

      for (var timeFromPeriodStart = numberIndexedToZero * duration; timeFromPeriodStart <= lastWantedStartPosition; timeFromPeriodStart += duration) {
        // To obtain the real number, adds the real number from the Period's start
        var realNumber = numberIndexedToZero + numberOffset;
        var realDuration = scaledEnd != null && timeFromPeriodStart + duration > scaledEnd ? scaledEnd - timeFromPeriodStart : duration;
        var realTime = timeFromPeriodStart + scaledStart;
        var manifestTime = timeFromPeriodStart + this._index.presentationTimeOffset;
        var realURL = tokens_1.replaceSegmentDASHTokens(mediaURL, manifestTime, realNumber);
        var args = {
          id: "" + realNumber,
          number: realNumber,
          time: realTime,
          isInit: false,
          duration: realDuration,
          timescale: timescale,
          mediaURL: realURL,
          timestampOffset: -(index.indexTimeOffset / timescale)
        };
        segments.push(args);
        numberIndexedToZero++;
      }

      return segments;
    }
    /**
     * Returns first possible position in the index.
     * @returns {number|null|undefined}
     */

  }, {
    key: "getFirstPosition",
    value: function getFirstPosition() {
      var firstSegmentStart = this._getFirstSegmentStart();

      if (firstSegmentStart == null) {
        return firstSegmentStart; // return undefined or null
      }

      return firstSegmentStart / this._index.timescale + this._periodStart;
    }
    /**
     * Returns last possible position in the index.
     * @returns {number|null}
     */

  }, {
    key: "getLastPosition",
    value: function getLastPosition() {
      var lastSegmentStart = this._getLastSegmentStart();

      if (lastSegmentStart == null) {
        // In that case (null or undefined), getLastPosition should reflect
        // the result of getLastSegmentStart, as the meaning is the same for
        // the two functions. So, we return the result of the latter.
        return lastSegmentStart;
      }

      var lastSegmentEnd = lastSegmentStart + this._index.duration;
      return lastSegmentEnd / this._index.timescale + this._periodStart;
    }
    /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * We never have to refresh a SegmentTemplate-based manifest.
     * @returns {Boolean}
     */

  }, {
    key: "shouldRefresh",
    value: function shouldRefresh() {
      return false;
    }
    /**
     * We cannot check for discontinuity in SegmentTemplate-based indexes.
     * @returns {Number}
     */

  }, {
    key: "checkDiscontinuity",
    value: function checkDiscontinuity() {
      return -1;
    }
  }, {
    key: "isSegmentStillAvailable",
    value: function isSegmentStillAvailable(segment) {
      if (segment.isInit) {
        return true;
      }

      if (segment.timescale !== this._index.timescale) {
        return undefined;
      }

      var timescale = segment.timescale;
      var timeRelativeToPeriodStart = segment.time - this._periodStart * timescale;

      var firstSegmentStart = this._getFirstSegmentStart();

      var lastSegmentStart = this._getLastSegmentStart();

      if (firstSegmentStart === undefined || lastSegmentStart === undefined) {
        return undefined;
      }

      if (firstSegmentStart === null || lastSegmentStart === null) {
        return false;
      }

      if (timeRelativeToPeriodStart < firstSegmentStart) {
        return false;
      }

      if (timeRelativeToPeriodStart > lastSegmentStart || segment.duration !== this._index.duration) {
        return false;
      }

      return timeRelativeToPeriodStart / this._index.duration % 1 === 0;
    }
    /**
     * SegmentTemplate without a SegmentTimeline should not be updated.
     * @returns {Boolean}
     */

  }, {
    key: "canBeOutOfSyncError",
    value: function canBeOutOfSyncError() {
      return false;
    }
    /**
     * @returns {Boolean}
     */

  }, {
    key: "isFinished",
    value: function isFinished() {
      if (!this._isDynamic) {
        return true;
      }

      if (this._relativePeriodEnd == null) {
        return false;
      }

      var timescale = this._index.timescale;

      var lastSegmentStart = this._getLastSegmentStart(); // As last segment start is null if live time is before
      // current period, consider the index not to be finished.


      if (lastSegmentStart == null) {
        return false;
      }

      var lastSegmentEnd = lastSegmentStart + this._index.duration; // (1 / 60 for possible rounding errors)

      var roundingError = 1 / 60 * timescale;
      return lastSegmentEnd + roundingError >= this._relativePeriodEnd * timescale;
    }
    /**
     * We do not have to add new segments to SegmentList-based indexes.
     * @returns {Array}
     */

  }, {
    key: "_addSegments",
    value: function _addSegments() {
      log_1.default.warn("Tried to add Segments to a template RepresentationIndex");
    }
    /**
     * @param {Object} newIndex
     */

  }, {
    key: "_update",
    value: function _update(newIndex) {
      this._index = newIndex._index;
      this._aggressiveMode = newIndex._aggressiveMode;
      this._isDynamic = newIndex._isDynamic;
      this._periodStart = newIndex._periodStart;
      this._relativePeriodEnd = newIndex._relativePeriodEnd;
      this._manifestBoundsCalculator = newIndex._manifestBoundsCalculator;
    }
    /**
     * Returns the timescaled start of the first segment that should be available,
     * relatively to the start of the Period.
     * @returns {number | null | undefined}
     */

  }, {
    key: "_getFirstSegmentStart",
    value: function _getFirstSegmentStart() {
      if (!this._isDynamic) {
        return 0; // it is the start of the Period
      } // 1 - check that this index is already available


      if (!this._relativePeriodEnd) {
        // /!\ The scaled max position augments continuously and might not
        // reflect exactly the real server-side value. As segments are
        // generated discretely.
        var maximumBound = this._manifestBoundsCalculator.getMaximumBound();

        if (maximumBound !== undefined && maximumBound < this._periodStart) {
          // Maximum position is before this period.
          // No segment is yet available here
          return null;
        }
      }

      var _this$_index = this._index,
          duration = _this$_index.duration,
          timescale = _this$_index.timescale;

      var firstPosition = this._manifestBoundsCalculator.getMinimumBound();

      if (firstPosition === undefined) {
        return undefined;
      }

      var segmentTime = firstPosition > this._periodStart ? (firstPosition - this._periodStart) * timescale : 0;
      var numberIndexedToZero = Math.floor(segmentTime / duration);
      return numberIndexedToZero * duration;
    }
    /**
     * Returns the timescaled start of the last segment that should be available,
     * relatively to the start of the Period.
     * Returns null if live time is before current period.
     * @returns {number|null|undefined}
     */

  }, {
    key: "_getLastSegmentStart",
    value: function _getLastSegmentStart() {
      var _this$_index2 = this._index,
          duration = _this$_index2.duration,
          timescale = _this$_index2.timescale;

      if (this._isDynamic) {
        var lastPos = this._manifestBoundsCalculator.getMaximumBound();

        if (lastPos === undefined) {
          return undefined;
        }

        if (this._relativePeriodEnd != null && this._relativePeriodEnd < lastPos - this._periodStart) {
          var scaledRelativePeriodEnd = this._relativePeriodEnd * timescale;
          return scaledRelativePeriodEnd <= 0 ? null : scaledRelativePeriodEnd - duration;
        } // /!\ The scaled last position augments continuously and might not
        // reflect exactly the real server-side value. As segments are
        // generated discretely.


        var scaledLastPosition = (lastPos - this._periodStart) * timescale; // Maximum position is before this period.
        // No segment is yet available here

        if (scaledLastPosition < 0) {
          return null;
        }

        var numberOfSegmentsAvailable = this._aggressiveMode ? Math.ceil(scaledLastPosition / duration) : Math.floor(scaledLastPosition / duration);
        return numberOfSegmentsAvailable <= 0 ? null : (numberOfSegmentsAvailable - 1) * duration;
      } else {
        var maximumTime = (this._relativePeriodEnd || 0) * timescale;
        var numberIndexedToZero = Math.ceil(maximumTime / duration) - 1;
        var regularLastSegmentStart = numberIndexedToZero * duration; // In some SegmentTemplate, we could think that there is one more
        // segment that there actually is due to a very little difference between
        // the period's duration and a multiple of a segment's duration.
        // Check that we're within a good margin

        var minimumDuration = MINIMUM_SEGMENT_SIZE * timescale;

        if (maximumTime - regularLastSegmentStart > minimumDuration || numberIndexedToZero === 0) {
          return regularLastSegmentStart;
        }

        return (numberIndexedToZero - 1) * duration;
      }
    }
  }]);

  return TemplateRepresentationIndex;
}();

exports.default = TemplateRepresentationIndex;
},{"../../../../config":"../../../config.ts","../../../../log":"../../../log.ts","./get_init_segment":"../../../parsers/manifest/dash/indexes/get_init_segment.ts","./tokens":"../../../parsers/manifest/dash/indexes/tokens.ts"}],"../../../parsers/manifest/utils/clear_timeline_from_position.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Remove segments which starts before the given `firstAvailablePosition` from
 * the timeline. `firstAvailablePosition` has to be time scaled.
 * @param {Array.<Object>}
 * @returns {number}
 */

function clearTimelineFromPosition(timeline, firstAvailablePosition) {
  while (timeline.length > 0) {
    var firstElt = timeline[0];

    if (firstElt.start >= firstAvailablePosition) {
      return; // all clear
    }

    if (firstElt.repeatCount <= 0) {
      timeline.shift();
    } else {
      // we have a segment repetition
      var nextElt = timeline[1];

      if (nextElt != null && nextElt.start <= firstAvailablePosition) {
        timeline.shift();
      } else {
        // no next segment or next segment is available
        if (firstElt.duration <= 0) {
          return;
        }

        var nextStart = firstElt.start + firstElt.duration;
        var nextRepeat = 1;

        while (nextStart < firstAvailablePosition && nextRepeat <= firstElt.repeatCount) {
          nextStart += firstElt.duration;
          nextRepeat++;
        }

        if (nextRepeat > firstElt.repeatCount) {
          // every start is before
          timeline.shift();
        } else {
          // some repetitions start after and some before
          var newRepeat = firstElt.repeatCount - nextRepeat;
          firstElt.start = nextStart;
          firstElt.repeatCount = newRepeat;
          return;
        }
      }
    }
  }
}

exports.default = clearTimelineFromPosition;
},{}],"../../../parsers/manifest/utils/is_segment_still_available.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Returns true if a Segment returned by the corresponding index is still
 * considered available.
 * Returns false if it is not available anymore.
 * Returns undefined if we cannot know whether it is still available or not.
 * /!\ We do not check the mediaURL of the segment.
 * @param {Object} segment
 * @param {Array.<Object>} timescale
 * @param {number} timeline
 * @returns {Boolean|undefined}
 */

function isSegmentStillAvailable(segment, timeline, timescale, indexTimeOffset) {
  if (timescale !== segment.timescale) {
    // weird case (update?)
    // In any case, it would be over-engineering to do time scaling here.
    return undefined;
  }

  for (var i = 0; i < timeline.length; i++) {
    var tSegment = timeline[i];
    var tSegmentTime = tSegment.start - indexTimeOffset;

    if (tSegmentTime > segment.time) {
      return false;
    } else if (tSegmentTime === segment.time) {
      // there should be only one here
      if (tSegment.duration !== segment.duration) {
        return false;
      }

      if (tSegment.range == null) {
        return segment.range == null;
      }

      return segment.range != null && tSegment.range[0] === segment.range[0] && tSegment.range[1] === segment.range[1];
    } else {
      // tSegment.start < segment.time
      if (tSegment.repeatCount >= 0 && tSegment.duration != null) {
        var timeDiff = tSegmentTime - tSegment.start;
        var repeat = timeDiff / tSegment.duration - 1;
        return repeat % 1 === 0 && repeat <= tSegment.repeatCount;
      }
    }
  }

  return false;
}

exports.default = isSegmentStillAvailable;
},{}],"../../../parsers/manifest/dash/indexes/timeline.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var errors_1 = require("../../../../errors");

var log_1 = __importDefault(require("../../../../log"));

var clear_timeline_from_position_1 = __importDefault(require("../../utils/clear_timeline_from_position"));

var index_helpers_1 = require("../../utils/index_helpers");

var is_segment_still_available_1 = __importDefault(require("../../utils/is_segment_still_available"));

var get_init_segment_1 = __importDefault(require("./get_init_segment"));

var get_segments_from_timeline_1 = __importDefault(require("./get_segments_from_timeline"));

var tokens_1 = require("./tokens");
/**
 * Translate parsed `S` node into Segment compatible with this index:
 * Find out the start, repeatCount and duration of each of these.
 *
 * @param {Object} item - parsed `S` node
 * @param {Object|null} previousItem - the previously parsed Segment (related
 * to the `S` node coming just before). If `null`, we're talking about the first
 * segment.
 * @param {Object|null} nextItem - the `S` node coming next. If `null`, we're
 * talking about the last segment.
 * @param {number} timelineStart - Absolute start for the timeline. In the same
 * timescale than the given `S` nodes.
 * @returns {Object|null}
 */


function fromParsedSToIndexSegment(item, previousItem, nextItem, timelineStart) {
  var start = item.start;
  var duration = item.duration;
  var repeatCount = item.repeatCount;

  if (start == null) {
    if (previousItem == null) {
      start = timelineStart;
    } else if (previousItem.duration != null) {
      start = previousItem.start + previousItem.duration * (previousItem.repeatCount + 1);
    }
  }

  if ((duration == null || isNaN(duration)) && nextItem && nextItem.start != null && !isNaN(nextItem.start) && start != null && !isNaN(start)) {
    duration = nextItem.start - start;
  }

  if (start != null && !isNaN(start) && duration != null && !isNaN(duration) && (repeatCount == null || !isNaN(repeatCount))) {
    return {
      start: start,
      duration: duration,
      repeatCount: repeatCount || 0
    };
  }

  log_1.default.warn("DASH: A \"S\" Element could not have been parsed.");
  return null;
}
/**
 * Get index of the segment containing the given timescaled timestamp.
 * @param {Object} index
 * @param {Number} start
 * @returns {Number}
 */


function getSegmentIndex(index, start) {
  var timeline = index.timeline;
  var low = 0;
  var high = timeline.length;

  while (low < high) {
    var mid = low + high >>> 1;

    if (timeline[mid].start < start) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }

  return low > 0 ? low - 1 : low;
}

var TimelineRepresentationIndex =
/*#__PURE__*/
function () {
  /**
   * @param {Object} index
   * @param {Object} context
   */
  function TimelineRepresentationIndex(index, context) {
    _classCallCheck(this, TimelineRepresentationIndex);

    var manifestBoundsCalculator = context.manifestBoundsCalculator,
        isDynamic = context.isDynamic,
        representationBaseURL = context.representationBaseURL,
        representationId = context.representationId,
        representationBitrate = context.representationBitrate,
        periodStart = context.periodStart,
        periodEnd = context.periodEnd;
    var timescale = index.timescale;
    var presentationTimeOffset = index.presentationTimeOffset != null ? index.presentationTimeOffset : 0;
    var scaledStart = periodStart * timescale;
    var indexTimeOffset = presentationTimeOffset - scaledStart;
    var initialTimeline = index.timeline;
    var timeline = [];

    for (var i = 0; i < initialTimeline.length; i++) {
      var item = initialTimeline[i];
      var nextItem = timeline[timeline.length - 1] || null;
      var prevItem = initialTimeline[i + 1] || null;
      var timelineElement = fromParsedSToIndexSegment(item, nextItem, prevItem, scaledStart);

      if (timelineElement) {
        timeline.push(timelineElement);
      }
    }

    this._manifestBoundsCalculator = manifestBoundsCalculator;
    this._lastUpdate = context.receivedTime == null ? performance.now() : context.receivedTime;
    this._isDynamic = isDynamic;
    this._index = {
      indexRange: index.indexRange,
      indexTimeOffset: indexTimeOffset,
      initialization: index.initialization && {
        mediaURL: tokens_1.createIndexURL(representationBaseURL, index.initialization.media, representationId, representationBitrate),
        range: index.initialization.range
      },
      mediaURL: tokens_1.createIndexURL(representationBaseURL, index.media, representationId, representationBitrate),
      startNumber: index.startNumber,
      timeline: timeline,
      timescale: timescale
    };
    this._scaledPeriodStart = index_helpers_1.toIndexTime(periodStart, this._index);
    this._scaledPeriodEnd = periodEnd == null ? undefined : index_helpers_1.toIndexTime(periodEnd, this._index);
  }
  /**
   * Construct init Segment.
   * @returns {Object}
   */


  _createClass(TimelineRepresentationIndex, [{
    key: "getInitSegment",
    value: function getInitSegment() {
      return get_init_segment_1.default(this._index);
    }
    /**
     * Asks for segments to download for a given time range.
     * @param {Number} from - Beginning of the time wanted, in seconds
     * @param {Number} duration - duration wanted, in seconds
     * @returns {Array.<Object>}
     */

  }, {
    key: "getSegments",
    value: function getSegments(from, duration) {
      this._refreshTimeline(); // first clear timeline if needed


      return get_segments_from_timeline_1.default(this._index, from, duration, this._scaledPeriodEnd);
    }
    /**
     * Returns true if the index should be refreshed.
     * @param {Number} _up
     * @param {Number} to
     * @returns {Boolean}
     */

  }, {
    key: "shouldRefresh",
    value: function shouldRefresh(_up, to) {
      this._refreshTimeline();

      if (!this._isDynamic) {
        return false;
      }

      if (this._index.timeline.length === 0) {
        return true;
      }

      var lastTimelineElt = this._index.timeline[this._index.timeline.length - 1];
      var lastTime = index_helpers_1.getIndexSegmentEnd(lastTimelineElt, null, this._scaledPeriodEnd);

      if (to * this._index.timescale < lastTime) {
        return false;
      }

      var lastTheoriticalPosition = this._getTheoriticalLastPosition();

      if (lastTheoriticalPosition == null) {
        return true;
      }

      return lastTheoriticalPosition > lastTime;
    }
    /**
     * Returns the starting time, in seconds, of the earliest segment currently
     * available.
     * Returns null if nothing is in the index
     * @returns {Number|null}
     */

  }, {
    key: "getFirstPosition",
    value: function getFirstPosition() {
      this._refreshTimeline();

      var index = this._index;
      return index.timeline.length === 0 ? null : index_helpers_1.fromIndexTime(index.timeline[0].start, index);
    }
    /**
     * Returns the ending time, in seconds, of the last segment currently
     * available.
     * Returns null if nothing is in the index
     * @returns {Number|null}
     */

  }, {
    key: "getLastPosition",
    value: function getLastPosition() {
      this._refreshTimeline();

      var timeline = this._index.timeline;

      if (timeline.length === 0) {
        return null;
      }

      var lastTimelineElement = timeline[timeline.length - 1];
      var lastTime = index_helpers_1.getIndexSegmentEnd(lastTimelineElement, null, this._scaledPeriodEnd);
      return index_helpers_1.fromIndexTime(lastTime, this._index);
    }
    /**
     * Returns true if a Segment returned by this index is still considered
     * available.
     * Returns false if it is not available anymore.
     * Returns undefined if we cannot know whether it is still available or not.
     * @param {Object} segment
     * @returns {Boolean|undefined}
     */

  }, {
    key: "isSegmentStillAvailable",
    value: function isSegmentStillAvailable(segment) {
      if (segment.isInit) {
        return true;
      }

      this._refreshTimeline();

      var _this$_index = this._index,
          timeline = _this$_index.timeline,
          timescale = _this$_index.timescale,
          indexTimeOffset = _this$_index.indexTimeOffset;
      return is_segment_still_available_1.default(segment, timeline, timescale, indexTimeOffset);
    }
    /**
     * Checks if the time given is in a discontinuity. That is:
     *   - We're on the upper bound of the current range (end of the range - time
     *     is inferior to the timescale)
     *   - The next range starts after the end of the current range.
     * @param {Number} _time
     * @returns {Number} - If a discontinuity is present, this is the Starting
     * time for the next (discontinuited) range. If not this is equal to -1.
     */

  }, {
    key: "checkDiscontinuity",
    value: function checkDiscontinuity(_time) {
      this._refreshTimeline();

      var _this$_index2 = this._index,
          timeline = _this$_index2.timeline,
          timescale = _this$_index2.timescale;
      var scaledTime = index_helpers_1.toIndexTime(_time, this._index);

      if (scaledTime <= 0) {
        return -1;
      }

      var segmentIndex = getSegmentIndex(this._index, scaledTime);

      if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) {
        return -1;
      }

      var timelineItem = timeline[segmentIndex];

      if (timelineItem.duration === -1) {
        return -1;
      }

      var nextTimelineItem = timeline[segmentIndex + 1];

      if (nextTimelineItem == null) {
        return -1;
      }

      var rangeUp = timelineItem.start;
      var rangeTo = index_helpers_1.getIndexSegmentEnd(timelineItem, nextTimelineItem, this._scaledPeriodEnd); // Every segments defined in range (from rangeUp to rangeTo) are
      // explicitely contiguous.
      // We want to check that the range end is before the next timeline item
      // start, and that scaled time is in this discontinuity.

      if (rangeTo < nextTimelineItem.start && scaledTime >= rangeUp && rangeTo - scaledTime < timescale) {
        return index_helpers_1.fromIndexTime(nextTimelineItem.start, this._index);
      }

      return -1;
    }
    /**
     * @param {Error} error
     * @returns {Boolean}
     */

  }, {
    key: "canBeOutOfSyncError",
    value: function canBeOutOfSyncError(error) {
      if (!this._isDynamic) {
        return false;
      }

      return error instanceof errors_1.NetworkError && error.isHttpError(404);
    }
    /**
     * @param {Object} newIndex
     */

  }, {
    key: "_update",
    value: function _update(newIndex) {
      this._index = newIndex._index;
      this._isDynamic = newIndex._isDynamic;
      this._scaledPeriodStart = newIndex._scaledPeriodStart;
      this._scaledPeriodEnd = newIndex._scaledPeriodEnd;
      this._lastUpdate = newIndex._lastUpdate;
      this._manifestBoundsCalculator = newIndex._manifestBoundsCalculator;
    }
    /**
     * We do not have to add new segments to SegmentList-based indexes.
     * @param {Array.<Object>} nextSegments
     * @param {Object|undefined} currentSegmentInfos
     * @returns {Array}
     */

  }, {
    key: "_addSegments",
    value: function _addSegments() {
      if (__DEV__) {
        log_1.default.warn("Tried to add Segments to a SegmentTimeline RepresentationIndex");
      }
    }
    /**
     * @returns {Boolean}
     */

  }, {
    key: "isFinished",
    value: function isFinished() {
      if (!this._isDynamic) {
        return true;
      }

      var timeline = this._index.timeline;

      if (this._scaledPeriodEnd == null || timeline.length === 0) {
        return false;
      }

      var lastTimelineElement = timeline[timeline.length - 1];
      var lastTime = index_helpers_1.getIndexSegmentEnd(lastTimelineElement, null, this._scaledPeriodEnd); // We can never be truly sure if a SegmentTimeline-based index is finished
      // or not (1 / 60 for possible rounding errors)

      return lastTime + 1 / 60 >= this._scaledPeriodEnd;
    }
    /**
     * Clean-up timeline to remove segment information which should not be
     * available due to timeshifting.
     */

  }, {
    key: "_refreshTimeline",
    value: function _refreshTimeline() {
      var firstPosition = this._manifestBoundsCalculator.getMinimumBound();

      if (firstPosition == null) {
        return; // we don't know yet
      }

      var scaledFirstPosition = index_helpers_1.toIndexTime(firstPosition, this._index);
      clear_timeline_from_position_1.default(this._index.timeline, scaledFirstPosition);
    }
    /**
     * Returns last position if new segments have the same duration than the
     * current last one.
     * @returns {number}
     */

  }, {
    key: "_getTheoriticalLastPosition",
    value: function _getTheoriticalLastPosition() {
      var index = this._index;

      if (index.timeline.length <= 0) {
        return undefined;
      }

      var lastTimelineElement = index.timeline[index.timeline.length - 1];
      var lastPosition = index_helpers_1.getIndexSegmentEnd(lastTimelineElement, null, this._scaledPeriodEnd);

      if (!this._isDynamic) {
        return lastPosition;
      }

      var lastSegmentDuration = lastTimelineElement.duration;
      var timeDiffInSeconds = (performance.now() - this._lastUpdate) / 1000;
      var timeDiffTS = timeDiffInSeconds * index.timescale;

      if (timeDiffTS < lastSegmentDuration) {
        return lastPosition;
      }

      var numberOfNewSegments = Math.floor(timeDiffTS / lastSegmentDuration);
      return numberOfNewSegments * lastSegmentDuration + lastPosition;
    }
  }]);

  return TimelineRepresentationIndex;
}();

exports.default = TimelineRepresentationIndex;
},{"../../../../errors":"../../../errors/index.ts","../../../../log":"../../../log.ts","../../utils/clear_timeline_from_position":"../../../parsers/manifest/utils/clear_timeline_from_position.ts","../../utils/index_helpers":"../../../parsers/manifest/utils/index_helpers.ts","../../utils/is_segment_still_available":"../../../parsers/manifest/utils/is_segment_still_available.ts","./get_init_segment":"../../../parsers/manifest/dash/indexes/get_init_segment.ts","./get_segments_from_timeline":"../../../parsers/manifest/dash/indexes/get_segments_from_timeline.ts","./tokens":"../../../parsers/manifest/dash/indexes/tokens.ts"}],"../../../parsers/manifest/dash/parse_representations.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../../log"));

var resolve_url_1 = __importDefault(require("../../../utils/resolve_url"));

var base_1 = __importDefault(require("./indexes/base"));

var list_1 = __importDefault(require("./indexes/list"));

var template_1 = __importDefault(require("./indexes/template"));

var timeline_1 = __importDefault(require("./indexes/timeline"));
/**
 * Find and parse RepresentationIndex located in an AdaptationSet node.
 * Returns a generic parsed SegmentTemplate with a single element if not found.
 * @param {Object} adaptation
 * @param {Object} context
 */


function findAdaptationIndex(adaptation, context) {
  var adaptationChildren = adaptation.children;
  var adaptationIndex;

  if (adaptationChildren.segmentBase != null) {
    var segmentBase = adaptationChildren.segmentBase;
    adaptationIndex = new base_1.default(segmentBase, context);
  } else if (adaptationChildren.segmentList != null) {
    var segmentList = adaptationChildren.segmentList;
    adaptationIndex = new list_1.default(segmentList, context);
  } else if (adaptationChildren.segmentTemplate != null) {
    var segmentTemplate = adaptationChildren.segmentTemplate;
    adaptationIndex = segmentTemplate.indexType === "timeline" ? new timeline_1.default(segmentTemplate, context) : new template_1.default(segmentTemplate, context);
  } else {
    adaptationIndex = new template_1.default({
      duration: Number.MAX_VALUE,
      timescale: 1,
      startNumber: 0,
      initialization: {
        media: ""
      },
      media: ""
    }, context);
  }

  return adaptationIndex;
}
/**
 * Process intermediate periods to create final parsed periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} manifestInfos
 * @returns {Array.<Object>}
 */


function parseRepresentations(representationsIR, adaptation, adaptationInfos) {
  return representationsIR.map(function (representation) {
    var baseURL = representation.children.baseURL;
    var representationBaseURL = resolve_url_1.default(adaptationInfos.baseURL, baseURL); // 4-2-1. Find Index

    var context = {
      aggressiveMode: adaptationInfos.aggressiveMode,
      manifestBoundsCalculator: adaptationInfos.manifestBoundsCalculator,
      isDynamic: adaptationInfos.isDynamic,
      periodEnd: adaptationInfos.end,
      periodStart: adaptationInfos.start,
      receivedTime: adaptationInfos.receivedTime,
      representationBaseURL: representationBaseURL,
      representationBitrate: representation.attributes.bitrate,
      representationId: representation.attributes.id,
      timeShiftBufferDepth: adaptationInfos.timeShiftBufferDepth
    };
    var representationIndex;

    if (representation.children.segmentBase != null) {
      var segmentBase = representation.children.segmentBase;
      representationIndex = new base_1.default(segmentBase, context);
    } else if (representation.children.segmentList != null) {
      var segmentList = representation.children.segmentList;
      representationIndex = new list_1.default(segmentList, context);
    } else if (representation.children.segmentTemplate != null) {
      var segmentTemplate = representation.children.segmentTemplate;
      representationIndex = segmentTemplate.indexType === "timeline" ? new timeline_1.default(segmentTemplate, context) : new template_1.default(segmentTemplate, context);
    } else {
      representationIndex = findAdaptationIndex(adaptation, context);
    } // 4-2-2. Find bitrate


    var representationBitrate;

    if (representation.attributes.bitrate == null) {
      log_1.default.warn("DASH: No usable bitrate found in the Representation.");
      representationBitrate = 0;
    } else {
      representationBitrate = representation.attributes.bitrate;
    } // 4-2-3. Set ID


    var representationID = representation.attributes.id != null ? representation.attributes.id : representation.attributes.bitrate + (representation.attributes.height != null ? "-" + representation.attributes.height : "") + (representation.attributes.width != null ? "-" + representation.attributes.width : "") + (representation.attributes.mimeType != null ? "-" + representation.attributes.mimeType : "") + (representation.attributes.codecs != null ? "-" + representation.attributes.codecs : ""); // 4-2-4. Construct Representation Base

    var parsedRepresentation = {
      bitrate: representationBitrate,
      index: representationIndex,
      id: representationID
    }; // 4-2-5. Add optional attributes

    var codecs;

    if (representation.attributes.codecs != null) {
      codecs = representation.attributes.codecs;
    } else if (adaptation.attributes.codecs != null) {
      codecs = adaptation.attributes.codecs;
    }

    if (codecs != null) {
      codecs = codecs === "mp4a.40.02" ? "mp4a.40.2" : codecs;
      parsedRepresentation.codecs = codecs;
    }

    if (representation.attributes.frameRate != null) {
      parsedRepresentation.frameRate = representation.attributes.frameRate;
    } else if (adaptation.attributes.frameRate != null) {
      parsedRepresentation.frameRate = adaptation.attributes.frameRate;
    }

    if (representation.attributes.height != null) {
      parsedRepresentation.height = representation.attributes.height;
    } else if (adaptation.attributes.height != null) {
      parsedRepresentation.height = adaptation.attributes.height;
    }

    if (representation.attributes.mimeType != null) {
      parsedRepresentation.mimeType = representation.attributes.mimeType;
    } else if (adaptation.attributes.mimeType != null) {
      parsedRepresentation.mimeType = adaptation.attributes.mimeType;
    }

    if (representation.attributes.width != null) {
      parsedRepresentation.width = representation.attributes.width;
    } else if (adaptation.attributes.width != null) {
      parsedRepresentation.width = adaptation.attributes.width;
    }

    if (adaptation.children.contentProtections != null) {
      var contentProtections = adaptation.children.contentProtections.reduce(function (acc, cp) {
        if (cp.keyId != null) {
          acc.push({
            keyId: cp.keyId
          });
        }

        return acc;
      }, []);

      if (contentProtections.length > 0) {
        parsedRepresentation.contentProtections = contentProtections;
      }
    }

    return parsedRepresentation;
  });
}

exports.default = parseRepresentations;
},{"../../../log":"../../../log.ts","../../../utils/resolve_url":"../../../utils/resolve_url.ts","./indexes/base":"../../../parsers/manifest/dash/indexes/base.ts","./indexes/list":"../../../parsers/manifest/dash/indexes/list.ts","./indexes/template":"../../../parsers/manifest/dash/indexes/template.ts","./indexes/timeline":"../../../parsers/manifest/dash/indexes/timeline.ts"}],"../../../parsers/manifest/dash/parse_adaptation_sets.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../../log"));

var array_find_1 = __importDefault(require("../../../utils/array_find"));

var array_includes_1 = __importDefault(require("../../../utils/array_includes"));

var resolve_url_1 = __importDefault(require("../../../utils/resolve_url"));

var infer_adaptation_type_1 = __importDefault(require("./infer_adaptation_type"));

var parse_representations_1 = __importDefault(require("./parse_representations"));
/**
 * Detect if the accessibility given defines an adaptation for the visually
 * impaired.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */


function isVisuallyImpaired(accessibility) {
  if (!accessibility) {
    return false;
  }

  return accessibility.schemeIdUri === "urn:tva:metadata:cs:AudioPurposeCS:2007" && accessibility.value === "1";
}
/**
 * Detect if the accessibility given defines an adaptation for the hard of
 * hearing.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */


function isHardOfHearing(accessibility) {
  if (!accessibility) {
    return false;
  }

  return accessibility.schemeIdUri === "urn:tva:metadata:cs:AudioPurposeCS:2007" && accessibility.value === "2";
}
/**
 * Contruct Adaptation ID from the information we have.
 * @param {Object} adaptation
 * @param {Array.<Object>} representations
 * @param {Object} infos
 * @returns {string}
 */


function getAdaptationID(adaptation, representations, infos) {
  if (adaptation.attributes.id) {
    return adaptation.attributes.id;
  }

  var idString = infos.type;

  if (adaptation.attributes.language) {
    idString += "-".concat(adaptation.attributes.language);
  }

  if (infos.isClosedCaption) {
    idString += "-cc";
  }

  if (infos.isAudioDescription) {
    idString += "-ad";
  }

  if (adaptation.attributes.contentType) {
    idString += "-".concat(adaptation.attributes.contentType);
  }

  if (adaptation.attributes.codecs) {
    idString += "-".concat(adaptation.attributes.codecs);
  }

  if (adaptation.attributes.mimeType) {
    idString += "-".concat(adaptation.attributes.mimeType);
  }

  if (adaptation.attributes.frameRate) {
    idString += "-".concat(adaptation.attributes.frameRate);
  }

  if (idString.length === infos.type.length) {
    idString += representations.length ? "-" + representations[0].id : "-empty";
  }

  return "adaptation-" + idString;
}
/**
 * Returns a list of ID this adaptation can be seamlessly switched to
 * @param {Object} adaptation
 * @returns {Array.<string>}
 */


function getAdaptationSetSwitchingIDs(adaptation) {
  if (adaptation.children.supplementalProperties != null) {
    var supplementalProperties = adaptation.children.supplementalProperties;

    for (var j = 0; j < supplementalProperties.length; j++) {
      var supplementalProperty = supplementalProperties[j];

      if (supplementalProperty.schemeIdUri === "urn:mpeg:dash:adaptation-set-switching:2016" && supplementalProperty.value != null) {
        return supplementalProperty.value.split(",").map(function (id) {
          return id.trim();
        }).filter(function (id) {
          return id;
        });
      }
    }
  }

  return [];
}
/**
 * Process intermediate periods to create final parsed periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} manifestInfos
 * @returns {Array.<Object>}
 */


function parseAdaptationSets(adaptationsIR, periodInfos) {
  return adaptationsIR.reduce(function (acc, adaptation) {
    var adaptationChildren = adaptation.children;
    var parsedAdaptations = acc.adaptations;
    var representationsIR = adaptation.children.representations;
    var adaptationInfos = {
      aggressiveMode: periodInfos.aggressiveMode,
      baseURL: resolve_url_1.default(periodInfos.baseURL, adaptationChildren.baseURL),
      manifestBoundsCalculator: periodInfos.manifestBoundsCalculator,
      end: periodInfos.end,
      isDynamic: periodInfos.isDynamic,
      receivedTime: periodInfos.receivedTime,
      start: periodInfos.start,
      timeShiftBufferDepth: periodInfos.timeShiftBufferDepth
    };
    var adaptationMimeType = adaptation.attributes.mimeType;
    var adaptationCodecs = adaptation.attributes.codecs;
    var type = infer_adaptation_type_1.default(representationsIR, adaptationMimeType || null, adaptationCodecs || null, adaptationChildren.roles || null);
    var representations = parse_representations_1.default(representationsIR, adaptation, adaptationInfos);
    var originalID = adaptation.attributes.id;
    var newID;
    var adaptationSetSwitchingIDs = getAdaptationSetSwitchingIDs(adaptation); // TODO remove "main" video track management

    var roles = adaptationChildren.roles;
    var isMainAdaptation = !!roles && !!array_find_1.default(roles, function (role) {
      return role.value === "main";
    }) && !!array_find_1.default(roles, function (role) {
      return role.schemeIdUri === "urn:mpeg:dash:role:2011";
    });
    var videoMainAdaptation = acc.videoMainAdaptation;

    if (type === "video" && videoMainAdaptation !== null && isMainAdaptation) {
      var _videoMainAdaptation$;

      (_videoMainAdaptation$ = videoMainAdaptation.representations).push.apply(_videoMainAdaptation$, _toConsumableArray(representations));

      newID = videoMainAdaptation.id;
    } else {
      var accessibility = adaptationChildren.accessibility;
      var isClosedCaption = type === "text" && accessibility != null && isHardOfHearing(accessibility) ? true : undefined;
      var isAudioDescription = type === "audio" && accessibility != null && isVisuallyImpaired(accessibility) ? true : undefined;
      var adaptationID = newID = getAdaptationID(adaptation, representations, {
        isClosedCaption: isClosedCaption,
        isAudioDescription: isAudioDescription,
        type: type
      });
      var parsedAdaptationSet = {
        id: adaptationID,
        representations: representations,
        type: type
      };

      if (adaptation.attributes.language != null) {
        parsedAdaptationSet.language = adaptation.attributes.language;
      }

      if (isClosedCaption != null) {
        parsedAdaptationSet.closedCaption = isClosedCaption;
      }

      if (isAudioDescription != null) {
        parsedAdaptationSet.audioDescription = isAudioDescription;
      }

      var adaptationsOfTheSameType = parsedAdaptations[type];

      if (!adaptationsOfTheSameType) {
        parsedAdaptations[type] = [parsedAdaptationSet];

        if (isMainAdaptation && type === "video") {
          acc.videoMainAdaptation = parsedAdaptationSet;
        }
      } else {
        var mergedInto = null; // look if we have to merge this into another Adaptation

        var _loop = function _loop(k) {
          var id = adaptationSetSwitchingIDs[k];
          var switchingInfos = acc.adaptationSwitchingInfos[id];

          if (switchingInfos != null && switchingInfos.newID !== newID && array_includes_1.default(switchingInfos.adaptationSetSwitchingIDs, originalID)) {
            var adaptationToMergeInto = array_find_1.default(adaptationsOfTheSameType, function (a) {
              return a.id === id;
            });

            if (adaptationToMergeInto != null && adaptationToMergeInto.audioDescription === parsedAdaptationSet.audioDescription && adaptationToMergeInto.closedCaption === parsedAdaptationSet.closedCaption && adaptationToMergeInto.language === parsedAdaptationSet.language) {
              var _adaptationToMergeInt;

              log_1.default.info("DASH Parser: merging \"switchable\" AdaptationSets", originalID, id);

              (_adaptationToMergeInt = adaptationToMergeInto.representations).push.apply(_adaptationToMergeInt, _toConsumableArray(parsedAdaptationSet.representations));

              mergedInto = adaptationToMergeInto;
            }
          }
        };

        for (var k = 0; k < adaptationSetSwitchingIDs.length; k++) {
          _loop(k);
        }

        if (isMainAdaptation && type === "video") {
          if (mergedInto == null) {
            // put "main" adaptation as the first
            adaptationsOfTheSameType.unshift(parsedAdaptationSet);
            acc.videoMainAdaptation = parsedAdaptationSet;
          } else {
            // put the resulting adaptation first instead
            var indexOf = adaptationsOfTheSameType.indexOf(mergedInto);

            if (indexOf < 0) {
              adaptationsOfTheSameType.unshift(parsedAdaptationSet);
            } else if (indexOf !== 0) {
              adaptationsOfTheSameType.splice(indexOf, 1);
              adaptationsOfTheSameType.unshift(mergedInto);
            }

            acc.videoMainAdaptation = mergedInto;
          }
        } else if (mergedInto === null) {
          adaptationsOfTheSameType.push(parsedAdaptationSet);
        }
      }
    }

    if (originalID != null && acc.adaptationSwitchingInfos[originalID] == null) {
      acc.adaptationSwitchingInfos[originalID] = {
        newID: newID,
        adaptationSetSwitchingIDs: adaptationSetSwitchingIDs
      };
    }

    return {
      adaptations: parsedAdaptations,
      adaptationSwitchingInfos: acc.adaptationSwitchingInfos,
      videoMainAdaptation: acc.videoMainAdaptation
    };
  }, {
    adaptations: {},
    videoMainAdaptation: null,
    adaptationSwitchingInfos: {}
  }).adaptations;
}

exports.default = parseAdaptationSets;
},{"../../../log":"../../../log.ts","../../../utils/array_find":"../../../utils/array_find.ts","../../../utils/array_includes":"../../../utils/array_includes.ts","../../../utils/resolve_url":"../../../utils/resolve_url.ts","./infer_adaptation_type":"../../../parsers/manifest/dash/infer_adaptation_type.ts","./parse_representations":"../../../parsers/manifest/dash/parse_representations.ts"}],"../../../parsers/manifest/dash/parse_periods.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../../log"));

var flat_map_1 = __importDefault(require("../../../utils/flat_map"));

var id_generator_1 = __importDefault(require("../../../utils/id_generator"));

var object_values_1 = __importDefault(require("../../../utils/object_values"));

var resolve_url_1 = __importDefault(require("../../../utils/resolve_url"));

var flatten_overlapping_periods_1 = __importDefault(require("./flatten_overlapping_periods"));

var get_periods_time_infos_1 = __importDefault(require("./get_periods_time_infos"));

var manifest_bounds_calculator_1 = __importDefault(require("./manifest_bounds_calculator"));

var parse_adaptation_sets_1 = __importDefault(require("./parse_adaptation_sets"));

var generatePeriodID = id_generator_1.default();
/**
 * Process intermediate periods to create final parsed periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} manifestInfos
 * @returns {Array.<Object>}
 */

function parsePeriods(periodsIR, manifestInfos) {
  var parsedPeriods = [];
  var periodsTimeInformation = get_periods_time_infos_1.default(periodsIR, manifestInfos);

  if (periodsTimeInformation.length !== periodsIR.length) {
    throw new Error("MPD parsing error: the time information are incoherent.");
  } // We might to communicate the depth of the Buffer while parsing


  var isDynamic = manifestInfos.isDynamic,
      timeShiftBufferDepth = manifestInfos.timeShiftBufferDepth;
  var manifestBoundsCalculator = new manifest_bounds_calculator_1.default({
    isDynamic: isDynamic,
    timeShiftBufferDepth: timeShiftBufferDepth
  });

  if (!isDynamic && manifestInfos.duration != null) {
    manifestBoundsCalculator.setLastPosition(manifestInfos.duration);
  } // We parse it in reverse because we might need to deduce the buffer depth from
  // the last Periods' indexes


  for (var i = periodsIR.length - 1; i >= 0; i--) {
    var periodIR = periodsIR[i];
    var xlinkInfos = manifestInfos.xlinkInfos.get(periodIR);
    var periodBaseURL = resolve_url_1.default(manifestInfos.baseURL, periodIR.children.baseURL);
    var _periodsTimeInformati = periodsTimeInformation[i],
        periodStart = _periodsTimeInformati.periodStart,
        periodDuration = _periodsTimeInformati.periodDuration,
        periodEnd = _periodsTimeInformati.periodEnd;
    var periodID = void 0;

    if (periodIR.attributes.id == null) {
      log_1.default.warn("DASH: No usable id found in the Period. Generating one.");
      periodID = "gen-dash-period-" + generatePeriodID();
    } else {
      periodID = periodIR.attributes.id;
    }

    var receivedTime = xlinkInfos !== undefined ? xlinkInfos.receivedTime : manifestInfos.receivedTime;
    var periodInfos = {
      aggressiveMode: manifestInfos.aggressiveMode,
      baseURL: periodBaseURL,
      manifestBoundsCalculator: manifestBoundsCalculator,
      end: periodEnd,
      isDynamic: isDynamic,
      receivedTime: receivedTime,
      start: periodStart,
      timeShiftBufferDepth: timeShiftBufferDepth
    };
    var adaptations = parse_adaptation_sets_1.default(periodIR.children.adaptations, periodInfos);
    var parsedPeriod = {
      id: periodID,
      start: periodStart,
      end: periodEnd,
      duration: periodDuration,
      adaptations: adaptations
    };
    parsedPeriods.unshift(parsedPeriod);

    if (!manifestBoundsCalculator.lastPositionIsKnown()) {
      var lastPosition = getMaximumLastPosition(adaptations);

      if (!isDynamic) {
        if (typeof lastPosition === "number") {
          manifestBoundsCalculator.setLastPosition(lastPosition);
        }
      } else {
        if (typeof lastPosition === "number") {
          var positionTime = performance.now() / 1000;
          manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);
        } else {
          var guessedLastPositionFromClock = guessLastPositionFromClock(manifestInfos, periodStart);

          if (guessedLastPositionFromClock !== undefined) {
            var _guessedLastPositionF = _slicedToArray(guessedLastPositionFromClock, 2),
                guessedLastPosition = _guessedLastPositionF[0],
                guessedPositionTime = _guessedLastPositionF[1];

            manifestBoundsCalculator.setLastPosition(guessedLastPosition, guessedPositionTime);
          }
        }
      }
    }
  }

  if (manifestInfos.isDynamic && !manifestBoundsCalculator.lastPositionIsKnown()) {
    // Guess a last time the last position
    var _guessedLastPositionFromClock = guessLastPositionFromClock(manifestInfos, 0);

    if (_guessedLastPositionFromClock !== undefined) {
      var _guessedLastPositionF2 = _slicedToArray(_guessedLastPositionFromClock, 2),
          _lastPosition = _guessedLastPositionF2[0],
          _positionTime = _guessedLastPositionF2[1];

      manifestBoundsCalculator.setLastPosition(_lastPosition, _positionTime);
    }
  }

  return flatten_overlapping_periods_1.default(parsedPeriods);
}

exports.default = parsePeriods;
/**
 * Try to guess the "last position", which is the last position
 * available in the manifest in seconds, and the "position time", the time
 * (`performance.now()`) in which the last position was collected.
 *
 * These values allows to retrieve at any time in the future the new last
 * position, by substracting the position time to the last position, and
 * adding to it the new value returned by `performance.now`.
 *
 * The last position and position time are returned by this function if and only if
 * it would indicate a last position superior to the `minimumTime` given.
 *
 * This last part allows for example to detect which Period is likely to be the
 * "current" one in multi-periods contents. By giving the Period's start as a
 * `minimumTime`, you ensure that you will get a value only if the current time
 * is in that period.
 *
 * This is useful as guessing the live time from the clock can be seen as a last
 * resort. By detecting that the current time is before the currently considered
 * Period, we can just parse and look at the previous Period. If we can guess
 * the live time more directly from that previous one, we might be better off
 * than just using the clock.
 *
 * @param {Object} manifestInfos
 * @param {number} minimumTime
 * @returns {Array.<number|undefined>}
 */

function guessLastPositionFromClock(manifestInfos, minimumTime) {
  if (manifestInfos.clockOffset != null) {
    var lastPosition = manifestInfos.clockOffset / 1000 - manifestInfos.availabilityStartTime;
    var positionTime = performance.now() / 1000;
    var timeInSec = positionTime + lastPosition;

    if (timeInSec >= minimumTime) {
      return [timeInSec, positionTime];
    }
  } else {
    var now = Date.now() / 1000;

    if (now >= minimumTime) {
      log_1.default.warn("DASH Parser: no clock synchronization mechanism found." + " Using the system clock instead.");

      var _lastPosition2 = now - manifestInfos.availabilityStartTime;

      var _positionTime2 = performance.now() / 1000;

      return [_lastPosition2, _positionTime2];
    }
  }

  return undefined;
}
/**
 * Try to extract the last position declared for any segments in a Period:
 *   - If at least a single index' last position is defined, take the maximum
 *     among them.
 *   - If segments are available but we cannot define the last position
 *     return undefined.
 *   - If no segment are available in that period, return null
 * @param {Object} adaptationsPerType
 * @returns {number|null|undefined}
 */


function getMaximumLastPosition(adaptationsPerType) {
  var maxEncounteredPosition = null;
  var allIndexAreEmpty = true;
  var adaptationsVal = object_values_1.default(adaptationsPerType).filter(function (ada) {
    return ada != null;
  });
  var allAdaptations = flat_map_1.default(adaptationsVal, function (adaptationsForType) {
    return adaptationsForType;
  });

  for (var adapIndex = 0; adapIndex < allAdaptations.length; adapIndex++) {
    var representations = allAdaptations[adapIndex].representations;

    for (var repIndex = 0; repIndex < representations.length; repIndex++) {
      var representation = representations[repIndex];
      var position = representation.index.getLastPosition();

      if (position !== null) {
        allIndexAreEmpty = false;

        if (typeof position === "number") {
          maxEncounteredPosition = maxEncounteredPosition == null ? position : Math.max(maxEncounteredPosition, position);
        }
      }
    }
  }

  if (maxEncounteredPosition != null) {
    return maxEncounteredPosition;
  } else if (allIndexAreEmpty) {
    return null;
  }

  return undefined;
}
},{"../../../log":"../../../log.ts","../../../utils/flat_map":"../../../utils/flat_map.ts","../../../utils/id_generator":"../../../utils/id_generator.ts","../../../utils/object_values":"../../../utils/object_values.ts","../../../utils/resolve_url":"../../../utils/resolve_url.ts","./flatten_overlapping_periods":"../../../parsers/manifest/dash/flatten_overlapping_periods.ts","./get_periods_time_infos":"../../../parsers/manifest/dash/get_periods_time_infos.ts","./manifest_bounds_calculator":"../../../parsers/manifest/dash/manifest_bounds_calculator.ts","./parse_adaptation_sets":"../../../parsers/manifest/dash/parse_adaptation_sets.ts"}],"../../../parsers/manifest/dash/parse_mpd.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var array_find_1 = __importDefault(require("../../../utils/array_find"));

var id_generator_1 = __importDefault(require("../../../utils/id_generator"));

var resolve_url_1 = __importStar(require("../../../utils/resolve_url"));

var check_manifest_ids_1 = __importDefault(require("../utils/check_manifest_ids"));

var get_clock_offset_1 = __importDefault(require("./get_clock_offset"));

var get_http_utc_timing_url_1 = __importDefault(require("./get_http_utc-timing_url"));

var get_minimum_and_maximum_positions_1 = __importDefault(require("./get_minimum_and_maximum_positions"));

var MPD_1 = require("./node_parsers/MPD");

var Period_1 = require("./node_parsers/Period");

var parse_availability_start_time_1 = __importDefault(require("./parse_availability_start_time"));

var parse_duration_1 = __importDefault(require("./parse_duration"));

var parse_periods_1 = __importDefault(require("./parse_periods"));

var generateManifestID = id_generator_1.default();
/**
 * @param {Element} root - The MPD root.
 * @param {Object} args
 * @returns {Object}
 */

function parseMPD(root, args) {
  // Transform whole MPD into a parsed JS object representation
  var mpdIR = MPD_1.createMPDIntermediateRepresentation(root);
  return loadExternalRessourcesAndParse(mpdIR, args);
}

exports.default = parseMPD;
/**
 * Checks if xlinks needs to be loaded before actually parsing the manifest.
 * @param {Object} mpdIR
 * @param {Object} args
 * @returns {Object}
 */

function loadExternalRessourcesAndParse(mpdIR, args, hasLoadedClock) {
  var rootChildren = mpdIR.children,
      rootAttributes = mpdIR.attributes;
  var xlinkInfos = new WeakMap();

  if (args.externalClockOffset == null) {
    var isDynamic = rootAttributes.type === "dynamic";
    var directTiming = array_find_1.default(rootChildren.utcTimings, function (utcTiming) {
      return utcTiming.schemeIdUri === "urn:mpeg:dash:utc:direct:2014" && utcTiming.value != null;
    });
    var clockOffsetFromDirectUTCTiming = directTiming != null && directTiming.value != null ? get_clock_offset_1.default(directTiming.value) : undefined;
    var clockOffset = clockOffsetFromDirectUTCTiming != null && !isNaN(clockOffsetFromDirectUTCTiming) ? clockOffsetFromDirectUTCTiming : undefined;

    if (clockOffset != null) {
      args.externalClockOffset = clockOffset;
    } else if (isDynamic && hasLoadedClock !== true) {
      var UTCTimingHTTPURL = get_http_utc_timing_url_1.default(mpdIR);

      if (UTCTimingHTTPURL != null && UTCTimingHTTPURL.length > 0) {
        // TODO fetch UTCTiming and XLinks at the same time
        return {
          type: "needs-ressources",
          value: {
            ressources: [UTCTimingHTTPURL],
            continue: function continueParsingMPD(loadedRessources) {
              if (loadedRessources.length !== 1) {
                throw new Error("DASH parser: wrong number of loaded ressources.");
              }

              clockOffset = get_clock_offset_1.default(loadedRessources[0].responseData);
              args.externalClockOffset = clockOffset;
              return loadExternalRessourcesAndParse(mpdIR, args, true);
            }
          }
        };
      }
    }
  }

  var xlinksToLoad = [];

  for (var i = 0; i < rootChildren.periods.length; i++) {
    var _rootChildren$periods = rootChildren.periods[i].attributes,
        xlinkHref = _rootChildren$periods.xlinkHref,
        xlinkActuate = _rootChildren$periods.xlinkActuate;

    if (xlinkHref != null && xlinkActuate === "onLoad") {
      xlinksToLoad.push({
        index: i,
        ressource: xlinkHref
      });
    }
  }

  if (xlinksToLoad.length === 0) {
    return parseCompleteIntermediateRepresentation(mpdIR, args, xlinkInfos);
  }

  return {
    type: "needs-ressources",
    value: {
      ressources: xlinksToLoad.map(function (_ref) {
        var ressource = _ref.ressource;
        return ressource;
      }),
      continue: function continueParsingMPD(loadedRessources) {
        if (loadedRessources.length !== xlinksToLoad.length) {
          throw new Error("DASH parser: wrong number of loaded ressources.");
        } // Note: It is important to go from the last index to the first index in
        // the resulting array, as we will potentially add elements to the array


        for (var _i = loadedRessources.length - 1; _i >= 0; _i--) {
          var _rootChildren$periods2;

          var index = xlinksToLoad[_i].index;
          var _loadedRessources$_i = loadedRessources[_i],
              xlinkData = _loadedRessources$_i.responseData,
              receivedTime = _loadedRessources$_i.receivedTime,
              sendingTime = _loadedRessources$_i.sendingTime,
              url = _loadedRessources$_i.url;
          var wrappedData = "<root>" + xlinkData + "</root>";
          var dataAsXML = new DOMParser().parseFromString(wrappedData, "text/xml");

          if (!dataAsXML || dataAsXML.children.length === 0) {
            throw new Error("DASH parser: Invalid external ressources");
          }

          var periods = dataAsXML.children[0].children;
          var periodsIR = [];

          for (var j = 0; j < periods.length; j++) {
            if (periods[j].nodeType === Node.ELEMENT_NODE) {
              var periodIR = Period_1.createPeriodIntermediateRepresentation(periods[j]);
              xlinkInfos.set(periodIR, {
                receivedTime: receivedTime,
                sendingTime: sendingTime,
                url: url
              });
              periodsIR.push(periodIR);
            }
          } // replace original "xlinked" periods by the real deal


          (_rootChildren$periods2 = rootChildren.periods).splice.apply(_rootChildren$periods2, [index, 1].concat(periodsIR));
        }

        return loadExternalRessourcesAndParse(mpdIR, args);
      }
    }
  };
}
/**
 * Parse the MPD intermediate representation into a regular Manifest.
 * @param {Object} mpdIR
 * @param {Object} args
 * @returns {Object}
 */


function parseCompleteIntermediateRepresentation(mpdIR, args, xlinkInfos) {
  var rootChildren = mpdIR.children,
      rootAttributes = mpdIR.attributes;
  var isDynamic = rootAttributes.type === "dynamic";
  var baseURL = resolve_url_1.default(resolve_url_1.normalizeBaseURL(args.url == null ? "" : args.url), rootChildren.baseURL);
  var availabilityStartTime = parse_availability_start_time_1.default(rootAttributes, args.referenceDateTime);
  var timeShiftBufferDepth = rootAttributes.timeShiftBufferDepth;
  var clockOffset = args.externalClockOffset;
  var manifestInfos = {
    aggressiveMode: args.aggressiveMode,
    availabilityStartTime: availabilityStartTime,
    baseURL: baseURL,
    clockOffset: clockOffset,
    duration: rootAttributes.duration,
    isDynamic: isDynamic,
    receivedTime: args.manifestReceivedTime,
    timeShiftBufferDepth: timeShiftBufferDepth,
    xlinkInfos: xlinkInfos
  };
  var parsedPeriods = parse_periods_1.default(rootChildren.periods, manifestInfos);
  var duration = parse_duration_1.default(rootAttributes, parsedPeriods);
  var parsedMPD = {
    availabilityStartTime: availabilityStartTime,
    baseURL: baseURL,
    clockOffset: args.externalClockOffset,
    duration: duration,
    id: rootAttributes.id != null ? rootAttributes.id : "gen-dash-manifest-" + generateManifestID(),
    isDynamic: isDynamic,
    isLive: isDynamic,
    periods: parsedPeriods,
    suggestedPresentationDelay: rootAttributes.suggestedPresentationDelay,
    transportType: "dash",
    uris: args.url == null ? rootChildren.locations : [args.url].concat(_toConsumableArray(rootChildren.locations))
  }; // -- add optional fields --

  if (rootAttributes.minimumUpdatePeriod != null && rootAttributes.minimumUpdatePeriod > 0) {
    parsedMPD.lifetime = rootAttributes.minimumUpdatePeriod;
  }

  check_manifest_ids_1.default(parsedMPD);

  var _get_minimum_and_maxi = get_minimum_and_maximum_positions_1.default(parsedMPD),
      _get_minimum_and_maxi2 = _slicedToArray(_get_minimum_and_maxi, 2),
      minTime = _get_minimum_and_maxi2[0],
      maxTime = _get_minimum_and_maxi2[1];

  var now = performance.now();

  if (!isDynamic) {
    if (minTime != null) {
      parsedMPD.minimumTime = {
        isContinuous: false,
        value: minTime,
        time: now
      };
    }

    if (duration != null) {
      parsedMPD.maximumTime = {
        isContinuous: false,
        value: duration,
        time: now
      };
    } else if (maxTime != null) {
      parsedMPD.maximumTime = {
        isContinuous: false,
        value: maxTime,
        time: now
      };
    }
  } else {
    if (minTime != null) {
      parsedMPD.minimumTime = {
        isContinuous: timeShiftBufferDepth != null,
        value: minTime,
        time: now
      };
    }

    if (maxTime != null) {
      parsedMPD.maximumTime = {
        isContinuous: true,
        value: maxTime,
        time: now
      };

      if (minTime == null) {
        parsedMPD.minimumTime = {
          isContinuous: true,
          value: maxTime,
          time: now
        };
      }
    }
  }

  return {
    type: "done",
    value: parsedMPD
  };
}
},{"../../../utils/array_find":"../../../utils/array_find.ts","../../../utils/id_generator":"../../../utils/id_generator.ts","../../../utils/resolve_url":"../../../utils/resolve_url.ts","../utils/check_manifest_ids":"../../../parsers/manifest/utils/check_manifest_ids.ts","./get_clock_offset":"../../../parsers/manifest/dash/get_clock_offset.ts","./get_http_utc-timing_url":"../../../parsers/manifest/dash/get_http_utc-timing_url.ts","./get_minimum_and_maximum_positions":"../../../parsers/manifest/dash/get_minimum_and_maximum_positions.ts","./node_parsers/MPD":"../../../parsers/manifest/dash/node_parsers/MPD.ts","./node_parsers/Period":"../../../parsers/manifest/dash/node_parsers/Period.ts","./parse_availability_start_time":"../../../parsers/manifest/dash/parse_availability_start_time.ts","./parse_duration":"../../../parsers/manifest/dash/parse_duration.ts","./parse_periods":"../../../parsers/manifest/dash/parse_periods.ts"}],"../../../parsers/manifest/dash/parse_from_document.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var parse_mpd_1 = __importDefault(require("./parse_mpd"));
/**
 * @param {Document} manifest - Original manifest as returned by the server
 * @param {Object} args
 * @returns {Object} - parsed manifest
 */


function parseFromDocument(document, args) {
  var root = document.documentElement;

  if (!root || root.nodeName !== "MPD") {
    throw new Error("DASH Parser: document root should be MPD");
  }

  return parse_mpd_1.default(root, args);
}

exports.default = parseFromDocument;
},{"./parse_mpd":"../../../parsers/manifest/dash/parse_mpd.ts"}],"../../../parsers/manifest/dash/index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var parse_from_document_1 = __importStar(require("./parse_from_document"));

exports.IMPDParserResponse = parse_from_document_1.IMPDParserResponse;
exports.default = parse_from_document_1.default;
},{"./parse_from_document":"../../../parsers/manifest/dash/parse_from_document.ts"}],"../../../transports/dash/manifest_parser.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var object_assign_1 = __importDefault(require("object-assign"));

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var manifest_1 = __importDefault(require("../../manifest"));

var dash_1 = __importDefault(require("../../parsers/manifest/dash"));

var request_1 = __importDefault(require("../../utils/request"));
/**
 * Request external "xlink" ressource from a MPD.
 * @param {string} xlinkURL
 * @returns {Observable}
 */


function requestStringResource(url) {
  return request_1.default({
    url: url,
    responseType: "text"
  }).pipe(operators_1.filter(function (e) {
    return e.type === "data-loaded";
  }), operators_1.map(function (e) {
    return e.value;
  }));
}
/**
 * @param {Object} options
 * @returns {Function}
 */


function generateManifestParser(options) {
  var _aggressiveMode = options.aggressiveMode,
      lowLatencyMode = options.lowLatencyMode,
      referenceDateTime = options.referenceDateTime;
  var aggressiveMode = lowLatencyMode ? _aggressiveMode !== false : _aggressiveMode === true;
  var serverTimeOffset = options.serverSyncInfos != null ? options.serverSyncInfos.serverTimestamp - options.serverSyncInfos.clientTime : undefined;
  return function manifestParser(args) {
    var response = args.response,
        scheduleRequest = args.scheduleRequest;
    var argClockOffset = args.externalClockOffset;
    var loaderURL = args.url;
    var url = response.url == null ? loaderURL : response.url;
    var data = typeof response.responseData === "string" ? new DOMParser().parseFromString(response.responseData, "text/xml") : // TODO find a way to check if Document?
    response.responseData;
    var externalClockOffset = serverTimeOffset == null ? argClockOffset : serverTimeOffset;
    var parsedManifest = dash_1.default(data, {
      aggressiveMode: aggressiveMode,
      url: url,
      referenceDateTime: referenceDateTime,
      externalClockOffset: externalClockOffset
    });
    return loadExternalResources(parsedManifest);

    function loadExternalResources(parserResponse) {
      if (parserResponse.type === "done") {
        var manifest = new manifest_1.default(parserResponse.value, options);
        return rxjs_1.of({
          manifest: manifest,
          url: url
        });
      }

      var _parserResponse$value = parserResponse.value,
          ressources = _parserResponse$value.ressources,
          continueParsing = _parserResponse$value.continue;
      var externalResources$ = ressources.map(function (resource) {
        return scheduleRequest(function () {
          return requestStringResource(resource);
        });
      });
      return rxjs_1.combineLatest(externalResources$).pipe(operators_1.mergeMap(function (loadedResources) {
        var resources = [];

        for (var i = 0; i < loadedResources.length; i++) {
          var resource = loadedResources[i];

          if (typeof resource.responseData !== "string") {
            throw new Error("External DASH resources should only be strings");
          } // Normally not needed but TypeScript is just dumb here


          resources.push(object_assign_1.default(resource, {
            responseData: resource.responseData
          }));
        }

        return loadExternalResources(continueParsing(resources));
      }));
    }
  };
}

exports.default = generateManifestParser;
},{"object-assign":"../../../../node_modules/object-assign/index.js","rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../manifest":"../../../manifest/index.ts","../../parsers/manifest/dash":"../../../parsers/manifest/dash/index.ts","../../utils/request":"../../../utils/request/index.ts"}],"../../../transports/utils/byte_range.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Returns text-formatted byteRange (`bytes=$start-$end?)`
 * @param {Array.<string|Number>} arr
 * @returns {string}
 */

function byteRange(_ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      start = _ref2[0],
      end = _ref2[1];

  return end === Infinity ? "bytes=" + +start + "-" : "bytes=" + +start + "-" + +end;
}

exports.default = byteRange;
},{}],"../../../transports/utils/find_complete_box.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var byte_parsing_1 = require("../../utils/byte_parsing");
/**
 * Find the offset for the first declaration of the given box in an isobmff.
 * Returns -1 if not found or if incomplete.
 *
 * This function does not throw or log in case of partial segments.
 * @param {Uint8Array} buf - the isobmff
 * @param {Number} wantedName
 * @returns {Number} - Offset where the box begins. -1 if not found.
 */


function findCompleteBox(buf, wantedName) {
  var len = buf.length;
  var i = 0;

  while (i + 8 < len) {
    var size = byte_parsing_1.be4toi(buf, i);

    if (size <= 0) {
      return -1;
    }

    var name = byte_parsing_1.be4toi(buf, i + 4);

    if (name === wantedName) {
      if (i + size <= len) {
        return i;
      }

      return -1;
    }

    i += size;
  }

  return -1;
}

exports.default = findCompleteBox;
},{"../../utils/byte_parsing":"../../../utils/byte_parsing.ts"}],"../../../transports/utils/check_isobmff_integrity.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var errors_1 = require("../../errors");

var find_complete_box_1 = __importDefault(require("./find_complete_box"));
/**
 * @param {Uint8Array} buffer
 * @param {boolean} isInit
 * @returns {Array}
 */


function checkISOBMFFIntegrity(buffer, isInit) {
  if (isInit) {
    var ftypIndex = find_complete_box_1.default(buffer, 0x66747970
    /* ftyp */
    );

    if (ftypIndex < 0) {
      throw new errors_1.OtherError("INTEGRITY_ERROR", "Incomplete `ftyp` box");
    }

    var moovIndex = find_complete_box_1.default(buffer, 0x6d6f6f76
    /* moov */
    );

    if (moovIndex < 0) {
      throw new errors_1.OtherError("INTEGRITY_ERROR", "Incomplete `moov` box");
    }
  } else {
    var moofIndex = find_complete_box_1.default(buffer, 0x6d6f6f66
    /* moof */
    );

    if (moofIndex < 0) {
      throw new errors_1.OtherError("INTEGRITY_ERROR", "Incomplete `moof` box");
    }

    var mdatIndex = find_complete_box_1.default(buffer, 0x6d646174
    /* mdat */
    );

    if (mdatIndex < 0) {
      throw new errors_1.OtherError("INTEGRITY_ERROR", "Incomplete `mdat` box");
    }
  }
}

exports.default = checkISOBMFFIntegrity;
},{"../../errors":"../../../errors/index.ts","./find_complete_box":"../../../transports/utils/find_complete_box.ts"}],"../../../transports/utils/is_webm_embedded_track.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @param {Object} representation
 * @returns {boolean}
 */

function isWEBMEmbeddedTrack(representation) {
  return representation.mimeType === "video/webm" || representation.mimeType === "audio/webm";
}

exports.default = isWEBMEmbeddedTrack;
},{}],"../../../transports/dash/init_segment_loader.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var byte_parsing_1 = require("../../utils/byte_parsing");

var request_1 = __importDefault(require("../../utils/request"));

var byte_range_1 = __importDefault(require("../utils/byte_range"));
/**
 * Perform a request for an initialization segment, agnostic to the container.
 * @param {string} url
 * @param {Object} content
 */


function initSegmentLoader(url, _ref) {
  var segment = _ref.segment;

  if (segment.range == null) {
    return request_1.default({
      url: url,
      responseType: "arraybuffer",
      sendProgressEvents: true
    });
  }

  if (segment.indexRange == null) {
    return request_1.default({
      url: url,
      headers: {
        Range: byte_range_1.default(segment.range)
      },
      responseType: "arraybuffer",
      sendProgressEvents: true
    });
  } // range and indexRange are contiguous (99% of the cases)


  if (segment.range[1] + 1 === segment.indexRange[0]) {
    return request_1.default({
      url: url,
      headers: {
        Range: byte_range_1.default([segment.range[0], segment.indexRange[1]])
      },
      responseType: "arraybuffer",
      sendProgressEvents: true
    });
  }

  var rangeRequest$ = request_1.default({
    url: url,
    headers: {
      Range: byte_range_1.default(segment.range)
    },
    responseType: "arraybuffer",
    sendProgressEvents: false
  });
  var indexRequest$ = request_1.default({
    url: url,
    headers: {
      Range: byte_range_1.default(segment.indexRange)
    },
    responseType: "arraybuffer",
    sendProgressEvents: false
  });
  return rxjs_1.combineLatest([rangeRequest$, indexRequest$]).pipe(operators_1.map(function (_ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
        initData = _ref3[0],
        indexData = _ref3[1];

    var data = byte_parsing_1.concat(new Uint8Array(initData.value.responseData), new Uint8Array(indexData.value.responseData));
    var sendingTime = Math.min(initData.value.sendingTime, indexData.value.sendingTime);
    var receivedTime = Math.max(initData.value.receivedTime, indexData.value.receivedTime);
    return {
      type: "data-loaded",
      value: {
        url: url,
        responseData: data,
        size: initData.value.size + indexData.value.size,
        duration: receivedTime - sendingTime,
        sendingTime: sendingTime,
        receivedTime: receivedTime
      }
    };
  }));
}

exports.default = initSegmentLoader;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../utils/byte_parsing":"../../../utils/byte_parsing.ts","../../utils/request":"../../../utils/request/index.ts","../utils/byte_range":"../../../transports/utils/byte_range.ts"}],"../../../transports/dash/extract_complete_chunks.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var byte_parsing_1 = require("../../utils/byte_parsing");

var find_complete_box_1 = __importDefault(require("../utils/find_complete_box"));
/**
 * Take a chunk of ISOBMFF data and extract complete `moof`+`mdat` subsegments
 * which are ready to be decoded.
 * Returns a tuple of two containing first an array of those subsegments
 * followed by tha last un-decodable part.
 * @param {Uint8Array} buffer
 * @returns {Array}
 */


function extractCompleteChunks(buffer) {
  var _position = 0;
  var chunks = [];

  while (_position < buffer.length) {
    var currentBuffer = buffer.subarray(_position, Infinity);
    var moofIndex = find_complete_box_1.default(currentBuffer, 0x6d6f6f66
    /* moof */
    );

    if (moofIndex < 0) {
      // no moof, not a segment.
      return [chunks, currentBuffer];
    }

    var moofLen = byte_parsing_1.be4toi(buffer, moofIndex + _position);
    var moofEnd = _position + moofIndex + moofLen;

    if (moofEnd > buffer.length) {
      // not a complete moof segment
      return [chunks, currentBuffer];
    }

    var mdatIndex = find_complete_box_1.default(currentBuffer, 0x6d646174
    /* mdat */
    );

    if (mdatIndex < 0) {
      // no mdat, not a segment.
      return [chunks, currentBuffer];
    }

    var mdatLen = byte_parsing_1.be4toi(buffer, mdatIndex + _position);
    var mdatEnd = _position + mdatIndex + mdatLen;

    if (mdatEnd > buffer.length) {
      // not a complete mdat segment
      return [chunks, currentBuffer];
    }

    var maxEnd = Math.max(moofEnd, mdatEnd);
    var chunk = buffer.subarray(_position, maxEnd);
    chunks.push(chunk);
    _position = maxEnd;
  }

  return [chunks, null];
}

exports.default = extractCompleteChunks;
},{"../../utils/byte_parsing":"../../../utils/byte_parsing.ts","../utils/find_complete_box":"../../../transports/utils/find_complete_box.ts"}],"../../../transports/dash/low_latency_segment_loader.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var log_1 = __importDefault(require("../../log"));

var byte_parsing_1 = require("../../utils/byte_parsing");

var fetch_1 = __importDefault(require("../../utils/request/fetch"));

var byte_range_1 = __importDefault(require("../utils/byte_range"));

var extract_complete_chunks_1 = __importDefault(require("./extract_complete_chunks"));

function lowLatencySegmentLoader(url, args) {
  var segment = args.segment;
  var headers = segment.range != null ? {
    Range: byte_range_1.default(segment.range)
  } : undefined;
  return fetch_1.default({
    url: url,
    headers: headers
  }).pipe(operators_1.scan(function (acc, evt) {
    if (evt.type === "data-complete") {
      if (acc.partialChunk != null) {
        log_1.default.warn("DASH Pipelines: remaining chunk does not belong to any segment");
      }

      return {
        event: evt,
        completeChunks: [],
        partialChunk: null
      };
    }

    var data = new Uint8Array(evt.value.chunk);
    var concatenated = acc.partialChunk != null ? byte_parsing_1.concat(acc.partialChunk, data) : data;

    var _extract_complete_chu = extract_complete_chunks_1.default(concatenated),
        _extract_complete_chu2 = _slicedToArray(_extract_complete_chu, 2),
        completeChunks = _extract_complete_chu2[0],
        partialChunk = _extract_complete_chu2[1];

    return {
      event: evt,
      completeChunks: completeChunks,
      partialChunk: partialChunk
    };
  }, {
    event: null,
    completeChunks: [],
    partialChunk: null
  }), operators_1.mergeMap(function (evt) {
    var emitted = [];

    for (var i = 0; i < evt.completeChunks.length; i++) {
      emitted.push({
        type: "data-chunk",
        value: {
          responseData: evt.completeChunks[i]
        }
      });
    }

    var event = evt.event;

    if (event != null && event.type === "data-chunk") {
      var value = event.value;
      emitted.push({
        type: "progress",
        value: {
          duration: value.duration,
          size: value.size,
          url: value.url,
          totalSize: value.totalSize
        }
      });
    } else if (event != null && event.type === "data-complete") {
      var _value = event.value;
      emitted.push({
        type: "data-chunk-complete",
        value: {
          duration: _value.duration,
          receivedTime: _value.receivedTime,
          sendingTime: _value.sendingTime,
          size: _value.size,
          status: _value.status,
          url: _value.url
        }
      });
    }

    return rxjs_1.of.apply(rxjs_1, emitted);
  }));
}

exports.default = lowLatencySegmentLoader;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../log":"../../../log.ts","../../utils/byte_parsing":"../../../utils/byte_parsing.ts","../../utils/request/fetch":"../../../utils/request/fetch.ts","../utils/byte_range":"../../../transports/utils/byte_range.ts","./extract_complete_chunks":"../../../transports/dash/extract_complete_chunks.ts"}],"../../../transports/dash/segment_loader.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var request_1 = __importStar(require("../../utils/request"));

var warn_once_1 = __importDefault(require("../../utils/warn_once"));

var byte_range_1 = __importDefault(require("../utils/byte_range"));

var check_isobmff_integrity_1 = __importDefault(require("../utils/check_isobmff_integrity"));

var is_webm_embedded_track_1 = __importDefault(require("../utils/is_webm_embedded_track"));

var init_segment_loader_1 = __importDefault(require("./init_segment_loader"));

var low_latency_segment_loader_1 = __importDefault(require("./low_latency_segment_loader"));
/**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @returns {Observable}
 */


function regularSegmentLoader(url, args, lowLatencyMode) {
  if (args.segment.isInit) {
    return init_segment_loader_1.default(url, args);
  }

  var isWEBM = is_webm_embedded_track_1.default(args.representation);

  if (lowLatencyMode && !isWEBM) {
    if (request_1.fetchIsSupported()) {
      return low_latency_segment_loader_1.default(url, args);
    } else {
      warn_once_1.default("DASH: Your browser does not have the fetch API. You will have " + "a higher chance of rebuffering when playing close to the live edge");
    }
  }

  var segment = args.segment;
  return request_1.default({
    url: url,
    responseType: "arraybuffer",
    sendProgressEvents: true,
    headers: segment.range != null ? {
      Range: byte_range_1.default(segment.range)
    } : undefined
  });
}
/**
 * Generate a segment loader:
 *   - call a custom SegmentLoader if defined
 *   - call the regular loader if not
 * @param {boolean} lowLatencyMode
 * @param {Function} [customSegmentLoader]
 * @returns {Function}
 */


function generateSegmentLoader(_ref) {
  var lowLatencyMode = _ref.lowLatencyMode,
      customSegmentLoader = _ref.segmentLoader,
      checkMediaSegmentIntegrity = _ref.checkMediaSegmentIntegrity;

  if (checkMediaSegmentIntegrity !== true) {
    return segmentLoader;
  }

  return function (content) {
    return segmentLoader(content).pipe(operators_1.tap(function (res) {
      if ((res.type === "data-loaded" || res.type === "data-chunk") && res.value.responseData !== null) {
        check_isobmff_integrity_1.default(new Uint8Array(res.value.responseData), content.segment.isInit);
      }
    }));
  };
  /**
   * @param {Object} content
   * @returns {Observable}
   */

  function segmentLoader(content) {
    var mediaURL = content.segment.mediaURL;

    if (mediaURL == null) {
      return rxjs_1.of({
        type: "data-created",
        value: {
          responseData: null
        }
      });
    }

    if (lowLatencyMode || customSegmentLoader == null) {
      return regularSegmentLoader(mediaURL, content, lowLatencyMode);
    }

    var args = {
      adaptation: content.adaptation,
      manifest: content.manifest,
      period: content.period,
      representation: content.representation,
      segment: content.segment,
      transport: "dash",
      url: mediaURL
    };
    return new rxjs_1.Observable(function (obs) {
      var hasFinished = false;
      var hasFallbacked = false;
      /**
       * Callback triggered when the custom segment loader has a response.
       * @param {Object} args
       */

      var resolve = function resolve(_args) {
        if (!hasFallbacked) {
          hasFinished = true;
          obs.next({
            type: "data-loaded",
            value: {
              responseData: _args.data,
              size: _args.size,
              duration: _args.duration
            }
          });
          obs.complete();
        }
      };
      /**
       * Callback triggered when the custom segment loader fails
       * @param {*} err - The corresponding error encountered
       */


      var reject = function reject() {
        var err = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (!hasFallbacked) {
          hasFinished = true;
          obs.error(err);
        }
      };
      /**
       * Callback triggered when the custom segment loader wants to fallback to
       * the "regular" implementation
       */


      var fallback = function fallback() {
        hasFallbacked = true;
        var regular$ = regularSegmentLoader(mediaURL, content, lowLatencyMode); // HACK What is TypeScript/RxJS doing here??????

        /* tslint:disable deprecation */
        // @ts-ignore

        regular$.subscribe(obs);
        /* tslint:enable deprecation */
      };

      var callbacks = {
        reject: reject,
        resolve: resolve,
        fallback: fallback
      };
      var abort = customSegmentLoader(args, callbacks);
      return function () {
        if (!hasFinished && !hasFallbacked && typeof abort === "function") {
          abort();
        }
      };
    });
  }
}

exports.default = generateSegmentLoader;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../utils/request":"../../../utils/request/index.ts","../../utils/warn_once":"../../../utils/warn_once.ts","../utils/byte_range":"../../../transports/utils/byte_range.ts","../utils/check_isobmff_integrity":"../../../transports/utils/check_isobmff_integrity.ts","../utils/is_webm_embedded_track":"../../../transports/utils/is_webm_embedded_track.ts","./init_segment_loader":"../../../transports/dash/init_segment_loader.ts","./low_latency_segment_loader":"../../../transports/dash/low_latency_segment_loader.ts"}],"../../../parsers/containers/matroska/utils.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../../log"));

var SEGMENT_ID = 0x18538067;
var INFO_ID = 0x1549a966;
var TIMECODESCALE_ID = 0x2AD7B1;
var DURATION_ID = 0x4489;
var CUES_ID = 0x1C53BB6B;
var CUE_POINT_ID = 0xbb;
var CUE_TIME_ID = 0xb3;
var CUE_TRACK_POSITIONS_ID = 0xb7;
var CUE_CLUSTER_POSITIONS_ID = 0xf1;
/**
 * Find the offsets of the value linked to the given element ID.
 * @param {number} elementID - ID for the searched element.
 * @param {Array.<number>} parents - eventual IDs of the parent elements. From
 * top level to lower level (from the furthest to the closest).
 * @param {Uint8Array} buffer - buffer where the ID will be searched
 * @param {Array.<number>} range - start and end offsets in the buffer where the
 * ID will be searched.
 * @returns {Array.<number>|null}
 */

function findNextElement(elementID, parents, buffer, _ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      initialOffset = _ref2[0],
      maxOffset = _ref2[1];

  var currentOffset = initialOffset;

  while (currentOffset < maxOffset) {
    var parsedID = getEBMLID(buffer, currentOffset);

    if (parsedID == null) {
      return null;
    }

    var ebmlTagID = parsedID.value,
        ebmlTagLength = parsedID.length;
    var sizeOffset = currentOffset + ebmlTagLength;
    var parsedValue = getEBMLValue(buffer, sizeOffset);

    if (parsedValue == null) {
      return null;
    }

    var valueLengthLength = parsedValue.length,
        valueLength = parsedValue.value;
    var valueOffset = sizeOffset + valueLengthLength;
    var valueEndOffset = valueOffset + valueLength;

    if (ebmlTagID === elementID) {
      return [valueOffset, valueEndOffset];
    } else if (parents.length) {
      for (var i = 0; i < parents.length; i++) {
        if (ebmlTagID === parents[i]) {
          var newParents = parents.slice(i + 1, parents.length);
          return findNextElement(elementID, newParents, buffer, [valueOffset, valueEndOffset]);
        }
      }
    }

    currentOffset = valueEndOffset;
  }

  return null;
}
/**
 * Return the timecode scale (basically timescale) of the whole file.
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {number|null}
 */


function getTimeCodeScale(buffer, initialOffset) {
  var timeCodeScaleOffsets = findNextElement(TIMECODESCALE_ID, [SEGMENT_ID, INFO_ID], buffer, [initialOffset, buffer.length]);

  if (timeCodeScaleOffsets == null) {
    return null;
  }

  var length = timeCodeScaleOffsets[1] - timeCodeScaleOffsets[0];
  return 1e9 / bytesToNumber(buffer, timeCodeScaleOffsets[0], length);
}

exports.getTimeCodeScale = getTimeCodeScale;
/**
 * Return the duration of the concerned media.
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {number|null}
 */

function getDuration(buffer, initialOffset) {
  var timeCodeScaleOffsets = findNextElement(DURATION_ID, [SEGMENT_ID, INFO_ID], buffer, [initialOffset, buffer.length]);

  if (timeCodeScaleOffsets == null) {
    return null;
  }

  var length = timeCodeScaleOffsets[1] - timeCodeScaleOffsets[0];

  if (length === 4) {
    return get_IEEE754_32Bits(buffer, timeCodeScaleOffsets[0]);
  } else if (length === 8) {
    return get_IEEE754_64Bits(buffer, timeCodeScaleOffsets[0]);
  }

  return null;
}
/**
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {Array.<Object>|null}
 */


function getSegmentsFromCues(buffer, initialOffset) {
  var segmentRange = findNextElement(SEGMENT_ID, [], buffer, [initialOffset, buffer.length]);

  if (segmentRange == null) {
    return null;
  }

  var _segmentRange = _slicedToArray(segmentRange, 2),
      segmentRangeStart = _segmentRange[0],
      segmentRangeEnd = _segmentRange[1];

  var timescale = getTimeCodeScale(buffer, segmentRangeStart);

  if (timescale == null) {
    return null;
  }

  var duration = getDuration(buffer, segmentRangeStart);

  if (duration == null) {
    return null;
  }

  var cuesRange = findNextElement(CUES_ID, [], buffer, [segmentRangeStart, segmentRangeEnd]);

  if (cuesRange == null) {
    return null;
  }

  var rawInfos = [];
  var currentOffset = cuesRange[0];

  while (currentOffset < cuesRange[1]) {
    var cuePointRange = findNextElement(CUE_POINT_ID, [], buffer, [currentOffset, cuesRange[1]]);

    if (cuePointRange == null) {
      break;
    }

    var cueTimeRange = findNextElement(CUE_TIME_ID, [], buffer, [cuePointRange[0], cuePointRange[1]]);

    if (cueTimeRange == null) {
      return null;
    }

    var time = bytesToNumber(buffer, cueTimeRange[0], cueTimeRange[1] - cueTimeRange[0]);
    var cueOffsetRange = findNextElement(CUE_CLUSTER_POSITIONS_ID, [CUE_TRACK_POSITIONS_ID], buffer, [cuePointRange[0], cuePointRange[1]]);

    if (cueOffsetRange == null) {
      return null;
    }

    var rangeStart = bytesToNumber(buffer, cueOffsetRange[0], cueOffsetRange[1] - cueOffsetRange[0]) + segmentRangeStart;
    rawInfos.push({
      time: time,
      rangeStart: rangeStart
    });
    currentOffset = cuePointRange[1];
  }

  var segments = [];

  for (var i = 0; i < rawInfos.length; i++) {
    var currentSegment = rawInfos[i];

    if (i === rawInfos.length - 1) {
      segments.push({
        time: currentSegment.time,
        count: 0,
        timescale: timescale,
        duration: i === 0 ? duration : duration - currentSegment.time,
        range: [currentSegment.rangeStart, Infinity]
      });
    } else {
      segments.push({
        time: currentSegment.time,
        count: 0,
        timescale: timescale,
        duration: rawInfos[i + 1].time - currentSegment.time,
        range: [currentSegment.rangeStart, rawInfos[i + 1].rangeStart - 1]
      });
    }
  }

  return segments;
}

exports.getSegmentsFromCues = getSegmentsFromCues;

function getLength(buffer, offset) {
  for (var length = 1; length <= 8; length++) {
    if (buffer[offset] >= Math.pow(2, 8 - length)) {
      return length;
    }
  }

  return undefined;
}

function getEBMLID(buffer, offset) {
  var length = getLength(buffer, offset);

  if (length == null) {
    log_1.default.warn("webm: unrepresentable length");
    return null;
  }

  if (offset + length > buffer.length) {
    log_1.default.warn("webm: impossible length");
    return null;
  }

  var value = 0;

  for (var i = 0; i < length; i++) {
    value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;
  }

  return {
    length: length,
    value: value
  };
}

function getEBMLValue(buffer, offset) {
  var length = getLength(buffer, offset);

  if (length == null) {
    log_1.default.warn("webm: unrepresentable length");
    return null;
  }

  if (offset + length > buffer.length) {
    log_1.default.warn("webm: impossible length");
    return null;
  }

  var value = (buffer[offset] & (1 << 8 - length) - 1) * Math.pow(2, (length - 1) * 8);

  for (var i = 1; i < length; i++) {
    value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;
  }

  return {
    length: length,
    value: value
  };
}
/**
 * Convert a IEEE754 32 bits floating number as an Uint8Array into its
 * corresponding Number.
 * @param {Uint8Array} buffer
 * @param {number} offset
 * @returns {number}
 */


function get_IEEE754_32Bits(buffer, offset) {
  return new DataView(buffer.buffer).getFloat32(offset);
}
/**
 * Convert a IEEE754 64 bits floating number as an Uint8Array into its
 * corresponding Number.
 * @param {Uint8Array} buffer
 * @param {number} offset
 * @returns {number}
 */


function get_IEEE754_64Bits(buffer, offset) {
  return new DataView(buffer.buffer).getFloat64(offset);
}

function bytesToNumber(buffer, offset, length) {
  var value = 0;

  for (var i = 0; i < length; i++) {
    value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;
  }

  return value;
}
},{"../../../log":"../../../log.ts"}],"../../../parsers/containers/matroska/index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var utils_1 = require("./utils");

exports.ICuesSegment = utils_1.ICuesSegment;
exports.getSegmentsFromCues = utils_1.getSegmentsFromCues;
exports.getTimeCodeScale = utils_1.getTimeCodeScale;
},{"./utils":"../../../parsers/containers/matroska/utils.ts"}],"../../../transports/utils/get_isobmff_timing_infos.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var isobmff_1 = require("../../parsers/containers/isobmff");
/**
 * Get precize start and duration of a chunk.
 * @param {UInt8Array} buffer - An ISOBMFF container (at least a `moof` + a
 * `mdat` box.
 * @param {Boolean} isChunked - If true, the whole segment was chunked into
 * multiple parts and buffer is one of them. If false, buffer is the whole
 * segment.
 * @param {Object} segment
 * @param {Array.<Object>|undefined} sidxSegments - Segments from sidx. Here
 * pre-parsed for performance reasons as it is usually available when
 * this function is called.
 * @param {Object|undefined} initInfos
 * @returns {Object}
 */


function getISOBMFFTimingInfos(buffer, isChunked, segment, initInfos) {
  var startTime;
  var duration;
  var trunDuration = isobmff_1.getDurationFromTrun(buffer);
  var timescale = initInfos && initInfos.timescale ? initInfos.timescale : segment.timescale;
  var baseDecodeTime = isobmff_1.getTrackFragmentDecodeTime(buffer);

  if (isChunked) {
    // when chunked, no mean to know the duration for now
    if (initInfos == null) {
      return null;
    }

    if (baseDecodeTime < 0) {
      return null;
    }

    return {
      time: baseDecodeTime,
      duration: trunDuration >= 0 ? trunDuration : undefined,
      timescale: initInfos.timescale
    };
  } // we could always make a mistake when reading a container.
  // If the estimate is too far from what the segment seems to imply, take
  // the segment infos instead.


  var maxDecodeTimeDelta; // Scaled start time and duration as announced in the segment data

  var segmentDuration;

  if (timescale === segment.timescale) {
    maxDecodeTimeDelta = Math.min(timescale * 0.9, segment.duration != null ? segment.duration / 4 : 0.25);
    segmentDuration = segment.duration;
  } else {
    maxDecodeTimeDelta = Math.min(timescale * 0.9, segment.duration != null ? segment.duration / segment.timescale * timescale / 4 : 0.25);
    segmentDuration = segment.duration != null ? segment.duration / segment.timescale * timescale : undefined;
  }

  if (baseDecodeTime >= 0) {
    startTime = segment.timestampOffset != null ? baseDecodeTime + segment.timestampOffset * timescale : baseDecodeTime;
  } else {
    return null;
  }

  if (trunDuration >= 0 && (segmentDuration == null || Math.abs(trunDuration - segmentDuration) <= maxDecodeTimeDelta)) {
    duration = trunDuration;
  }

  return {
    timescale: timescale,
    time: startTime,
    duration: duration
  };
}

exports.default = getISOBMFFTimingInfos;
},{"../../parsers/containers/isobmff":"../../../parsers/containers/isobmff/index.ts"}],"../../../transports/dash/segment_parser.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var isobmff_1 = require("../../parsers/containers/isobmff");

var matroska_1 = require("../../parsers/containers/matroska");

var get_isobmff_timing_infos_1 = __importDefault(require("../utils/get_isobmff_timing_infos"));

var is_webm_embedded_track_1 = __importDefault(require("../utils/is_webm_embedded_track"));

function parser(_ref) {
  var content = _ref.content,
      response = _ref.response,
      init = _ref.init;
  var period = content.period,
      representation = content.representation,
      segment = content.segment;
  var data = response.data,
      isChunked = response.isChunked;

  if (data == null) {
    return rxjs_1.of({
      chunkData: null,
      chunkInfos: null,
      chunkOffset: 0,
      appendWindow: [period.start, period.end]
    });
  }

  var chunkData = data instanceof Uint8Array ? data : new Uint8Array(data);
  var isWEBM = is_webm_embedded_track_1.default(representation);

  if (!segment.isInit) {
    var chunkInfos = isWEBM ? null : // TODO extract from webm
    get_isobmff_timing_infos_1.default(chunkData, isChunked, segment, init);
    var chunkOffset = segment.timestampOffset || 0;
    return rxjs_1.of({
      chunkData: chunkData,
      chunkInfos: chunkInfos,
      chunkOffset: chunkOffset,
      appendWindow: [period.start, period.end]
    });
  } // it is an initialization segment


  var indexRange = segment.indexRange;
  var nextSegments = isWEBM ? matroska_1.getSegmentsFromCues(chunkData, 0) : isobmff_1.getSegmentsFromSidx(chunkData, indexRange ? indexRange[0] : 0);

  if (nextSegments) {
    representation.index._addSegments(nextSegments);
  }

  var timescale = isWEBM ? matroska_1.getTimeCodeScale(chunkData, 0) : isobmff_1.getMDHDTimescale(chunkData);
  var initChunkInfos = timescale != null && timescale > 0 ? {
    time: 0,
    duration: 0,
    timescale: timescale
  } : null;
  return rxjs_1.of({
    chunkData: chunkData,
    chunkInfos: initChunkInfos,
    chunkOffset: segment.timestampOffset || 0,
    appendWindow: [period.start, period.end]
  });
}

exports.default = parser;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","../../parsers/containers/isobmff":"../../../parsers/containers/isobmff/index.ts","../../parsers/containers/matroska":"../../../parsers/containers/matroska/index.ts","../utils/get_isobmff_timing_infos":"../../../transports/utils/get_isobmff_timing_infos.ts","../utils/is_webm_embedded_track":"../../../transports/utils/is_webm_embedded_track.ts"}],"../../../transports/utils/is_mp4_embedded_text_track.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Returns true if the given texttrack segment represents a textrack embedded
 * in a mp4 file.
 * @param {Representation} representation
 * @returns {Boolean}
 */

function isMP4EmbeddedTextTrack(representation) {
  return representation.mimeType === "application/mp4";
}

exports.default = isMP4EmbeddedTextTrack;
},{}],"../../../transports/dash/text_loader.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var request_1 = __importStar(require("../../utils/request"));

var warn_once_1 = __importDefault(require("../../utils/warn_once"));

var byte_range_1 = __importDefault(require("../utils/byte_range"));

var check_isobmff_integrity_1 = __importDefault(require("../utils/check_isobmff_integrity"));

var is_mp4_embedded_text_track_1 = __importDefault(require("../utils/is_mp4_embedded_text_track"));

var init_segment_loader_1 = __importDefault(require("./init_segment_loader"));

var low_latency_segment_loader_1 = __importDefault(require("./low_latency_segment_loader"));
/**
 * Perform requests for "text" segments
 * @param {boolean} lowLatencyMode
 * @returns {Function}
 */


function generateTextTrackLoader(_ref) {
  var lowLatencyMode = _ref.lowLatencyMode,
      checkMediaSegmentIntegrity = _ref.checkMediaSegmentIntegrity;

  if (checkMediaSegmentIntegrity !== true) {
    return textTrackLoader;
  }

  return function (content) {
    return textTrackLoader(content).pipe(operators_1.tap(function (res) {
      if ((res.type === "data-loaded" || res.type === "data-chunk") && res.value.responseData !== null && typeof res.value.responseData !== "string") {
        check_isobmff_integrity_1.default(new Uint8Array(res.value.responseData), content.segment.isInit);
      }
    }));
  };
  /**
   * @param {Object} args
   * @returns {Observable}
   */

  function textTrackLoader(args) {
    var _args$segment = args.segment,
        mediaURL = _args$segment.mediaURL,
        range = _args$segment.range;

    if (mediaURL == null) {
      return rxjs_1.of({
        type: "data-created",
        value: {
          responseData: null
        }
      });
    }

    if (args.segment.isInit) {
      return init_segment_loader_1.default(mediaURL, args);
    }

    var isMP4Embedded = is_mp4_embedded_text_track_1.default(args.representation);

    if (lowLatencyMode && isMP4Embedded) {
      if (request_1.fetchIsSupported()) {
        return low_latency_segment_loader_1.default(mediaURL, args);
      } else {
        warn_once_1.default("DASH: Your browser does not have the fetch API. You will have " + "a higher chance of rebuffering when playing close to the live edge");
      }
    } // ArrayBuffer when in mp4 to parse isobmff manually, text otherwise


    var responseType = isMP4Embedded ? "arraybuffer" : "text";
    return request_1.default({
      url: mediaURL,
      responseType: responseType,
      headers: range ? {
        Range: byte_range_1.default(range)
      } : null,
      sendProgressEvents: true
    });
  }
}

exports.default = generateTextTrackLoader;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../utils/request":"../../../utils/request/index.ts","../../utils/warn_once":"../../../utils/warn_once.ts","../utils/byte_range":"../../../transports/utils/byte_range.ts","../utils/check_isobmff_integrity":"../../../transports/utils/check_isobmff_integrity.ts","../utils/is_mp4_embedded_text_track":"../../../transports/utils/is_mp4_embedded_text_track.ts","./init_segment_loader":"../../../transports/dash/init_segment_loader.ts","./low_latency_segment_loader":"../../../transports/dash/low_latency_segment_loader.ts"}],"../../../utils/string_from_utf8.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Creates a new string from the given array of char codes.
 *
 * @param {Uint8Array} args
 * @returns {string}
 */

function stringFromCharCode(args) {
  var max = 16000;
  var ret = "";

  for (var i = 0; i < args.length; i += max) {
    var subArray = args.subarray(i, i + max); // NOTE: ugly I know, but TS is problematic here (you can try)

    ret += String.fromCharCode.apply(null, subArray);
  }

  return ret;
}
/**
 * Creates a string from the given buffer as UTF-8 encoding.
 * @param {BufferSource} [data]
 * @returns {string}
 * @throws {Error}
 * @export
 */


function stringFromUTF8(data) {
  if (!data) {
    return "";
  }

  var uint8 = new Uint8Array(data); // If present, strip off the UTF-8 BOM.

  if (uint8[0] === 0xef && uint8[1] === 0xbb && uint8[2] === 0xbf) {
    uint8 = uint8.subarray(3);
  } // http://stackoverflow.com/a/13691499


  var utf8 = stringFromCharCode(uint8); // This converts each character in the string to an escape sequence.  If the
  // character is in the ASCII range, it is not converted; otherwise it is
  // converted to a URI escape sequence.
  // Example: "\x67\x35\xe3\x82\xac" -> "g#%E3%82%AC"
  // TODO "escape" is deprecated, provide a ponyfill?

  var escaped = escape(utf8); // Decode the escaped sequence.  This will interpret UTF-8 sequences into the
  // correct character.
  // Example: "g#%E3%82%AC" -> "g#â¬"

  return decodeURIComponent(escaped);
}

exports.default = stringFromUTF8;
},{}],"../../../transports/utils/parse_text_track.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../log"));

var isobmff_1 = require("../../parsers/containers/isobmff");

var string_from_utf8_1 = __importDefault(require("../../utils/string_from_utf8"));
/**
 * Return plain text text track from the given ISOBMFF.
 * @param {Uint8Array} chunkBytes
 * @returns {string}
 */


function extractTextTrackFromISOBMFF(chunkBytes) {
  return string_from_utf8_1.default(isobmff_1.getMDAT(chunkBytes));
}

exports.extractTextTrackFromISOBMFF = extractTextTrackFromISOBMFF;
/**
 * Returns the a string expliciting the format of a text track when that text
 * track is embedded into a ISOBMFF file.
 * @param {Object} representation
 * @returns {string}
 */

function getISOBMFFTextTrackFormat(representation) {
  var codec = representation.codec == null ? "" : representation.codec;

  switch (codec.toLowerCase()) {
    case "stpp": // stpp === TTML in MP4

    case "stpp.ttml.im1t":
      return "ttml";

    case "wvtt":
      // wvtt === WebVTT in MP4
      return "vtt";
  }

  throw new Error("The codec used for the subtitles " + "\"".concat(codec, "\" is not managed yet."));
}

exports.getISOBMFFTextTrackFormat = getISOBMFFTextTrackFormat;
/**
 * Returns the a string expliciting the format of a text track in plain text.
 * @param {Object} representation
 * @returns {string}
 */

function getPlainTextTrackFormat(representation) {
  var _representation$mimeT = representation.mimeType,
      mimeType = _representation$mimeT === void 0 ? "" : _representation$mimeT;

  switch (representation.mimeType) {
    case "application/ttml+xml":
      return "ttml";

    case "application/x-sami":
    case "application/smil":
      return "sami";

    case "text/vtt":
      return "vtt";
  }

  var _representation$codec = representation.codec,
      codec = _representation$codec === void 0 ? "" : _representation$codec;
  var codeLC = codec.toLowerCase();

  if (codeLC === "srt") {
    return "srt";
  }

  throw new Error("could not find a text-track parser for the type ".concat(mimeType));
}

exports.getPlainTextTrackFormat = getPlainTextTrackFormat;
/**
 * @param {Object} content
 * @param {ArrayBuffer|UInt8Array|null} chunkData
 * @param {Object|null} chunkInfos
 * @param {boolean} isChunked
 * @returns {Object|null}
 */

function getISOBMFFEmbeddedTextTrackData(_ref, chunkBytes, chunkInfos, isChunked) {
  var segment = _ref.segment,
      adaptation = _ref.adaptation,
      representation = _ref.representation;

  if (segment.isInit) {
    return null;
  }

  var startTime;
  var endTime;
  var timescale = 1;

  if (chunkInfos == null) {
    if (!isChunked) {
      log_1.default.warn("Transport: Unavailable time data for current text track.");
    } else {
      startTime = segment.time;
      endTime = startTime + segment.duration;
      timescale = segment.timescale;
    }
  } else {
    startTime = chunkInfos.time;

    if (chunkInfos.duration != null) {
      endTime = startTime + chunkInfos.duration;
    } else if (!isChunked) {
      endTime = startTime + segment.duration;
    }

    timescale = chunkInfos.timescale;
  }

  var type = getISOBMFFTextTrackFormat(representation);
  var textData = extractTextTrackFromISOBMFF(chunkBytes);
  return {
    data: textData,
    type: type,
    language: adaptation.language,
    start: startTime,
    end: endTime,
    timescale: timescale
  };
}

exports.getISOBMFFEmbeddedTextTrackData = getISOBMFFEmbeddedTextTrackData;
/**
 * @param {Object} content
 * @param {ArrayBuffer|UInt8Array|null} chunkData
 * @param {Object|null} chunkInfos
 * @param {boolean} isChunked
 * @returns {Object|null}
 */

function getPlainTextTrackData(_ref2, textTrackData, isChunked) {
  var segment = _ref2.segment,
      adaptation = _ref2.adaptation,
      representation = _ref2.representation;

  if (segment.isInit) {
    return null;
  }

  var start;
  var end;
  var timescale = 1;

  if (!isChunked) {
    start = segment.time;
    end = start + segment.duration;
    timescale = segment.timescale;
  } else {
    log_1.default.warn("Transport: Unavailable time data for current text track.");
  }

  var type = getPlainTextTrackFormat(representation);
  return {
    data: textTrackData,
    type: type,
    language: adaptation.language,
    start: start,
    end: end,
    timescale: timescale
  };
}

exports.getPlainTextTrackData = getPlainTextTrackData;
},{"../../log":"../../../log.ts","../../parsers/containers/isobmff":"../../../parsers/containers/isobmff/index.ts","../../utils/string_from_utf8":"../../../utils/string_from_utf8.ts"}],"../../../transports/dash/text_parser.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var isobmff_1 = require("../../parsers/containers/isobmff");

var byte_parsing_1 = require("../../utils/byte_parsing");

var get_isobmff_timing_infos_1 = __importDefault(require("../utils/get_isobmff_timing_infos"));

var is_mp4_embedded_text_track_1 = __importDefault(require("../utils/is_mp4_embedded_text_track"));

var parse_text_track_1 = require("../utils/parse_text_track");
/**
 * Parse TextTrack data when it is embedded in an ISOBMFF file.
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */


function parseISOBMFFEmbeddedTextTrack(_ref) {
  var response = _ref.response,
      content = _ref.content,
      init = _ref.init;
  var period = content.period,
      representation = content.representation,
      segment = content.segment;
  var isInit = segment.isInit,
      indexRange = segment.indexRange;
  var data = response.data,
      isChunked = response.isChunked;
  var chunkBytes = typeof data === "string" ? byte_parsing_1.strToBytes(data) : data instanceof Uint8Array ? data : new Uint8Array(data);

  if (isInit) {
    var sidxSegments = isobmff_1.getSegmentsFromSidx(chunkBytes, indexRange ? indexRange[0] : 0);
    var mdhdTimescale = isobmff_1.getMDHDTimescale(chunkBytes);
    var initChunkInfos = mdhdTimescale > 0 ? {
      time: 0,
      duration: 0,
      timescale: mdhdTimescale
    } : null;

    if (sidxSegments) {
      representation.index._addSegments(sidxSegments);
    }

    return rxjs_1.of({
      chunkData: null,
      chunkInfos: initChunkInfos,
      chunkOffset: segment.timestampOffset || 0,
      appendWindow: [period.start, period.end]
    });
  }

  var chunkInfos = get_isobmff_timing_infos_1.default(chunkBytes, isChunked, segment, init);
  var chunkData = parse_text_track_1.getISOBMFFEmbeddedTextTrackData(content, chunkBytes, chunkInfos, isChunked);
  return rxjs_1.of({
    chunkData: chunkData,
    chunkInfos: chunkInfos,
    chunkOffset: segment.timestampOffset || 0,
    appendWindow: [period.start, period.end]
  });
}
/**
 * Parse TextTrack data in plain text form.
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */


function parsePlainTextTrack(_ref2) {
  var response = _ref2.response,
      content = _ref2.content;
  var period = content.period,
      segment = content.segment;

  if (segment.isInit) {
    return rxjs_1.of({
      chunkData: null,
      chunkInfos: null,
      chunkOffset: segment.timestampOffset || 0,
      appendWindow: [period.start, period.end]
    });
  }

  var data = response.data,
      isChunked = response.isChunked;
  var textTrackData;

  if (typeof data !== "string") {
    var bytesData = data instanceof Uint8Array ? data : new Uint8Array(data);
    textTrackData = byte_parsing_1.bytesToStr(bytesData);
  } else {
    textTrackData = data;
  }

  var chunkData = parse_text_track_1.getPlainTextTrackData(content, textTrackData, isChunked);
  return rxjs_1.of({
    chunkData: chunkData,
    chunkInfos: null,
    chunkOffset: segment.timestampOffset || 0,
    appendWindow: [period.start, period.end]
  });
}
/**
 * Parse TextTrack data.
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */


function textTrackParser(_ref3) {
  var response = _ref3.response,
      content = _ref3.content,
      init = _ref3.init;
  var period = content.period,
      representation = content.representation,
      segment = content.segment;
  var data = response.data,
      isChunked = response.isChunked;

  if (data == null) {
    // No data, just return empty infos
    return rxjs_1.of({
      chunkData: null,
      chunkInfos: null,
      chunkOffset: segment.timestampOffset || 0,
      appendWindow: [period.start, period.end]
    });
  }

  var isMP4 = is_mp4_embedded_text_track_1.default(representation);

  if (isMP4) {
    return parseISOBMFFEmbeddedTextTrack({
      response: {
        data: data,
        isChunked: isChunked
      },
      content: content,
      init: init
    });
  } else {
    return parsePlainTextTrack({
      response: {
        data: data,
        isChunked: isChunked
      },
      content: content
    });
  }
}

exports.default = textTrackParser;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","../../parsers/containers/isobmff":"../../../parsers/containers/isobmff/index.ts","../../utils/byte_parsing":"../../../utils/byte_parsing.ts","../utils/get_isobmff_timing_infos":"../../../transports/utils/get_isobmff_timing_infos.ts","../utils/is_mp4_embedded_text_track":"../../../transports/utils/is_mp4_embedded_text_track.ts","../utils/parse_text_track":"../../../transports/utils/parse_text_track.ts"}],"../../../transports/dash/pipelines.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var document_manifest_loader_1 = __importDefault(require("../utils/document_manifest_loader"));

var image_pipelines_1 = require("./image_pipelines");

var manifest_parser_1 = __importDefault(require("./manifest_parser"));

var segment_loader_1 = __importDefault(require("./segment_loader"));

var segment_parser_1 = __importDefault(require("./segment_parser"));

var text_loader_1 = __importDefault(require("./text_loader"));

var text_parser_1 = __importDefault(require("./text_parser"));
/**
 * Returns pipelines used for DASH streaming.
 * @param {Object} options
 * implementation. Used for each generated http request.
 * @returns {Object}
 */


function default_1(options) {
  var manifestLoader = document_manifest_loader_1.default({
    customManifestLoader: options.manifestLoader
  });
  var manifestParser = manifest_parser_1.default(options);
  var segmentLoader = segment_loader_1.default(options);
  var textTrackLoader = text_loader_1.default(options);
  return {
    manifest: {
      loader: manifestLoader,
      parser: manifestParser
    },
    audio: {
      loader: segmentLoader,
      parser: segment_parser_1.default
    },
    video: {
      loader: segmentLoader,
      parser: segment_parser_1.default
    },
    text: {
      loader: textTrackLoader,
      parser: text_parser_1.default
    },
    image: {
      loader: image_pipelines_1.imageLoader,
      parser: image_pipelines_1.imageParser
    }
  };
}

exports.default = default_1;
},{"../utils/document_manifest_loader":"../../../transports/utils/document_manifest_loader.ts","./image_pipelines":"../../../transports/dash/image_pipelines.ts","./manifest_parser":"../../../transports/dash/manifest_parser.ts","./segment_loader":"../../../transports/dash/segment_loader.ts","./segment_parser":"../../../transports/dash/segment_parser.ts","./text_loader":"../../../transports/dash/text_loader.ts","./text_parser":"../../../transports/dash/text_parser.ts"}],"../../../transports/dash/index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

var pipelines_1 = __importDefault(require("./pipelines"));

exports.default = pipelines_1.default;
},{"./pipelines":"../../../transports/dash/pipelines.ts"}],"../../../parsers/manifest/smooth/get_codecs.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @param {string} fourCC
 * @param {string} codecPrivateData
 * @returns {string}
 */

function getAudioCodecs(fourCC, codecPrivateData) {
  var mpProfile;

  if (fourCC === "AACH") {
    mpProfile = 5; // High Efficiency AAC Profile
  } else {
    mpProfile = codecPrivateData ? (parseInt(codecPrivateData.substring(0, 2), 16) & 0xF8) >> 3 : 2;
  }

  return mpProfile ? "mp4a.40." + mpProfile : "";
}

exports.getAudioCodecs = getAudioCodecs;
/**
 * @param {string} codecPrivateData
 * @returns {string}
 */

function getVideoCodecs(codecPrivateData) {
  // we can extract codes only if fourCC is on of "H264", "X264", "DAVC", "AVC1"
  var _ref = /00000001\d7([0-9a-fA-F]{6})/.exec(codecPrivateData) || [],
      _ref2 = _slicedToArray(_ref, 2),
      _ref2$ = _ref2[1],
      avcProfile = _ref2$ === void 0 ? "" : _ref2$;

  return avcProfile && "avc1." + avcProfile;
}

exports.getVideoCodecs = getVideoCodecs;
},{}],"../../../parsers/manifest/smooth/parse_C_nodes.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Parse C nodes to build index timeline.
 * @param {Element} nodes
 */

function parseCNodes(nodes) {
  return nodes.reduce(function (timeline, node, i) {
    var dAttr = node.getAttribute("d");
    var tAttr = node.getAttribute("t");
    var rAttr = node.getAttribute("r");
    var repeatCount = rAttr ? +rAttr - 1 : 0;
    var start = tAttr ? +tAttr : undefined;
    var duration = dAttr ? +dAttr : undefined;

    if (i === 0) {
      // first node
      start = start || 0;
    } else {
      // from second node to the end
      var prev = timeline[i - 1];

      if (start == null || isNaN(start)) {
        if (prev.duration == null || isNaN(prev.duration)) {
          throw new Error("Smooth: Invalid CNodes. Missing timestamp.");
        }

        start = prev.start + prev.duration * (prev.repeatCount + 1);
      }
    }

    if (duration == null || isNaN(duration)) {
      var nextNode = nodes[i + 1];

      if (nextNode) {
        var nextTAttr = nextNode.getAttribute("t");
        var nextStart = nextTAttr ? +nextTAttr : null;

        if (nextStart === null) {
          throw new Error("Can't build index timeline from Smooth Manifest.");
        }

        duration = nextStart - start;
      } else {
        return timeline;
      }
    }

    timeline.push({
      duration: duration,
      start: start,
      repeatCount: repeatCount
    });
    return timeline;
  }, []);
}

exports.default = parseCNodes;
},{}],"../../../parsers/manifest/smooth/parse_protection_node.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var byte_parsing_1 = require("../../../utils/byte_parsing");

var isobmff_1 = require("../../containers/isobmff");
/**
 * @param {Uint8Array} keyIdBytes
 * @returns {Array.<Object>}
 */


function createWidevineKeySystem(keyIdBytes) {
  return [{
    systemId: "edef8ba9-79d6-4ace-a3c8-27dcd51d21ed",
    privateData: byte_parsing_1.concat([0x08, 0x01, 0x12, 0x10], keyIdBytes)
  }];
}
/**
 * Parse "Protection" Node, which contains DRM information
 * @param {Element} protectionNode
 * @returns {Object}
 */


function parseProtectionNode(protectionNode) {
  var keySystemCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createWidevineKeySystem;

  if (!protectionNode.firstElementChild || protectionNode.firstElementChild.nodeName !== "ProtectionHeader") {
    throw new Error("Protection should have ProtectionHeader child");
  }

  var header = protectionNode.firstElementChild;
  var privateData = byte_parsing_1.strToBytes(atob(header.textContent || ""));
  var keyIdHex = isobmff_1.getPlayReadyKIDFromPrivateData(privateData);
  var keyIdBytes = byte_parsing_1.hexToBytes(keyIdHex); // remove possible braces

  var systemId = (header.getAttribute("SystemID") || "").toLowerCase().replace(/\{|\}/g, "");
  return {
    keyId: keyIdBytes,
    keySystems: [{
      systemId: systemId,
      privateData: privateData
    }].concat(keySystemCreator(keyIdBytes))
  };
}

exports.default = parseProtectionNode;
},{"../../../utils/byte_parsing":"../../../utils/byte_parsing.ts","../../containers/isobmff":"../../../parsers/containers/isobmff/index.ts"}],"../../../parsers/manifest/smooth/utils/add_segment_infos.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var index_helpers_1 = require("../../utils/index_helpers");
/**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} newSegment
 * @param {Object} currentSegment
 * @returns {Boolean} - true if the segment has been added
 */


function _addSegmentInfos(index, newSegment, currentSegment) {
  var timeline = index.timeline,
      timescale = index.timescale;
  var timelineLength = timeline.length;
  var last = timeline[timelineLength - 1];
  var scaledNewSegment = newSegment.timescale === timescale ? {
    time: newSegment.time,
    duration: newSegment.duration
  } : {
    time: newSegment.time / newSegment.timescale * timescale,
    duration: newSegment.duration / newSegment.timescale * timescale
  };
  var scaledCurrentTime;

  if (currentSegment && currentSegment.timescale) {
    scaledCurrentTime = currentSegment.timescale === timescale ? currentSegment.time : currentSegment.time / currentSegment.timescale * timescale;
  } // in some circumstances, the new segment information are only duration
  // information that we could use to deduct the start of the next segment.
  // This is the case where the new segment are associated to a current
  // segment and have the same start.
  // However, we prefer to be sure of the duration of the new segments
  // before adding such segments.


  var shouldDeductNextSegment = scaledCurrentTime != null && scaledNewSegment.time === scaledCurrentTime;

  if (shouldDeductNextSegment) {
    return false;
  } else if (scaledNewSegment.time >= index_helpers_1.getIndexSegmentEnd(last, null)) {
    // if the given timing has a timestamp after the timeline end we
    // just need to push a new element in the timeline, or increase
    // the @r attribute of the last element.
    if (last.duration === scaledNewSegment.duration) {
      last.repeatCount++;
    } else {
      index.timeline.push({
        duration: scaledNewSegment.duration,
        start: scaledNewSegment.time,
        repeatCount: 0
      });
    }

    return true;
  }

  return false;
}

exports.default = _addSegmentInfos;
},{"../../utils/index_helpers":"../../../parsers/manifest/utils/index_helpers.ts"}],"../../../parsers/manifest/smooth/utils/tokens.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @param {string} url
 * @param {string|number} bitrate
 * @returns {string}
 */

function replaceRepresentationSmoothTokens(url, bitrate, customAttributes) {
  return url.replace(/\{bitrate\}/g, String(bitrate)).replace(/{CustomAttributes}/g, customAttributes.length > 0 ? customAttributes[0] : "");
}

exports.replaceRepresentationSmoothTokens = replaceRepresentationSmoothTokens;
/**
 * @param {string} url
 * @param {number} time
 * @returns {string}
 */

function replaceSegmentSmoothTokens(url, time) {
  return url.replace(/\{start time\}/g, String(time));
}

exports.replaceSegmentSmoothTokens = replaceSegmentSmoothTokens;
},{}],"../../../parsers/manifest/smooth/representation_index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var errors_1 = require("../../../errors");

var log_1 = __importDefault(require("../../../log"));

var clear_timeline_from_position_1 = __importDefault(require("../utils/clear_timeline_from_position"));

var index_helpers_1 = require("../utils/index_helpers");

var is_segment_still_available_1 = __importDefault(require("../utils/is_segment_still_available"));

var add_segment_infos_1 = __importDefault(require("./utils/add_segment_infos"));

var tokens_1 = require("./utils/tokens");
/**
 * Get index of the segment containing the given timescaled timestamp.
 * @param {Object} index
 * @param {Number} start
 * @returns {Number}
 */


function getSegmentIndex(index, start) {
  var timeline = index.timeline;
  var low = 0;
  var high = timeline.length;

  while (low < high) {
    var mid = low + high >>> 1;

    if (timeline[mid].start < start) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }

  return low > 0 ? low - 1 : low;
}
/**
 * @param {Number} start
 * @param {Number} up
 * @param {Number} duration
 * @returns {Number}
 */


function getSegmentNumber(start, up, duration) {
  var diff = up - start;
  return diff > 0 ? Math.floor(diff / duration) : 0;
} // interface ISmoothIndex {
//   presentationTimeOffset? : number;
//   timescale : number;
//   media? : string;
//   timeline : IIndexSegment[];
//   startNumber? : number;
// }

/**
 * Convert second-based start time and duration to the timescale of the
 * manifest's index.
 * @param {Object} index
 * @param {Number} start
 * @param {Number} duration
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */


function normalizeRange(index, start, duration) {
  var timescale = index.timescale || 1;
  return {
    up: start * timescale,
    to: (start + duration) * timescale
  };
}
/**
 * Calculate the number of times a segment repeat based on the next segment.
 * @param {Object} segment
 * @param {Object} nextSegment
 * @returns {Number}
 */


function calculateRepeat(segment, nextSegment) {
  var repeatCount = segment.repeatCount || 0; // A negative value of the @r attribute of the S element indicates
  // that the duration indicated in @d attribute repeats until the
  // start of the next S element, the end of the Period or until the
  // next MPD update.
  // TODO Also for SMOOTH????

  if (segment.duration != null && repeatCount < 0) {
    var repeatEnd = nextSegment ? nextSegment.start : Infinity;
    repeatCount = Math.ceil((repeatEnd - segment.start) / segment.duration) - 1;
  }

  return repeatCount;
}
/**
 * RepresentationIndex implementation for Smooth Manifests.
 *
 * Allows to interact with the index to create new Segments.
 *
 * @class SmoothRepresentationIndex
 */


var SmoothRepresentationIndex =
/*#__PURE__*/
function () {
  function SmoothRepresentationIndex(index, options) {
    _classCallCheck(this, SmoothRepresentationIndex);

    var aggressiveMode = options.aggressiveMode,
        isLive = options.isLive,
        segmentPrivateInfos = options.segmentPrivateInfos;
    var estimatedReceivedTime = index.manifestReceivedTime == null ? performance.now() : index.manifestReceivedTime;
    this._index = index;
    this._indexValidityTime = estimatedReceivedTime;
    this._initSegmentInfos = {
      bitsPerSample: segmentPrivateInfos.bitsPerSample,
      channels: segmentPrivateInfos.channels,
      codecPrivateData: segmentPrivateInfos.codecPrivateData,
      packetSize: segmentPrivateInfos.packetSize,
      samplingRate: segmentPrivateInfos.samplingRate,
      protection: segmentPrivateInfos.protection
    };
    this._isAggressiveMode = aggressiveMode;
    this._isLive = isLive;

    if (index.timeline.length) {
      var lastItem = index.timeline[index.timeline.length - 1];
      var scaledEnd = index_helpers_1.getIndexSegmentEnd(lastItem, null);
      this._initialScaledLastPosition = scaledEnd;

      if (index.isLive) {
        var scaledReceivedTime = estimatedReceivedTime / 1000 * index.timescale;
        this._scaledLiveGap = scaledReceivedTime - scaledEnd;
      }
    }
  }
  /**
   * Construct init Segment compatible with a Smooth Manifest.
   * @returns {Object}
   */


  _createClass(SmoothRepresentationIndex, [{
    key: "getInitSegment",
    value: function getInitSegment() {
      return {
        id: "init",
        isInit: true,
        time: 0,
        duration: 0,
        timescale: this._index.timescale,
        privateInfos: {
          smoothInit: this._initSegmentInfos
        },
        mediaURL: null
      };
    }
    /**
     * Generate a list of Segments for a particular period of time.
     *
     * @param {Number} _up
     * @param {Number} _to
     * @returns {Array.<Object>}
     */

  }, {
    key: "getSegments",
    value: function getSegments(_up, _to) {
      this._refreshTimeline();

      var _normalizeRange = normalizeRange(this._index, _up, _to),
          up = _normalizeRange.up,
          to = _normalizeRange.to;

      var _this$_index = this._index,
          timeline = _this$_index.timeline,
          timescale = _this$_index.timescale,
          media = _this$_index.media;
      var isAggressive = this._isAggressiveMode;
      var currentNumber;
      var segments = [];
      var timelineLength = timeline.length;
      var maxPosition = this._scaledLiveGap == null ? undefined : performance.now() / 1000 * timescale - this._scaledLiveGap;

      for (var i = 0; i < timelineLength; i++) {
        var segmentRange = timeline[i];
        var duration = segmentRange.duration,
            start = segmentRange.start;
        var repeat = calculateRepeat(segmentRange, timeline[i + 1]);
        var segmentNumberInCurrentRange = getSegmentNumber(start, up, duration);
        var segmentTime = start + segmentNumberInCurrentRange * duration;
        var timeToAddToCheckMaxPosition = isAggressive ? 0 : duration;

        while (segmentTime < to && segmentNumberInCurrentRange <= repeat && (maxPosition == null || segmentTime + timeToAddToCheckMaxPosition <= maxPosition)) {
          var time = segmentTime;
          var number = currentNumber != null ? currentNumber + segmentNumberInCurrentRange : undefined;
          var segment = {
            id: "" + segmentTime,
            time: time,
            isInit: false,
            duration: duration,
            timescale: timescale,
            number: number,
            mediaURL: tokens_1.replaceSegmentSmoothTokens(media, time)
          };
          segments.push(segment); // update segment number and segment time for the next segment

          segmentNumberInCurrentRange++;
          segmentTime = start + segmentNumberInCurrentRange * duration;
        }

        if (segmentTime >= to) {
          // we reached ``to``, we're done
          return segments;
        }

        if (currentNumber != null) {
          currentNumber += repeat + 1;
        }
      }

      return segments;
    }
    /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * (If we should re-fetch the manifest)
     * @param {Number} up
     * @param {Number} to
     * @returns {Boolean}
     */

  }, {
    key: "shouldRefresh",
    value: function shouldRefresh(up, to) {
      this._refreshTimeline();

      if (!this._index.isLive) {
        return false;
      }

      var _this$_index2 = this._index,
          timeline = _this$_index2.timeline,
          timescale = _this$_index2.timescale;
      var lastSegmentInCurrentTimeline = timeline[timeline.length - 1];

      if (!lastSegmentInCurrentTimeline) {
        return false;
      }

      var repeat = lastSegmentInCurrentTimeline.repeatCount || 0;
      var endOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.start + (repeat + 1) * lastSegmentInCurrentTimeline.duration;

      if (to * timescale < endOfLastSegmentInCurrentTimeline) {
        return false;
      }

      if (up * timescale >= endOfLastSegmentInCurrentTimeline) {
        return true;
      } // ----


      var startOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.start + repeat * lastSegmentInCurrentTimeline.duration;
      return up * timescale > startOfLastSegmentInCurrentTimeline;
    }
    /**
     * Returns first position available in the index.
     *
     * @param {Object} index
     * @returns {Number|null}
     */

  }, {
    key: "getFirstPosition",
    value: function getFirstPosition() {
      this._refreshTimeline();

      var index = this._index;

      if (!index.timeline.length) {
        return null;
      }

      return index.timeline[0].start / index.timescale;
    }
    /**
     * Returns last position available in the index.
     * @param {Object} index
     * @returns {Number}
     */

  }, {
    key: "getLastPosition",
    value: function getLastPosition() {
      this._refreshTimeline();

      var index = this._index;

      if (this._scaledLiveGap == null) {
        var lastTimelineElement = index.timeline[index.timeline.length - 1];
        return index_helpers_1.getIndexSegmentEnd(lastTimelineElement, null) / index.timescale;
      }

      for (var i = index.timeline.length - 1; i >= 0; i--) {
        var timelineElt = index.timeline[i];
        var timescaledNow = performance.now() / 1000 * index.timescale;
        var start = timelineElt.start,
            duration = timelineElt.duration,
            repeatCount = timelineElt.repeatCount;

        for (var j = repeatCount; j >= 0; j--) {
          var end = start + duration * (j + 1);
          var positionToReach = this._isAggressiveMode ? end - duration : end;

          if (positionToReach <= timescaledNow - this._scaledLiveGap) {
            return end / index.timescale;
          }
        }
      }

      return undefined;
    }
    /**
     * Checks if the time given is in a discontinuity. That is:
     *   - We're on the upper bound of the current range (end of the range - time
     *     is inferior to the timescale)
     *   - The next range starts after the end of the current range.
     *
     * @param {Number} _time
     * @returns {Number} - If a discontinuity is present, this is the Starting
     * time for the next (discontinuited) range. If not this is equal to -1.
     */

  }, {
    key: "checkDiscontinuity",
    value: function checkDiscontinuity(_time) {
      this._refreshTimeline();

      var index = this._index;
      var timeline = index.timeline,
          _index$timescale = index.timescale,
          timescale = _index$timescale === void 0 ? 1 : _index$timescale;
      var time = _time * timescale;

      if (time <= 0) {
        return -1;
      }

      var segmentIndex = getSegmentIndex(index, time);

      if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) {
        return -1;
      }

      var range = timeline[segmentIndex];

      if (range.duration === -1) {
        return -1;
      }

      var rangeUp = range.start;
      var rangeTo = index_helpers_1.getIndexSegmentEnd(range, null);
      var nextRange = timeline[segmentIndex + 1]; // when we are actually inside the found range and this range has
      // an explicit discontinuity with the next one

      if (rangeTo !== nextRange.start && time >= rangeUp && time <= rangeTo && rangeTo - time < timescale) {
        return nextRange.start / timescale;
      }

      return -1;
    }
  }, {
    key: "isSegmentStillAvailable",
    value: function isSegmentStillAvailable(segment) {
      if (segment.isInit) {
        return true;
      }

      this._refreshTimeline();

      var _this$_index3 = this._index,
          timeline = _this$_index3.timeline,
          timescale = _this$_index3.timescale;
      return is_segment_still_available_1.default(segment, timeline, timescale, 0);
    }
    /**
     * @param {Error} error
     * @returns {Boolean}
     */

  }, {
    key: "canBeOutOfSyncError",
    value: function canBeOutOfSyncError(error) {
      if (!this._isLive) {
        return false;
      }

      return error instanceof errors_1.NetworkError && (error.isHttpError(404) || error.isHttpError(412));
    }
    /**
     * Update this RepresentationIndex by a newly downloaded one.
     * Check if the old index had more information about new segments and re-add
     * them if that's the case.
     * @param {Object} newIndex
     */

  }, {
    key: "_update",
    value: function _update(newIndex) {
      var oldTimeline = this._index.timeline;
      var newTimeline = newIndex._index.timeline;
      var oldTimescale = this._index.timescale;
      var newTimescale = newIndex._index.timescale;
      this._index = newIndex._index;
      this._initialScaledLastPosition = newIndex._initialScaledLastPosition;
      this._indexValidityTime = newIndex._indexValidityTime;
      this._scaledLiveGap = newIndex._scaledLiveGap;

      if (!oldTimeline.length || !newTimeline.length || oldTimescale !== newTimescale) {
        return; // don't take risk, if something is off, take the new one
      }

      var lastOldTimelineElement = oldTimeline[oldTimeline.length - 1];
      var lastNewTimelineElement = newTimeline[newTimeline.length - 1];
      var newEnd = index_helpers_1.getIndexSegmentEnd(lastNewTimelineElement, null);

      if (index_helpers_1.getIndexSegmentEnd(lastOldTimelineElement, null) <= newEnd) {
        return;
      }

      for (var i = 0; i < oldTimeline.length; i++) {
        var oldTimelineRange = oldTimeline[i];
        var oldEnd = index_helpers_1.getIndexSegmentEnd(oldTimelineRange, null);

        if (oldEnd === newEnd) {
          // just add the supplementary segments
          this._index.timeline = this._index.timeline.concat(oldTimeline.slice(i + 1));
          return;
        }

        if (oldEnd > newEnd) {
          // adjust repeatCount + add supplementary segments
          if (oldTimelineRange.duration !== lastNewTimelineElement.duration) {
            return;
          }

          var rangeDuration = newEnd - oldTimelineRange.start;

          if (rangeDuration === 0) {
            log_1.default.warn("Smooth Parser: a discontinuity detected in the previous manifest" + " has been resolved.");
            this._index.timeline = this._index.timeline.concat(oldTimeline.slice(i));
            return;
          }

          if (rangeDuration < 0 || rangeDuration % oldTimelineRange.duration !== 0) {
            return;
          }

          var repeatWithOld = rangeDuration / oldTimelineRange.duration - 1;
          var relativeRepeat = oldTimelineRange.repeatCount - repeatWithOld;

          if (relativeRepeat < 0) {
            return;
          }

          lastNewTimelineElement.repeatCount += relativeRepeat;
          var supplementarySegments = oldTimeline.slice(i + 1);
          this._index.timeline = this._index.timeline.concat(supplementarySegments);
          return;
        }
      }
    }
    /**
     * @returns {Boolean | undefined}
     */

  }, {
    key: "isFinished",
    value: function isFinished() {
      return !this._isLive;
    }
  }, {
    key: "_addSegments",
    value: function _addSegments(nextSegments, currentSegment) {
      this._refreshTimeline();

      for (var i = 0; i < nextSegments.length; i++) {
        add_segment_infos_1.default(this._index, nextSegments[i], currentSegment);
      }
    }
    /**
     * Clean-up timeline to remove segment information which should not be
     * available due to the timeshift window
     */

  }, {
    key: "_refreshTimeline",
    value: function _refreshTimeline() {
      // clean segments before time shift buffer depth
      if (this._initialScaledLastPosition == null) {
        return;
      }

      var index = this._index;
      var timeShiftBufferDepth = index.timeShiftBufferDepth;
      var timeSinceLastRealUpdate = (performance.now() - this._indexValidityTime) / 1000;
      var lastPositionEstimate = timeSinceLastRealUpdate + this._initialScaledLastPosition / index.timescale;

      if (timeShiftBufferDepth != null) {
        var minimumPosition = (lastPositionEstimate - timeShiftBufferDepth) * index.timescale;
        clear_timeline_from_position_1.default(index.timeline, minimumPosition);
      }
    }
  }]);

  return SmoothRepresentationIndex;
}();

exports.default = SmoothRepresentationIndex;
},{"../../../errors":"../../../errors/index.ts","../../../log":"../../../log.ts","../utils/clear_timeline_from_position":"../../../parsers/manifest/utils/clear_timeline_from_position.ts","../utils/index_helpers":"../../../parsers/manifest/utils/index_helpers.ts","../utils/is_segment_still_available":"../../../parsers/manifest/utils/is_segment_still_available.ts","./utils/add_segment_infos":"../../../parsers/manifest/smooth/utils/add_segment_infos.ts","./utils/tokens":"../../../parsers/manifest/smooth/utils/tokens.ts"}],"../../../parsers/manifest/smooth/utils/parseBoolean.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @param {*} parseBoolean
 * @returns {Boolean}
 */

function parseBoolean(val) {
  if (typeof val === "boolean") {
    return val;
  } else if (typeof val === "string") {
    return val.toUpperCase() === "TRUE";
  } else {
    return false;
  }
}

exports.default = parseBoolean;
},{}],"../../../parsers/manifest/smooth/utils/reduceChildren.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Reduce implementation for the children of the given element.
 * @param {Element} root
 * @param {Function} fn
 * @param {*} init
 * @returns {*}
 */

function reduceChildren(root, fn, init) {
  var node = root.firstElementChild;
  var accumulator = init;

  while (node) {
    accumulator = fn(accumulator, node.nodeName, node);
    node = node.nextElementSibling;
  }

  return accumulator;
}

exports.default = reduceChildren;
},{}],"../../../parsers/manifest/smooth/create_parser.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var object_assign_1 = __importDefault(require("object-assign"));

var log_1 = __importDefault(require("../../../log"));

var assert_1 = __importDefault(require("../../../utils/assert"));

var id_generator_1 = __importDefault(require("../../../utils/id_generator"));

var resolve_url_1 = __importStar(require("../../../utils/resolve_url"));

var check_manifest_ids_1 = __importDefault(require("../utils/check_manifest_ids"));

var get_codecs_1 = require("./get_codecs");

var parse_C_nodes_1 = __importDefault(require("./parse_C_nodes"));

var parse_protection_node_1 = __importDefault(require("./parse_protection_node"));

var representation_index_1 = __importDefault(require("./representation_index"));

var parseBoolean_1 = __importDefault(require("./utils/parseBoolean"));

var reduceChildren_1 = __importDefault(require("./utils/reduceChildren"));

var tokens_1 = require("./utils/tokens");
/**
 * Default value for the aggressive `mode`.
 * In this mode, segments will be returned even if we're not sure those had time
 * to be generated.
 */


var DEFAULT_AGGRESSIVE_MODE = false;
var generateManifestID = id_generator_1.default();
var DEFAULT_MIME_TYPES = {
  audio: "audio/mp4",
  video: "video/mp4",
  text: "application/ttml+xml"
};
var DEFAULT_CODECS = {
  audio: "mp4a.40.2",
  video: "avc1.4D401E"
};
var MIME_TYPES = {
  AACL: "audio/mp4",
  AVC1: "video/mp4",
  H264: "video/mp4",
  TTML: "application/ttml+xml+mp4"
};
/**
 * @param {Object|undefined} parserOptions
 * @returns {Function}
 */

function createSmoothStreamingParser() {
  var parserOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var SUGGESTED_PERSENTATION_DELAY = parserOptions.suggestedPresentationDelay;
  var REFERENCE_DATE_TIME = parserOptions.referenceDateTime || Date.UTC(1970, 0, 1, 0, 0, 0, 0) / 1000;
  var MIN_REPRESENTATION_BITRATE = parserOptions.minRepresentationBitrate || 0;
  /**
   * @param {Element} q
   * @param {string} streamType
   * @return {Object}
   */

  function parseQualityLevel(q, streamType) {
    var customAttributes = reduceChildren_1.default(q, function (acc, qName, qNode) {
      if (qName === "CustomAttributes") {
        acc.push.apply(acc, _toConsumableArray(reduceChildren_1.default(qNode, function (cAttrs, cName, cNode) {
          if (cName === "Attribute") {
            var name = cNode.getAttribute("Name");
            var value = cNode.getAttribute("Value");

            if (name !== null && value !== null) {
              cAttrs.push(name + "=" + value);
            }
          }

          return cAttrs;
        }, [])));
      }

      return acc;
    }, []);
    /**
     * @param {string} name
     * @returns {string|undefined}
     */

    function getAttribute(name) {
      var attr = q.getAttribute(name);
      return attr == null ? undefined : attr;
    }

    switch (streamType) {
      case "audio":
        {
          var audiotag = getAttribute("AudioTag");
          var bitrate = getAttribute("Bitrate");
          var bitsPerSample = getAttribute("BitsPerSample");
          var channels = getAttribute("Channels");
          var codecPrivateData = getAttribute("CodecPrivateData");
          var fourCC = getAttribute("FourCC");
          var packetSize = getAttribute("PacketSize");
          var samplingRate = getAttribute("SamplingRate");
          return {
            audiotag: audiotag !== undefined ? parseInt(audiotag, 10) : audiotag,
            bitrate: bitrate ? parseInt(bitrate, 10) || 0 : 0,
            bitsPerSample: bitsPerSample !== undefined ? parseInt(bitsPerSample, 10) : bitsPerSample,
            channels: channels !== undefined ? parseInt(channels, 10) : channels,
            codecPrivateData: codecPrivateData || "",
            customAttributes: customAttributes,
            mimeType: fourCC !== undefined ? MIME_TYPES[fourCC] : fourCC,
            packetSize: packetSize !== undefined ? parseInt(packetSize, 10) : packetSize,
            samplingRate: samplingRate !== undefined ? parseInt(samplingRate, 10) : samplingRate
          };
        }

      case "video":
        {
          var _bitrate = getAttribute("Bitrate");

          var _codecPrivateData = getAttribute("CodecPrivateData");

          var _fourCC = getAttribute("FourCC");

          var width = getAttribute("MaxWidth");
          var height = getAttribute("MaxHeight");
          return {
            bitrate: _bitrate ? parseInt(_bitrate, 10) || 0 : 0,
            customAttributes: customAttributes,
            mimeType: _fourCC !== undefined ? MIME_TYPES[_fourCC] : _fourCC,
            codecPrivateData: _codecPrivateData || "",
            codecs: get_codecs_1.getVideoCodecs(_codecPrivateData || ""),
            width: width !== undefined ? parseInt(width, 10) : undefined,
            height: height !== undefined ? parseInt(height, 10) : undefined
          };
        }

      case "text":
        {
          var _bitrate2 = getAttribute("Bitrate");

          var _codecPrivateData2 = getAttribute("CodecPrivateData");

          var _fourCC2 = getAttribute("FourCC");

          return {
            bitrate: _bitrate2 ? parseInt(_bitrate2, 10) || 0 : 0,
            customAttributes: customAttributes,
            mimeType: _fourCC2 !== undefined ? MIME_TYPES[_fourCC2] : _fourCC2,
            codecPrivateData: _codecPrivateData2 || ""
          };
        }

      default:
        log_1.default.error("Smooth Parser: Unrecognized StreamIndex type: " + streamType);
        return null;
    }
  }
  /**
   * Parse the adaptations (<StreamIndex>) tree containing
   * representations (<QualityLevels>) and timestamp indexes (<c>).
   * Indexes can be quite huge, and this function needs to
   * to be optimized.
   * @param {Object} args
   * @returns {Object}
   */


  function parseAdaptation(args) {
    var root = args.root,
        timescale = args.timescale,
        rootURL = args.rootURL,
        protections = args.protections,
        timeShiftBufferDepth = args.timeShiftBufferDepth,
        manifestReceivedTime = args.manifestReceivedTime,
        isLive = args.isLive;

    var _timescale = root.hasAttribute("Timescale") ? +(root.getAttribute("Timescale") || 0) : timescale;

    var adaptationType = root.getAttribute("Type");

    if (adaptationType == null) {
      throw new Error("StreamIndex without type.");
    }

    var subType = root.getAttribute("Subtype");
    var language = root.getAttribute("Language");
    var baseURL = root.getAttribute("Url") || "";

    if (__DEV__) {
      assert_1.default(baseURL !== "");
    }

    var _reduceChildren_1$def = reduceChildren_1.default(root, function (res, _name, node) {
      switch (_name) {
        case "QualityLevel":
          var qualityLevel = parseQualityLevel(node, adaptationType);

          if (qualityLevel === null) {
            return res;
          }

          if (adaptationType === "audio") {
            var fourCC = node.getAttribute("FourCC") || "";
            qualityLevel.codecs = get_codecs_1.getAudioCodecs(fourCC, qualityLevel.codecPrivateData);
          } // filter out video qualityLevels with small bitrates


          if (adaptationType !== "video" || qualityLevel.bitrate > MIN_REPRESENTATION_BITRATE) {
            res.qualityLevels.push(qualityLevel);
          }

          break;

        case "c":
          res.cNodes.push(node);
          break;
      }

      return res;
    }, {
      qualityLevels: [],
      cNodes: []
    }),
        qualityLevels = _reduceChildren_1$def.qualityLevels,
        cNodes = _reduceChildren_1$def.cNodes;

    var index = {
      timeline: parse_C_nodes_1.default(cNodes),
      timescale: _timescale
    }; // we assume that all qualityLevels have the same
    // codec and mimeType

    assert_1.default(qualityLevels.length !== 0, "adaptation should have at least one representation");
    var adaptationID = adaptationType + (language ? "_" + language : "");
    var representations = qualityLevels.map(function (qualityLevel) {
      var path = resolve_url_1.default(rootURL, baseURL);
      var repIndex = {
        timeline: index.timeline,
        timescale: index.timescale,
        media: tokens_1.replaceRepresentationSmoothTokens(path, qualityLevel.bitrate, qualityLevel.customAttributes),
        isLive: isLive,
        timeShiftBufferDepth: timeShiftBufferDepth,
        manifestReceivedTime: manifestReceivedTime
      };
      var mimeType = qualityLevel.mimeType || DEFAULT_MIME_TYPES[adaptationType];
      var codecs = qualityLevel.codecs || DEFAULT_CODECS[adaptationType];
      var id = adaptationID + "_" + adaptationType + "-" + mimeType + "-" + codecs + "-" + qualityLevel.bitrate;
      var contentProtections = [];
      var firstProtection;

      if (protections.length) {
        firstProtection = protections[0];
        protections.forEach(function (protection) {
          var keyId = protection.keyId;
          protection.keySystems.forEach(function (keySystem) {
            contentProtections.push({
              keyId: keyId,
              systemId: keySystem.systemId
            });
          });
        });
      }

      var segmentPrivateInfos = {
        bitsPerSample: qualityLevel.bitsPerSample,
        channels: qualityLevel.channels,
        codecPrivateData: qualityLevel.codecPrivateData || "",
        packetSize: qualityLevel.packetSize,
        samplingRate: qualityLevel.samplingRate,
        // TODO set multiple protections here instead of the first one
        protection: firstProtection != null ? {
          keyId: firstProtection.keyId,
          keySystems: firstProtection.keySystems
        } : undefined
      };
      var representation = object_assign_1.default({}, qualityLevel, {
        index: new representation_index_1.default(repIndex, {
          aggressiveMode: parserOptions.aggressiveMode == null ? DEFAULT_AGGRESSIVE_MODE : parserOptions.aggressiveMode,
          isLive: isLive,
          segmentPrivateInfos: segmentPrivateInfos
        }),
        mimeType: mimeType,
        codecs: codecs,
        id: id
      });

      if (contentProtections.length) {
        representation.contentProtections = contentProtections;
      }

      return representation;
    }); // TODO(pierre): real ad-insert support

    if (subType === "ADVT") {
      return null;
    }

    var parsedAdaptation = {
      id: adaptationID,
      type: adaptationType,
      representations: representations,
      language: language == null ? undefined : language
    };

    if (adaptationType === "text" && subType === "DESC") {
      parsedAdaptation.closedCaption = true;
    }

    return parsedAdaptation;
  }

  function parseFromDocument(doc, url, manifestReceivedTime) {
    var rootURL = resolve_url_1.normalizeBaseURL(url == null ? "" : url);
    var root = doc.documentElement;

    if (!root || root.nodeName !== "SmoothStreamingMedia") {
      throw new Error("document root should be SmoothStreamingMedia");
    }

    if (!/^[2]-[0-2]$/.test(root.getAttribute("MajorVersion") + "-" + root.getAttribute("MinorVersion"))) {
      throw new Error("Version should be 2.0, 2.1 or 2.2");
    }

    var timescale = +(root.getAttribute("Timescale") || 10000000);

    var _reduceChildren_1$def2 = reduceChildren_1.default(root, function (res, name, node) {
      switch (name) {
        case "Protection":
          {
            res.protections.push(parse_protection_node_1.default(node, parserOptions.keySystems));
            break;
          }

        case "StreamIndex":
          res.adaptationNodes.push(node);
          break;
      }

      return res;
    }, {
      adaptationNodes: [],
      protections: []
    }),
        protections = _reduceChildren_1$def2.protections,
        adaptationNodes = _reduceChildren_1$def2.adaptationNodes;

    var initialAdaptations = {};
    var isLive = parseBoolean_1.default(root.getAttribute("IsLive"));
    var timeShiftBufferDepth;

    if (isLive) {
      var dvrWindowLength = root.getAttribute("DVRWindowLength");

      if (dvrWindowLength != null && !isNaN(+dvrWindowLength) && +dvrWindowLength !== 0) {
        timeShiftBufferDepth = +dvrWindowLength / timescale;
      }
    }

    var adaptations = adaptationNodes.map(function (node) {
      return parseAdaptation({
        root: node,
        rootURL: rootURL,
        timescale: timescale,
        protections: protections,
        isLive: isLive,
        timeShiftBufferDepth: timeShiftBufferDepth,
        manifestReceivedTime: manifestReceivedTime
      });
    }).filter(function (adaptation) {
      return adaptation != null;
    }).reduce(function (acc, adaptation) {
      var type = adaptation.type;

      if (acc[type] === undefined) {
        acc[type] = [adaptation];
      } else {
        (acc[type] || []).push(adaptation);
      }

      return acc;
    }, initialAdaptations);
    var suggestedPresentationDelay;
    var availabilityStartTime;
    var minimumTime;
    var maximumTime;
    var firstVideoAdaptation = adaptations.video ? adaptations.video[0] : undefined;
    var firstAudioAdaptation = adaptations.audio ? adaptations.audio[0] : undefined;
    var firstTimeReference;
    var lastTimeReference;

    if (firstVideoAdaptation || firstAudioAdaptation) {
      var firstTimeReferences = [];
      var lastTimeReferences = [];

      if (firstVideoAdaptation) {
        var firstVideoRepresentation = firstVideoAdaptation.representations[0];

        if (firstVideoRepresentation) {
          var firstVideoTimeReference = firstVideoRepresentation.index.getFirstPosition();
          var lastVideoTimeReference = firstVideoRepresentation.index.getLastPosition();

          if (firstVideoTimeReference != null) {
            firstTimeReferences.push(firstVideoTimeReference);
          }

          if (lastVideoTimeReference != null) {
            lastTimeReferences.push(lastVideoTimeReference);
          }
        }
      }

      if (firstAudioAdaptation) {
        var firstAudioRepresentation = firstAudioAdaptation.representations[0];

        if (firstAudioRepresentation) {
          var firstAudioTimeReference = firstAudioRepresentation.index.getFirstPosition();
          var lastAudioTimeReference = firstAudioRepresentation.index.getLastPosition();

          if (firstAudioTimeReference != null) {
            firstTimeReferences.push(firstAudioTimeReference);
          }

          if (lastAudioTimeReference != null) {
            lastTimeReferences.push(lastAudioTimeReference);
          }
        }
      }

      if (firstTimeReferences.length) {
        firstTimeReference = Math.max.apply(Math, firstTimeReferences);
      }

      if (lastTimeReferences.length) {
        lastTimeReference = Math.min.apply(Math, lastTimeReferences);
      }
    }

    var periodStart;
    var duration;

    if (isLive) {
      periodStart = 0;
      suggestedPresentationDelay = SUGGESTED_PERSENTATION_DELAY;
      availabilityStartTime = REFERENCE_DATE_TIME;
      var time = performance.now();
      maximumTime = {
        isContinuous: true,
        value: lastTimeReference != null ? lastTimeReference : Date.now() / 1000 - availabilityStartTime,
        time: time
      };

      if (timeShiftBufferDepth == null) {
        // infinite buffer
        minimumTime = {
          isContinuous: false,
          value: firstTimeReference != null ? firstTimeReference : availabilityStartTime,
          time: time
        };
      } else {
        minimumTime = {
          isContinuous: true,
          value: Math.min(maximumTime.value - timeShiftBufferDepth + 5, maximumTime.value),
          time: time
        };
      }

      var manifestDuration = root.getAttribute("Duration");
      duration = manifestDuration != null && +manifestDuration !== 0 ? +manifestDuration / timescale : undefined;
    } else {
      periodStart = firstTimeReference != null ? firstTimeReference : 0;
      minimumTime = {
        isContinuous: false,
        value: firstTimeReference != null ? firstTimeReference : 0,
        time: performance.now()
      }; // if non-live and first time reference different than 0. Add first time reference
      // to duration

      var _manifestDuration = root.getAttribute("Duration");

      if (_manifestDuration != null && +_manifestDuration !== 0) {
        duration = lastTimeReference == null ? +_manifestDuration / timescale + (firstTimeReference || 0) : lastTimeReference;
      } else {
        duration = undefined;
      }
    }

    var periodDuration = duration != null ? duration - periodStart : undefined;
    var manifest = {
      availabilityStartTime: availabilityStartTime || 0,
      duration: duration,
      id: "gen-smooth-manifest-" + generateManifestID(),
      isLive: isLive,
      isDynamic: isLive,
      maximumTime: maximumTime,
      minimumTime: minimumTime,
      periods: [{
        adaptations: adaptations,
        duration: periodDuration,
        end: periodDuration == null ? undefined : periodStart + periodDuration,
        id: "gen-smooth-period-0",
        start: periodStart
      }],
      suggestedPresentationDelay: suggestedPresentationDelay,
      transportType: "smooth",
      uris: url == null ? [] : [url]
    };
    check_manifest_ids_1.default(manifest);
    return manifest;
  }

  return parseFromDocument;
}

exports.default = createSmoothStreamingParser;
},{"object-assign":"../../../../node_modules/object-assign/index.js","../../../log":"../../../log.ts","../../../utils/assert":"../../../utils/assert.ts","../../../utils/id_generator":"../../../utils/id_generator.ts","../../../utils/resolve_url":"../../../utils/resolve_url.ts","../utils/check_manifest_ids":"../../../parsers/manifest/utils/check_manifest_ids.ts","./get_codecs":"../../../parsers/manifest/smooth/get_codecs.ts","./parse_C_nodes":"../../../parsers/manifest/smooth/parse_C_nodes.ts","./parse_protection_node":"../../../parsers/manifest/smooth/parse_protection_node.ts","./representation_index":"../../../parsers/manifest/smooth/representation_index.ts","./utils/parseBoolean":"../../../parsers/manifest/smooth/utils/parseBoolean.ts","./utils/reduceChildren":"../../../parsers/manifest/smooth/utils/reduceChildren.ts","./utils/tokens":"../../../parsers/manifest/smooth/utils/tokens.ts"}],"../../../parsers/manifest/smooth/index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var create_parser_1 = __importStar(require("./create_parser"));

exports.IHSSParserConfiguration = create_parser_1.IHSSParserConfiguration;
exports.default = create_parser_1.default;
},{"./create_parser":"../../../parsers/manifest/smooth/create_parser.ts"}],"../../../transports/smooth/isobmff/create_boxes.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var isobmff_1 = require("../../../parsers/containers/isobmff");

var byte_parsing_1 = require("../../../utils/byte_parsing");
/**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes - horizontal resolution, eg 72
 * @param {Number} vRes - vertical resolution, eg 72
 * @param {string} encDepth
 * @param {Number} colorDepth - eg 24
 * @param {Uint8Array} avcc - Uint8Array representing the avcC atom
 * @returns {Uint8Array}
 */


function createAVC1Box(width, height, hRes, vRes, encName, colorDepth, avcc) {
  return isobmff_1.createBox("avc1", byte_parsing_1.concat(6, // 6 bytes reserved
  byte_parsing_1.itobe2(1), 16, // drefIdx + QuickTime reserved, zeroes
  byte_parsing_1.itobe2(width), // size 2 w
  byte_parsing_1.itobe2(height), // size 2 h
  byte_parsing_1.itobe2(hRes), 2, // reso 4 h
  byte_parsing_1.itobe2(vRes), 2 + 4, // reso 4 v + QuickTime reserved, zeroes
  [0, 1, encName.length], // frame count (default 1)
  byte_parsing_1.strToBytes(encName), // 1byte len + encoder name str
  31 - encName.length, // + padding
  byte_parsing_1.itobe2(colorDepth), // color depth
  [0xFF, 0xFF], // reserved ones
  avcc // avcc atom,
  ));
}

exports.createAVC1Box = createAVC1Box;
/**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes - horizontal resolution, eg 72
 * @param {Number} vRes - vertical resolution, eg 72
 * @param {string} encDepth
 * @param {Number} colorDepth - eg 24
 * @param {Uint8Array} avcc - Uint8Array representing the avcC atom
 * @param {Uint8Array} sinf - Uint8Array representing the sinf atom
 * @returns {Uint8Array}
 */

function createENCVBox(width, height, hRes, vRes, encName, colorDepth, avcc, sinf) {
  return isobmff_1.createBox("encv", byte_parsing_1.concat(6, // 6 bytes reserved
  byte_parsing_1.itobe2(1), 16, // drefIdx + QuickTime reserved, zeroes
  byte_parsing_1.itobe2(width), // size 2 w
  byte_parsing_1.itobe2(height), // size 2 h
  byte_parsing_1.itobe2(hRes), 2, // reso 4 h
  byte_parsing_1.itobe2(vRes), 2 + 4, // reso 4 v + QuickTime reserved, zeroes
  [0, 1, encName.length], // frame count (default 1)
  byte_parsing_1.strToBytes(encName), // 1byte len + encoder name str
  31 - encName.length, // + padding
  byte_parsing_1.itobe2(colorDepth), // color depth
  [0xFF, 0xFF], // reserved ones
  avcc, // avcc atom,
  sinf));
}

exports.createENCVBox = createENCVBox;
/**
 * @param {Number} drefIdx
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {Uint8Array} esds - Uint8Array representing the esds atom
 * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
 * only if name == "enca"
 * @returns {Uint8Array}
 */

function createMP4ABox(drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds) {
  return isobmff_1.createBox("mp4a", byte_parsing_1.concat(6, byte_parsing_1.itobe2(drefIdx), 8, byte_parsing_1.itobe2(channelsCount), byte_parsing_1.itobe2(sampleSize), 2, byte_parsing_1.itobe2(packetSize), byte_parsing_1.itobe2(sampleRate), 2, esds));
}

exports.createMP4ABox = createMP4ABox;
/**
 * @param {Number} drefIdx
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {Uint8Array} esds - Uint8Array representing the esds atom
 * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
 * only if name == "enca"
 * @returns {Uint8Array}
 */

function createENCABox(drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf) {
  return isobmff_1.createBox("enca", byte_parsing_1.concat(6, byte_parsing_1.itobe2(drefIdx), 8, byte_parsing_1.itobe2(channelsCount), byte_parsing_1.itobe2(sampleSize), 2, byte_parsing_1.itobe2(packetSize), byte_parsing_1.itobe2(sampleRate), 2, esds, sinf));
}

exports.createENCABox = createENCABox;
/**
 * @param {url} Uint8Array
 * @returns {Uint8Array}
 */

function createDREFBox(url) {
  // only one description here... FIXME
  return isobmff_1.createBox("dref", byte_parsing_1.concat(7, [1], url));
}

exports.createDREFBox = createDREFBox;
/**
 * @param {string} majorBrand
 * @param {Array.<string>} brands
 * @returns {Uint8Array}
 */

function createFTYPBox(majorBrand, brands) {
  return isobmff_1.createBox("ftyp", byte_parsing_1.concat.apply(null, [byte_parsing_1.strToBytes(majorBrand), [0, 0, 0, 1]].concat(brands.map(byte_parsing_1.strToBytes))));
}

exports.createFTYPBox = createFTYPBox;
/**
 * @param {string} schemeType - four letters (eg "cenc" for Common Encryption)
 * @param {Number} schemeVersion - eg 65536
 * @returns {Uint8Array}
 */

function createSCHMBox(schemeType, schemeVersion) {
  return isobmff_1.createBox("schm", byte_parsing_1.concat(4, byte_parsing_1.strToBytes(schemeType), byte_parsing_1.itobe4(schemeVersion)));
}

exports.createSCHMBox = createSCHMBox;
/**
 * Create tfdt box from a decoding time.
 * @param {number} decodeTime
 * @returns {Uint8Array}
 */

function createTfdtBox(decodeTime) {
  return isobmff_1.createBox("tfdt", byte_parsing_1.concat([1, 0, 0, 0], byte_parsing_1.itobe8(decodeTime)));
}

exports.createTfdtBox = createTfdtBox;
/**
 * @returns {Uint8Array}
 */

function createVMHDBox() {
  var arr = new Uint8Array(12);
  arr[3] = 1; // QuickTime...

  return isobmff_1.createBox("vmhd", arr);
}

exports.createVMHDBox = createVMHDBox;
/**
 * @param {Number} trackId
 * @returns {Uint8Array}
 */

function createTREXBox(trackId) {
  // default sample desc idx = 1
  return isobmff_1.createBox("trex", byte_parsing_1.concat(4, byte_parsing_1.itobe4(trackId), [0, 0, 0, 1], 12));
}

exports.createTREXBox = createTREXBox;
/**
 * @param {Number} length
 * @returns {Uint8Array}
 */

function createFreeBox(length) {
  return isobmff_1.createBox("free", new Uint8Array(length - 8));
}

exports.createFreeBox = createFreeBox;
/**
 * @param {Number} stream
 * @param {string} codecPrivateData - hex string
 * @returns {Uint8Array}
 */

function createESDSBox(stream, codecPrivateData) {
  return isobmff_1.createBox("esds", byte_parsing_1.concat(4, [0x03, 0x19], byte_parsing_1.itobe2(stream), [0x00, 0x04, 0x11, 0x40, 0x15], 11, [0x05, 0x02], byte_parsing_1.hexToBytes(codecPrivateData), [0x06, 0x01, 0x02]));
}

exports.createESDSBox = createESDSBox;
/**
 * @param {string} dataFormat - four letters (eg "avc1")
 * @returns {Uint8Array}
 */

function createFRMABox(dataFormat) {
  return isobmff_1.createBox("frma", byte_parsing_1.strToBytes(dataFormat));
}

exports.createFRMABox = createFRMABox;
/**
 * @param {Uint8Array} sps
 * @param {Uint8Array} pps
 * @param {Number} nalLen - NAL Unit length: 1, 2 or 4 bytes
 * eg: avcc(0x4d, 0x40, 0x0d, 4, 0xe1, "674d400d96560c0efcb80a70505050a0",
 * 1, "68ef3880")
 * @returns {Uint8Array}
 */

function createAVCCBox(sps, pps, nalLen) {
  var nal = nalLen === 2 ? 0x1 : nalLen === 4 ? 0x3 : 0x0; // Deduce AVC Profile from SPS

  var h264Profile = sps[1];
  var h264CompatibleProfile = sps[2];
  var h264Level = sps[3];
  return isobmff_1.createBox("avcC", byte_parsing_1.concat([1, h264Profile, h264CompatibleProfile, h264Level, 0x3F << 2 | nal, 0xE0 | 1], byte_parsing_1.itobe2(sps.length), sps, [1], byte_parsing_1.itobe2(pps.length), pps));
}

exports.createAVCCBox = createAVCCBox;
/**
 * @param {string} type - "video"/"audio"/"hint"
 * @returns {Uint8Array}
 */

function createHDLRBox(type) {
  var name;
  var handlerName;

  switch (type) {
    case "video":
      name = "vide";
      handlerName = "VideoHandler";
      break;

    case "audio":
      name = "soun";
      handlerName = "SoundHandler";
      break;

    default:
      name = "hint";
      handlerName = "";
      break;
  }

  return isobmff_1.createBox("hdlr", byte_parsing_1.concat(8, byte_parsing_1.strToBytes(name), 12, byte_parsing_1.strToBytes(handlerName), 1 // handler name is C-style string (0 terminated)
  ));
}

exports.createHDLRBox = createHDLRBox;
/**
 * @param {number} timescale
 * @returns {Uint8Array}
 */

function createMDHDBox(timescale) {
  return isobmff_1.createBox("mdhd", byte_parsing_1.concat(12, byte_parsing_1.itobe4(timescale), 8));
}

exports.createMDHDBox = createMDHDBox;
/**
 * @param {Number} timescale
 * @param {Number} trackId
 * @returns {Uint8Array}
 */

function createMVHDBox(timescale, trackId) {
  return isobmff_1.createBox("mvhd", byte_parsing_1.concat(12, byte_parsing_1.itobe4(timescale), 4, [0, 1], 2, // we assume rate = 1;
  [1, 0], 10, // we assume volume = 100%;
  [0, 1], 14, // default matrix
  [0, 1], 14, // default matrix
  [64, 0, 0, 0], 26, byte_parsing_1.itobe2(trackId + 1) // next trackId (=trackId + 1);
  ));
}

exports.createMVHDBox = createMVHDBox;
/**
 * @param {string} systemId - Hex string representing the CDM, 16 bytes.
 * @param {Uint8Array|undefined} privateData - Data associated to protection
 * specific system.
 * @param {Array.<Uint8Array>} keyIds - List of key ids contained in the PSSH
 * @returns {Uint8Array}
 */

function createPSSHBox(systemId) {
  var privateData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Uint8Array(0);
  var keyIds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Uint8Array(0);

  var _systemId = systemId.replace(/-/g, "");

  if (_systemId.length !== 32) {
    throw new Error("HSS: wrong system id length");
  }

  var version;
  var kidList;
  var kidCount = keyIds.length;

  if (kidCount > 0) {
    version = 1;
    kidList = byte_parsing_1.concat.apply(byte_parsing_1, _toConsumableArray([byte_parsing_1.itobe4(kidCount)].concat(keyIds)));
  } else {
    version = 0;
    kidList = [];
  }

  return isobmff_1.createBox("pssh", byte_parsing_1.concat([version, 0, 0, 0], byte_parsing_1.hexToBytes(_systemId), kidList, byte_parsing_1.itobe4(privateData.length), privateData));
}

exports.createPSSHBox = createPSSHBox;
/**
 * @param {Uint8Array} mfhd
 * @param {Uint8Array} tfhd
 * @param {Uint8Array} tfdt
 * @param {Uint8Array} trun
 * @returns {Uint8Array}
 */

function createSAIOBox(mfhd, tfhd, tfdt, trun) {
  return isobmff_1.createBox("saio", byte_parsing_1.concat(4, [0, 0, 0, 1], // ??
  byte_parsing_1.itobe4(mfhd.length + tfhd.length + tfdt.length + trun.length + 8 + 8 + 8 + 8)));
}

exports.createSAIOBox = createSAIOBox;
/**
 * @param {Uint8Array} sencContent - including 8 bytes flags and entries count
 * @returns {Uint8Array}
 */

function createSAIZBox(sencContent) {
  if (sencContent.length === 0) {
    return isobmff_1.createBox("saiz", new Uint8Array(0));
  }

  var flags = byte_parsing_1.be4toi(sencContent, 0);
  var entries = byte_parsing_1.be4toi(sencContent, 4);
  var arr = new Uint8Array(entries + 9);
  arr.set(byte_parsing_1.itobe4(entries), 5);
  var i = 9;
  var j = 8;
  var pairsCnt;
  var pairsLen;

  while (j < sencContent.length) {
    j += 8; // assuming IV is 8 bytes TODO handle 16 bytes IV
    // if we have extradata for each entry

    if ((flags & 0x2) === 0x2) {
      pairsLen = 2;
      pairsCnt = byte_parsing_1.be2toi(sencContent, j);
      j += pairsCnt * 6 + 2;
    } else {
      pairsCnt = 0;
      pairsLen = 0;
    }

    arr[i] = pairsCnt * 6 + 8 + pairsLen;
    i++;
  }

  return isobmff_1.createBox("saiz", arr);
}

exports.createSAIZBox = createSAIZBox;
/**
 * @returns {Uint8Array}
 */

function createSMHDBox() {
  return isobmff_1.createBox("smhd", new Uint8Array(8));
}

exports.createSMHDBox = createSMHDBox;
/**
 * @param {Array.<Uint8Array>} representations - arrays of Uint8Array,
 * typically [avc1] or [encv, avc1]
 * @returns {Uint8Array}
 */

function createSTSDBox(reps) {
  // only one description here... FIXME
  var arrBase = [7, [reps.length]];
  return isobmff_1.createBox("stsd", byte_parsing_1.concat.apply(byte_parsing_1, _toConsumableArray(arrBase.concat(reps))));
}

exports.createSTSDBox = createSTSDBox;
/**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} trackId
 * @returns {Uint8Array}
 */

function createTKHDBox(width, height, trackId) {
  return isobmff_1.createBox("tkhd", byte_parsing_1.concat(byte_parsing_1.itobe4(1 + 2 + 4), 8, // we assume track is enabled,
  // in media and in preview.
  byte_parsing_1.itobe4(trackId), 20, // we assume trackId = 1;
  [1, 0, 0, 0], // we assume volume = 100%;
  [0, 1, 0, 0], 12, // default matrix
  [0, 1, 0, 0], 12, // default matrix
  [64, 0, 0, 0], // ??
  byte_parsing_1.itobe2(width), 2, // width (TODO handle fixed)
  byte_parsing_1.itobe2(height), 2 // height (TODO handle fixed)
  ));
}

exports.createTKHDBox = createTKHDBox;
/**
 * @param {Number} algId - eg 1
 * @param {Number} ivSize - eg 8
 * @param {string} keyId - Hex KID 93789920e8d6520098577df8f2dd5546
 * @returns {Uint8Array}
 */

function createTENCBox(algId, ivSize, keyId) {
  return isobmff_1.createBox("tenc", byte_parsing_1.concat(6, [algId, ivSize], keyId));
}

exports.createTENCBox = createTENCBox;
},{"../../../parsers/containers/isobmff":"../../../parsers/containers/isobmff/index.ts","../../../utils/byte_parsing":"../../../utils/byte_parsing.ts"}],"../../../transports/smooth/isobmff/create_init_segment.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var isobmff_1 = require("../../../parsers/containers/isobmff");

var byte_parsing_1 = require("../../../utils/byte_parsing");

var create_boxes_1 = require("./create_boxes");
/**
 * @param {Uint8Array} mvhd
 * @param {Uint8Array} mvex
 * @param {Uint8Array} trak
 * @param {Object} pssList
 * @returns {Array.<Uint8Array>}
 */


function createMOOVBox(mvhd, mvex, trak, pssList) {
  var children = [mvhd, mvex, trak];
  pssList.forEach(function (pss) {
    var pssh = create_boxes_1.createPSSHBox(pss.systemId, pss.privateData, pss.keyIds);
    children.push(pssh);
  });
  return isobmff_1.createBoxWithChildren("moov", children);
}
/**
 * Create an initialization segment with the information given.
 * @param {Number} timescale
 * @param {string} type
 * @param {Uint8Array} stsd
 * @param {Uint8Array} mhd
 * @param {Number} width
 * @param {Number} height
 * @param {Array.<Object>} pssList - List of dict, example:
 * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
 * @returns {Uint8Array}
 */


function createInitSegment(timescale, type, stsd, mhd, width, height, pssList) {
  var stbl = isobmff_1.createBoxWithChildren("stbl", [stsd, isobmff_1.createBox("stts", new Uint8Array(0x08)), isobmff_1.createBox("stsc", new Uint8Array(0x08)), isobmff_1.createBox("stsz", new Uint8Array(0x0c)), isobmff_1.createBox("stco", new Uint8Array(0x08))]);
  var url = isobmff_1.createBox("url ", new Uint8Array([0, 0, 0, 1]));
  var dref = create_boxes_1.createDREFBox(url);
  var dinf = isobmff_1.createBoxWithChildren("dinf", [dref]);
  var minf = isobmff_1.createBoxWithChildren("minf", [mhd, dinf, stbl]);
  var hdlr = create_boxes_1.createHDLRBox(type);
  var mdhd = create_boxes_1.createMDHDBox(timescale); // this one is really important

  var mdia = isobmff_1.createBoxWithChildren("mdia", [mdhd, hdlr, minf]);
  var tkhd = create_boxes_1.createTKHDBox(width, height, 1);
  var trak = isobmff_1.createBoxWithChildren("trak", [tkhd, mdia]);
  var trex = create_boxes_1.createTREXBox(1);
  var mvex = isobmff_1.createBoxWithChildren("mvex", [trex]);
  var mvhd = create_boxes_1.createMVHDBox(timescale, 1); // in fact, we don't give a sh** about
  // this value :O

  var moov = createMOOVBox(mvhd, mvex, trak, pssList);
  var ftyp = create_boxes_1.createFTYPBox("isom", ["isom", "iso2", "iso6", "avc1", "dash"]);
  return byte_parsing_1.concat(ftyp, moov);
}

exports.default = createInitSegment;
},{"../../../parsers/containers/isobmff":"../../../parsers/containers/isobmff/index.ts","../../../utils/byte_parsing":"../../../utils/byte_parsing.ts","./create_boxes":"../../../transports/smooth/isobmff/create_boxes.ts"}],"../../../transports/smooth/isobmff/get_aaces_header.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var byte_parsing_1 = require("../../../utils/byte_parsing");
/**
 * Sampling frequencies defined in MPEG-4 Audio.
 * @type {Array.<Number>}
 */


var SAMPLING_FREQUENCIES = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
/**
 * Return AAC ES Header (hexstr form)
 *
 * @param {Number} type
 *          1 = AAC Main
 *          2 = AAC LC
 *          cf http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio
 * @param {Number} frequency
 * @param {Number} chans (1 or 2)
 * @returns {string}
 */

function getAacesHeader(type, frequency, chans) {
  var freq = SAMPLING_FREQUENCIES.indexOf(frequency); // TODO : handle Idx = 15...

  var val;
  val = (type & 0x3F) << 0x4;
  val = (val | freq & 0x1F) << 0x4;
  val = (val | chans & 0x1F) << 0x3;
  return byte_parsing_1.bytesToHex(byte_parsing_1.itobe2(val));
}

exports.default = getAacesHeader;
},{"../../../utils/byte_parsing":"../../../utils/byte_parsing.ts"}],"../../../transports/smooth/isobmff/create_audio_init_segment.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var isobmff_1 = require("../../../parsers/containers/isobmff");

var create_boxes_1 = require("./create_boxes");

var create_init_segment_1 = __importDefault(require("./create_init_segment"));

var get_aaces_header_1 = __importDefault(require("./get_aaces_header"));
/**
 * Return full audio initialization segment as Uint8Array.
 * @param {Number} timescale
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {string} codecPrivateData
 * @param {Uint8Array} keyId - hex string representing the key Id, 32 chars.
 * eg. a800dbed49c12c4cb8e0b25643844b9b
 * @param {Array.<Object>} [pssList]
 * @returns {Uint8Array}
 */


function createAudioInitSegment(timescale, channelsCount, sampleSize, packetSize, sampleRate, codecPrivateData, keyId) {
  var pssList = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [];

  var _codecPrivateData = codecPrivateData || get_aaces_header_1.default(2, sampleRate, channelsCount);

  var esds = create_boxes_1.createESDSBox(1, _codecPrivateData);

  var stsd = function () {
    if (!pssList.length || keyId == null) {
      var mp4a = create_boxes_1.createMP4ABox(1, channelsCount, sampleSize, packetSize, sampleRate, esds);
      return create_boxes_1.createSTSDBox([mp4a]);
    }

    var tenc = create_boxes_1.createTENCBox(1, 8, keyId);
    var schi = isobmff_1.createBoxWithChildren("schi", [tenc]);
    var schm = create_boxes_1.createSCHMBox("cenc", 65536);
    var frma = create_boxes_1.createFRMABox("mp4a");
    var sinf = isobmff_1.createBoxWithChildren("sinf", [frma, schm, schi]);
    var enca = create_boxes_1.createENCABox(1, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf);
    return create_boxes_1.createSTSDBox([enca]);
  }();

  return create_init_segment_1.default(timescale, "audio", stsd, create_boxes_1.createSMHDBox(), 0, 0, pssList);
}

exports.default = createAudioInitSegment;
},{"../../../parsers/containers/isobmff":"../../../parsers/containers/isobmff/index.ts","./create_boxes":"../../../transports/smooth/isobmff/create_boxes.ts","./create_init_segment":"../../../transports/smooth/isobmff/create_init_segment.ts","./get_aaces_header":"../../../transports/smooth/isobmff/get_aaces_header.ts"}],"../../../transports/smooth/isobmff/create_video_init_segment.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var isobmff_1 = require("../../../parsers/containers/isobmff");

var byte_parsing_1 = require("../../../utils/byte_parsing");

var create_boxes_1 = require("./create_boxes");

var create_init_segment_1 = __importDefault(require("./create_init_segment"));
/**
 * Return full video Init segment as Uint8Array
 * @param {Number} timescale - lowest number, this one will be set into mdhd
 * *10000 in mvhd, e.g. 1000
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes
 * @param {Number} vRes
 * @param {Number} nalLength (1, 2 or 4)
 * @param {string} codecPrivateData
 * @param {Uint8Array} keyId - hex string representing the key Id,
 * 32 chars. eg. a800dbed49c12c4cb8e0b25643844b9b
 * @param {Array.<Object>} [pssList] - List of dict, example:
 * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
 * @returns {Uint8Array}
 */


function createVideoInitSegment(timescale, width, height, hRes, vRes, nalLength, codecPrivateData, keyId, pssList) {
  var _pssList = pssList || [];

  var _codecPrivateData$spl = codecPrivateData.split("00000001"),
      _codecPrivateData$spl2 = _slicedToArray(_codecPrivateData$spl, 3),
      spsHex = _codecPrivateData$spl2[1],
      ppsHex = _codecPrivateData$spl2[2];

  var sps = byte_parsing_1.hexToBytes(spsHex);
  var pps = byte_parsing_1.hexToBytes(ppsHex); // TODO NAL length is forced to 4

  var avcc = create_boxes_1.createAVCCBox(sps, pps, nalLength);
  var stsd;

  if (!_pssList.length || keyId == null) {
    var avc1 = create_boxes_1.createAVC1Box(width, height, hRes, vRes, "AVC Coding", 24, avcc);
    stsd = create_boxes_1.createSTSDBox([avc1]);
  } else {
    var tenc = create_boxes_1.createTENCBox(1, 8, keyId);
    var schi = isobmff_1.createBoxWithChildren("schi", [tenc]);
    var schm = create_boxes_1.createSCHMBox("cenc", 65536);
    var frma = create_boxes_1.createFRMABox("avc1");
    var sinf = isobmff_1.createBoxWithChildren("sinf", [frma, schm, schi]);
    var encv = create_boxes_1.createENCVBox(width, height, hRes, vRes, "AVC Coding", 24, avcc, sinf);
    stsd = create_boxes_1.createSTSDBox([encv]);
  }

  return create_init_segment_1.default(timescale, "video", stsd, create_boxes_1.createVMHDBox(), width, height, _pssList);
}

exports.default = createVideoInitSegment;
},{"../../../parsers/containers/isobmff":"../../../parsers/containers/isobmff/index.ts","../../../utils/byte_parsing":"../../../utils/byte_parsing.ts","./create_boxes":"../../../transports/smooth/isobmff/create_boxes.ts","./create_init_segment":"../../../transports/smooth/isobmff/create_init_segment.ts"}],"../../../transports/smooth/isobmff/parse_tfrf.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var isobmff_1 = require("../../../parsers/containers/isobmff");

var byte_parsing_1 = require("../../../utils/byte_parsing");
/**
 * @param {Uint8Array} traf
 * @returns {Array.<Object>}
 */


function parseTfrf(traf) {
  var tfrf = isobmff_1.getUuidContent(traf, 0xD4807EF2, 0XCA394695, 0X8E5426CB, 0X9E46A79F);

  if (!tfrf) {
    return [];
  }

  var frags = [];
  var version = tfrf[0];
  var fragCount = tfrf[4];

  for (var i = 0; i < fragCount; i++) {
    var duration = void 0;
    var time = void 0;

    if (version === 1) {
      time = byte_parsing_1.be8toi(tfrf, i * 16 + 5);
      duration = byte_parsing_1.be8toi(tfrf, i * 16 + 5 + 8);
    } else {
      time = byte_parsing_1.be4toi(tfrf, i * 8 + 5);
      duration = byte_parsing_1.be4toi(tfrf, i * 8 + 5 + 4);
    }

    frags.push({
      time: time,
      duration: duration
    });
  }

  return frags;
}

exports.default = parseTfrf;
},{"../../../parsers/containers/isobmff":"../../../parsers/containers/isobmff/index.ts","../../../utils/byte_parsing":"../../../utils/byte_parsing.ts"}],"../../../transports/smooth/isobmff/parse_tfxd.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var isobmff_1 = require("../../../parsers/containers/isobmff");

var byte_parsing_1 = require("../../../utils/byte_parsing");
/**
 * @param {Uint8Array} traf
 * @returns {Object|undefined}
 */


function parseTfxd(traf) {
  var tfxd = isobmff_1.getUuidContent(traf, 0x6D1D9B05, 0x42D544E6, 0x80E2141D, 0xAFF757B2);

  if (tfxd == null) {
    return undefined;
  }

  return {
    duration: byte_parsing_1.be8toi(tfxd, 12),
    time: byte_parsing_1.be8toi(tfxd, 4)
  };
}

exports.default = parseTfxd;
},{"../../../parsers/containers/isobmff":"../../../parsers/containers/isobmff/index.ts","../../../utils/byte_parsing":"../../../utils/byte_parsing.ts"}],"../../../transports/smooth/isobmff/add_data_offset_flag_in_trun.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var byte_parsing_1 = require("../../../utils/byte_parsing");
/**
 * Update `trun` box given to add a data offset flag and the corresponding space
 * to set a data offset.
 * Do not do anything if the flag is already set.
 * @param {Uint8Array} trun
 * @returns {Uint8Array}
 */


function addDataOffsetFlagInTrun(trun) {
  var lastFlags = trun[11];
  var hasDataOffset = lastFlags & 0x01;

  if (hasDataOffset) {
    return trun;
  } // If no dataoffset is present, we add one


  var newTrun = new Uint8Array(trun.length + 4);
  newTrun.set(byte_parsing_1.itobe4(trun.length + 4), 0); // original length + data_offset size

  newTrun.set(trun.subarray(4, 16), 4); // name + (version + flags) + samplecount

  newTrun[11] = newTrun[11] | 0x01; // add data_offset flag

  newTrun.set([0, 0, 0, 0], 16); // add data offset

  newTrun.set(trun.subarray(16, trun.length), 20);
  return newTrun;
}

exports.default = addDataOffsetFlagInTrun;
},{"../../../utils/byte_parsing":"../../../utils/byte_parsing.ts"}],"../../../transports/smooth/isobmff/create_traf_box.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var isobmff_1 = require("../../../parsers/containers/isobmff");

var create_boxes_1 = require("./create_boxes");

function createTrafBox(tfhd, tfdt, trun, mfhd, senc) {
  var trafs = [tfhd, tfdt, trun];

  if (senc) {
    trafs.push(isobmff_1.createBox("senc", senc), create_boxes_1.createSAIZBox(senc), create_boxes_1.createSAIOBox(mfhd, tfhd, tfdt, trun));
  }

  return isobmff_1.createBoxWithChildren("traf", trafs);
}

exports.default = createTrafBox;
},{"../../../parsers/containers/isobmff":"../../../parsers/containers/isobmff/index.ts","./create_boxes":"../../../transports/smooth/isobmff/create_boxes.ts"}],"../../../transports/smooth/isobmff/replace_moof.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var compat_1 = require("../../../compat");

var isobmff_1 = require("../../../parsers/containers/isobmff");

var byte_parsing_1 = require("../../../utils/byte_parsing");

var create_boxes_1 = require("./create_boxes");
/**
 * Replace a moof in a segment by a new one.
 * @param {Uint8Array} segment
 * @param {Uint8Array} newMoof
 * @param {Array.<number>} moofOffsets
 * @param {number} trunOffsetInMoof
 * @returns {Uint8Array}
 */


function replaceMoofInSegment(segment, newMoof, moofOffsets, trunOffsetInMoof) {
  var oldMoofLength = moofOffsets[1] - moofOffsets[0];
  var moofDelta = newMoof.length - oldMoofLength;
  var mdatOffsets = isobmff_1.getBoxOffsets(segment, 0x6D646174
  /* "mdat" */
  );

  if (mdatOffsets == null) {
    throw new Error("Smooth: Invalid ISOBMFF given");
  }

  if (compat_1.canPatchISOBMFFSegment() && (moofDelta === 0 || moofDelta <= -8)) {
    // patch trun data_offset
    newMoof.set(byte_parsing_1.itobe4(mdatOffsets[0] + 8), trunOffsetInMoof + 16);
    segment.set(newMoof, moofOffsets[0]);

    if (moofDelta <= -8) {
      segment.set(create_boxes_1.createFreeBox(-moofDelta), newMoof.length);
    }

    return segment;
  } // patch trun data_offset


  newMoof.set(byte_parsing_1.itobe4(mdatOffsets[0] + moofDelta + 8), trunOffsetInMoof + 16);
  var newSegment = new Uint8Array(segment.length + moofDelta);
  var beforeMoof = segment.subarray(0, moofOffsets[0]);
  var afterMoof = segment.subarray(moofOffsets[1], segment.length);
  newSegment.set(beforeMoof, 0);
  newSegment.set(newMoof, beforeMoof.length);
  newSegment.set(afterMoof, beforeMoof.length + newMoof.length);
  return newSegment;
}

exports.default = replaceMoofInSegment;
},{"../../../compat":"../../../compat/index.ts","../../../parsers/containers/isobmff":"../../../parsers/containers/isobmff/index.ts","../../../utils/byte_parsing":"../../../utils/byte_parsing.ts","./create_boxes":"../../../transports/smooth/isobmff/create_boxes.ts"}],"../../../transports/smooth/isobmff/patch_segment.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var isobmff_1 = require("../../../parsers/containers/isobmff");

var add_data_offset_flag_in_trun_1 = __importDefault(require("./add_data_offset_flag_in_trun"));

var create_boxes_1 = require("./create_boxes");

var create_traf_box_1 = __importDefault(require("./create_traf_box"));

var replace_moof_1 = __importDefault(require("./replace_moof"));
/**
 * Patch ISOBMFF Segment downloaded in Smooth Streaming.
 * @param {Uint8Array} segment
 * @param {Number} decodeTime
 * @return {Uint8Array}
 */


function patchSegment(segment, decodeTime) {
  var moofOffsets = isobmff_1.getBoxOffsets(segment, 0x6d6f6f66
  /* moof */
  );

  if (moofOffsets == null) {
    throw new Error("Smooth: Invalid ISOBMFF given");
  }

  var moofContent = segment.subarray(moofOffsets[0] + 8, moofOffsets[1]);
  var mfhdBox = isobmff_1.getBox(moofContent, 0x6d666864
  /* mfhd */
  );
  var trafContent = isobmff_1.getBoxContent(moofContent, 0x74726166
  /* traf */
  );

  if (trafContent == null || mfhdBox == null) {
    throw new Error("Smooth: Invalid ISOBMFF given");
  }

  var tfhdBox = isobmff_1.getBox(trafContent, 0x74666864
  /* tfhd */
  );
  var trunBox = isobmff_1.getBox(trafContent, 0x7472756e
  /* trun */
  );

  if (tfhdBox == null || trunBox == null) {
    throw new Error("Smooth: Invalid ISOBMFF given");
  } // force trackId=1 since trackIds are not always reliable...


  tfhdBox.set([0, 0, 0, 1], 12);
  var tfdtBox = create_boxes_1.createTfdtBox(decodeTime);
  var newTrunBox = add_data_offset_flag_in_trun_1.default(trunBox);
  var sencContent = isobmff_1.getUuidContent(trafContent, 0xA2394F52, 0x5A9B4F14, 0xA2446C42, 0x7C648DF4);
  var newTrafBox = create_traf_box_1.default(tfhdBox, tfdtBox, newTrunBox, mfhdBox, sencContent);
  var newMoof = isobmff_1.createBoxWithChildren("moof", [mfhdBox, newTrafBox]);
  var trunOffsetInMoof = mfhdBox.length + tfhdBox.length + tfdtBox.length + 8
  /* moof size + name */
  + 8
  /* traf size + name */
  ;
  return replace_moof_1.default(segment, newMoof, moofOffsets, trunOffsetInMoof);
}

exports.default = patchSegment;
},{"../../../parsers/containers/isobmff":"../../../parsers/containers/isobmff/index.ts","./add_data_offset_flag_in_trun":"../../../transports/smooth/isobmff/add_data_offset_flag_in_trun.ts","./create_boxes":"../../../transports/smooth/isobmff/create_boxes.ts","./create_traf_box":"../../../transports/smooth/isobmff/create_traf_box.ts","./replace_moof":"../../../transports/smooth/isobmff/replace_moof.ts"}],"../../../transports/smooth/isobmff/index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var create_audio_init_segment_1 = __importDefault(require("./create_audio_init_segment"));

exports.createAudioInitSegment = create_audio_init_segment_1.default;

var create_video_init_segment_1 = __importDefault(require("./create_video_init_segment"));

exports.createVideoInitSegment = create_video_init_segment_1.default;

var parse_tfrf_1 = __importStar(require("./parse_tfrf"));

exports.parseTfrf = parse_tfrf_1.default;
exports.IISOBMFFBasicSegment = parse_tfrf_1.IISOBMFFBasicSegment;

var parse_tfxd_1 = __importDefault(require("./parse_tfxd"));

exports.parseTfxd = parse_tfxd_1.default;

var patch_segment_1 = __importDefault(require("./patch_segment"));

exports.patchSegment = patch_segment_1.default;
},{"./create_audio_init_segment":"../../../transports/smooth/isobmff/create_audio_init_segment.ts","./create_video_init_segment":"../../../transports/smooth/isobmff/create_video_init_segment.ts","./parse_tfrf":"../../../transports/smooth/isobmff/parse_tfrf.ts","./parse_tfxd":"../../../transports/smooth/isobmff/parse_tfxd.ts","./patch_segment":"../../../transports/smooth/isobmff/patch_segment.ts"}],"../../../transports/smooth/extract_timings_infos.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log_1 = __importDefault(require("../../log"));

var isobmff_1 = require("../../parsers/containers/isobmff");

var isobmff_2 = require("./isobmff");
/**
 * Try to obtain time information from the given data.
 * @param {Uint8Array} data
 * @param {boolean} isChunked
 * @param {Object} segment
 * @param {boolean} isLive
 * @returns {Object}
 */


function extractTimingsInfos(data, isChunked, segment, isLive) {
  var nextSegments = [];
  var chunkInfos;
  var tfxdSegment;
  var tfrfSegments;

  if (isLive) {
    var traf = isobmff_1.getTRAF(data);

    if (traf) {
      tfrfSegments = isobmff_2.parseTfrf(traf);
      tfxdSegment = isobmff_2.parseTfxd(traf);
    } else {
      log_1.default.warn("smooth: could not find traf atom");
    }
  }

  if (tfrfSegments) {
    for (var i = 0; i < tfrfSegments.length; i++) {
      nextSegments.push({
        time: tfrfSegments[i].time,
        duration: tfrfSegments[i].duration,
        timescale: segment.timescale
      });
    }
  }

  if (tfxdSegment) {
    chunkInfos = {
      time: tfxdSegment.time,
      duration: tfxdSegment.duration,
      timescale: segment.timescale
    };
    return {
      nextSegments: nextSegments,
      chunkInfos: chunkInfos
    };
  }

  if (isChunked) {
    return {
      nextSegments: nextSegments,
      chunkInfos: null
    };
  } // we could always make a mistake when reading a container.
  // If the estimate is too far from what the segment seems to imply, take
  // the segment infos instead.


  var maxDecodeTimeDelta = Math.min(segment.timescale * 0.9, segment.duration / 4);
  var trunDuration = isobmff_1.getDurationFromTrun(data);

  if (trunDuration >= 0 && (segment.duration == null || Math.abs(trunDuration - segment.duration) <= maxDecodeTimeDelta)) {
    chunkInfos = {
      time: segment.time,
      duration: trunDuration,
      timescale: segment.timescale
    };
  } else {
    chunkInfos = {
      time: segment.time,
      duration: segment.duration,
      timescale: segment.timescale
    };
  }

  return {
    nextSegments: nextSegments,
    chunkInfos: chunkInfos
  };
}

exports.default = extractTimingsInfos;
},{"../../log":"../../../log.ts","../../parsers/containers/isobmff":"../../../parsers/containers/isobmff/index.ts","./isobmff":"../../../transports/smooth/isobmff/index.ts"}],"../../../transports/smooth/segment_loader.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var assert_1 = __importDefault(require("../../utils/assert"));

var request_1 = __importDefault(require("../../utils/request"));

var byte_range_1 = __importDefault(require("../utils/byte_range"));

var isobmff_1 = require("./isobmff");
/**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @returns {Observable}
 */


function regularSegmentLoader(_ref) {
  var url = _ref.url,
      segment = _ref.segment;
  var headers;
  var range = segment.range;

  if (range) {
    headers = {
      Range: byte_range_1.default(range)
    };
  }

  return request_1.default({
    url: url,
    responseType: "arraybuffer",
    headers: headers,
    sendProgressEvents: true
  });
}
/**
 * Defines the url for the request, load the right loader (custom/default
 * one).
 */


var generateSegmentLoader = function generateSegmentLoader(customSegmentLoader) {
  return function (_ref2) {
    var segment = _ref2.segment,
        representation = _ref2.representation,
        adaptation = _ref2.adaptation,
        period = _ref2.period,
        manifest = _ref2.manifest;

    if (segment.isInit) {
      if (!segment.privateInfos || segment.privateInfos.smoothInit == null) {
        throw new Error("Smooth: Invalid segment format");
      }

      var smoothInitPrivateInfos = segment.privateInfos.smoothInit;
      var responseData;
      var protection = smoothInitPrivateInfos.protection;
      var codecPrivateData = smoothInitPrivateInfos.codecPrivateData || "";

      switch (adaptation.type) {
        case "video":
          responseData = isobmff_1.createVideoInitSegment(segment.timescale, representation.width || 0, representation.height || 0, 72, 72, 4, // vRes, hRes, nal
          codecPrivateData, protection && protection.keyId, protection && protection.keySystems);
          break;

        case "audio":
          responseData = isobmff_1.createAudioInitSegment(segment.timescale, smoothInitPrivateInfos.channels || 0, smoothInitPrivateInfos.bitsPerSample || 0, smoothInitPrivateInfos.packetSize || 0, smoothInitPrivateInfos.samplingRate || 0, codecPrivateData, protection && protection.keyId, protection && protection.keySystems);
          break;

        default:
          if (__DEV__) {
            assert_1.default(false, "responseData should have been set");
          }

          responseData = new Uint8Array(0);
      }

      return rxjs_1.of({
        type: "data-created",
        value: {
          responseData: responseData
        }
      });
    } else if (segment.mediaURL == null) {
      return rxjs_1.of({
        type: "data-created",
        value: {
          responseData: null
        }
      });
    } else {
      var url = segment.mediaURL;
      var args = {
        adaptation: adaptation,
        manifest: manifest,
        period: period,
        representation: representation,
        segment: segment,
        transport: "smooth",
        url: url
      };

      if (!customSegmentLoader) {
        return regularSegmentLoader(args);
      }

      return new rxjs_1.Observable(function (obs) {
        var hasFinished = false;
        var hasFallbacked = false;
        /**
         * Callback triggered when the custom segment loader has a response.
         * @param {Object} args
         */

        var resolve = function resolve(_args) {
          if (!hasFallbacked) {
            hasFinished = true;
            obs.next({
              type: "data-loaded",
              value: {
                responseData: _args.data,
                size: _args.size,
                duration: _args.duration
              }
            });
            obs.complete();
          }
        };
        /**
         * Callback triggered when the custom segment loader fails
         * @param {*} err - The corresponding error encountered
         */


        var reject = function reject() {
          var err = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          if (!hasFallbacked) {
            hasFinished = true;
            obs.error(err);
          }
        };

        var fallback = function fallback() {
          hasFallbacked = true; // HACK What is TypeScript/RxJS doing here??????

          /* tslint:disable deprecation */
          // @ts-ignore

          regularSegmentLoader(args).subscribe(obs);
          /* tslint:enable deprecation */
        };

        var callbacks = {
          reject: reject,
          resolve: resolve,
          fallback: fallback
        };
        var abort = customSegmentLoader(args, callbacks);
        return function () {
          if (!hasFinished && !hasFallbacked && typeof abort === "function") {
            abort();
          }
        };
      });
    }
  };
};

exports.default = generateSegmentLoader;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","../../utils/assert":"../../../utils/assert.ts","../../utils/request":"../../../utils/request/index.ts","../utils/byte_range":"../../../transports/utils/byte_range.ts","./isobmff":"../../../transports/smooth/isobmff/index.ts"}],"../../../transports/smooth/utils.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var warn_once_1 = __importDefault(require("../../utils/warn_once"));

var ISM_REG = /(\.isml?)(\?token=\S+)?$/;
var TOKEN_REG = /\?token=(\S+)/;
/**
 * TODO Remove this logic completely from the player
 * @param {Document} doc
 * @returns {string|null}
 */

function extractISML(doc) {
  return doc.getElementsByTagName("media")[0].getAttribute("src");
}

exports.extractISML = extractISML;
/**
 * Returns string corresponding to the token contained in the url's querystring.
 * Empty string if no token is found.
 * @param {string} url
 * @returns {string}
 */

function extractToken(url) {
  var tokenMatch = url.match(TOKEN_REG);
  return tokenMatch && tokenMatch[1] || "";
}

exports.extractToken = extractToken;
/**
 * Replace/Remove token from the url's querystring
 * @param {string} url
 * @param {string} [token]
 * @returns {string}
 */

function replaceToken(url, token) {
  if (token) {
    return url.replace(TOKEN_REG, "?token=" + token);
  } else {
    return url.replace(TOKEN_REG, "");
  }
}

exports.replaceToken = replaceToken;
/**
 * @param {string} url
 * @returns {string}
 */

function resolveManifest(url) {
  if (ISM_REG.test(url)) {
    warn_once_1.default("Giving a isml URL to loadVideo is deprecated." + " Please give the Manifest URL directly");
    return url.replace(ISM_REG, "$1/manifest$2");
  }

  return url;
}

exports.resolveManifest = resolveManifest;
},{"../../utils/warn_once":"../../../utils/warn_once.ts"}],"../../../transports/smooth/pipelines.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var features_1 = __importDefault(require("../../features"));

var log_1 = __importDefault(require("../../log"));

var manifest_1 = __importDefault(require("../../manifest"));

var isobmff_1 = require("../../parsers/containers/isobmff");

var smooth_1 = __importDefault(require("../../parsers/manifest/smooth"));

var byte_parsing_1 = require("../../utils/byte_parsing");

var request_1 = __importDefault(require("../../utils/request"));

var string_from_utf8_1 = __importDefault(require("../../utils/string_from_utf8"));

var warn_once_1 = __importDefault(require("../../utils/warn_once"));

var check_isobmff_integrity_1 = __importDefault(require("../utils/check_isobmff_integrity"));

var document_manifest_loader_1 = __importDefault(require("../utils/document_manifest_loader"));

var extract_timings_infos_1 = __importDefault(require("./extract_timings_infos"));

var isobmff_2 = require("./isobmff");

var segment_loader_1 = __importDefault(require("./segment_loader"));

var utils_1 = require("./utils");

var WSX_REG = /\.wsx?(\?token=\S+)?/;
/**
 * @param {Object} adaptation
 * @param {Object} dlSegment
 * @param {Object} nextSegments
 */

function addNextSegments(adaptation, nextSegments, dlSegment) {
  log_1.default.debug("Smooth Parser: update segments information.");
  var representations = adaptation.representations;

  for (var i = 0; i < representations.length; i++) {
    var representation = representations[i];

    representation.index._addSegments(nextSegments, dlSegment);
  }
}

function default_1(options) {
  var smoothManifestParser = smooth_1.default(options);
  var segmentLoader = segment_loader_1.default(options.segmentLoader);
  var manifestLoaderOptions = {
    customManifestLoader: options.manifestLoader
  };
  var manifestLoader = document_manifest_loader_1.default(manifestLoaderOptions);
  var manifestPipeline = {
    resolver: function resolver(_ref) {
      var url = _ref.url;

      if (url == null) {
        return rxjs_1.of({
          url: undefined
        });
      } // TODO Remove WSX logic


      var resolving;

      if (WSX_REG.test(url)) {
        warn_once_1.default("Giving WSX URL to loadVideo is deprecated." + " You should only give Manifest URLs.");
        resolving = request_1.default({
          url: utils_1.replaceToken(url, ""),
          responseType: "document"
        }).pipe(operators_1.map(function (_ref2) {
          var value = _ref2.value;
          var extractedURL = utils_1.extractISML(value.responseData);

          if (!extractedURL) {
            throw new Error("Invalid ISML");
          }

          return extractedURL;
        }));
      } else {
        resolving = rxjs_1.of(url);
      }

      var token = utils_1.extractToken(url);
      return resolving.pipe(operators_1.map(function (_url) {
        return {
          url: utils_1.replaceToken(utils_1.resolveManifest(_url), token)
        };
      }));
    },
    loader: manifestLoader,
    parser: function parser(_ref3) {
      var response = _ref3.response,
          reqURL = _ref3.url;
      var url = response.url == null ? reqURL : response.url;
      var data = typeof response.responseData === "string" ? new DOMParser().parseFromString(response.responseData, "text/xml") : response.responseData; // TODO find a way to check if Document?

      var manifestReceivedTime = response.receivedTime;
      var parserResult = smoothManifestParser(data, url, manifestReceivedTime);
      var manifest = new manifest_1.default(parserResult, {
        representationFilter: options.representationFilter,
        supplementaryImageTracks: options.supplementaryImageTracks,
        supplementaryTextTracks: options.supplementaryTextTracks
      });
      return rxjs_1.of({
        manifest: manifest,
        url: url
      });
    }
  };
  var segmentPipeline = {
    loader: function loader(content) {
      if (content.segment.isInit || options.checkMediaSegmentIntegrity !== true) {
        return segmentLoader(content);
      }

      return segmentLoader(content).pipe(operators_1.tap(function (res) {
        if ((res.type === "data-loaded" || res.type === "data-chunk") && res.value.responseData !== null) {
          check_isobmff_integrity_1.default(new Uint8Array(res.value.responseData), content.segment.isInit);
        }
      }));
    },
    parser: function parser(_ref4) {
      var content = _ref4.content,
          response = _ref4.response;
      var segment = content.segment,
          adaptation = content.adaptation,
          manifest = content.manifest;
      var data = response.data,
          isChunked = response.isChunked;

      if (data == null) {
        return rxjs_1.of({
          chunkData: null,
          chunkInfos: null,
          chunkOffset: 0,
          appendWindow: [undefined, undefined]
        });
      }

      if (segment.isInit) {
        // smooth init segments are crafted by hand. Their timescale is the one
        // from the manifest.
        var initSegmentInfos = {
          timescale: segment.timescale,
          time: 0,
          duration: 0
        };
        return rxjs_1.of({
          chunkData: data,
          chunkInfos: initSegmentInfos,
          chunkOffset: 0,
          appendWindow: [undefined, undefined]
        });
      }

      var responseBuffer = data instanceof Uint8Array ? data : new Uint8Array(data);

      var _extract_timings_info = extract_timings_infos_1.default(responseBuffer, isChunked, segment, manifest.isLive),
          nextSegments = _extract_timings_info.nextSegments,
          chunkInfos = _extract_timings_info.chunkInfos;

      if (chunkInfos == null) {
        throw new Error("Smooth Segment without time information");
      }

      var chunkData = isobmff_2.patchSegment(responseBuffer, chunkInfos.time);

      if (nextSegments) {
        addNextSegments(adaptation, nextSegments, chunkInfos);
      }

      return rxjs_1.of({
        chunkData: chunkData,
        chunkInfos: chunkInfos,
        chunkOffset: 0,
        appendWindow: [undefined, undefined]
      });
    }
  };
  var textTrackPipeline = {
    loader: function loader(_ref5) {
      var segment = _ref5.segment,
          representation = _ref5.representation;

      if (segment.isInit || segment.mediaURL == null) {
        return rxjs_1.of({
          type: "data-created",
          value: {
            responseData: null
          }
        });
      }

      var isMP4 = isMP4EmbeddedTrack(representation);

      if (!isMP4 || options.checkMediaSegmentIntegrity !== true) {
        return request_1.default({
          url: segment.mediaURL,
          responseType: isMP4 ? "arraybuffer" : "text",
          sendProgressEvents: true
        });
      }

      return request_1.default({
        url: segment.mediaURL,
        responseType: "arraybuffer",
        sendProgressEvents: true
      }).pipe(operators_1.tap(function (res) {
        if (res.type === "data-loaded") {
          check_isobmff_integrity_1.default(new Uint8Array(res.value.responseData), segment.isInit);
        }
      }));
    },
    parser: function parser(_ref6) {
      var content = _ref6.content,
          response = _ref6.response;
      var manifest = content.manifest,
          adaptation = content.adaptation,
          representation = content.representation,
          segment = content.segment;
      var language = adaptation.language;
      var _representation$mimeT = representation.mimeType,
          mimeType = _representation$mimeT === void 0 ? "" : _representation$mimeT,
          _representation$codec = representation.codec,
          codec = _representation$codec === void 0 ? "" : _representation$codec;
      var data = response.data,
          isChunked = response.isChunked;

      if (segment.isInit || data == null) {
        return rxjs_1.of({
          chunkData: null,
          chunkInfos: null,
          chunkOffset: 0,
          appendWindow: [undefined, undefined]
        });
      }

      var nextSegments;
      var chunkInfos = null;
      var isMP4 = mimeType.indexOf("mp4") >= 0;

      var _sdStart;

      var _sdEnd;

      var _sdTimescale = 1;

      var _sdData;

      var _sdType;

      if (isMP4) {
        var chunkBytes;

        if (typeof data === "string") {
          chunkBytes = byte_parsing_1.strToBytes(data);
        } else {
          chunkBytes = data instanceof Uint8Array ? data : new Uint8Array(data);
        }

        var timings = extract_timings_infos_1.default(chunkBytes, isChunked, segment, manifest.isLive);
        nextSegments = timings.nextSegments;
        chunkInfos = timings.chunkInfos;

        if (chunkInfos == null) {
          if (isChunked) {
            log_1.default.warn("Smooth: Unavailable time data for current text track.");
          } else {
            _sdStart = segment.time;
            _sdEnd = _sdStart + segment.duration;
            _sdTimescale = segment.timescale;
          }
        } else {
          _sdStart = chunkInfos.time;
          _sdEnd = chunkInfos.duration != null ? chunkInfos.time + chunkInfos.duration : undefined;
          _sdTimescale = chunkInfos.timescale;
        }

        var lcCodec = codec.toLowerCase();

        if (mimeType === "application/ttml+xml+mp4" || lcCodec === "stpp" || lcCodec === "stpp.ttml.im1t") {
          _sdType = "ttml";
        } else if (lcCodec === "wvtt") {
          _sdType = "vtt";
        } else {
          throw new Error("could not find a text-track parser for the type ".concat(mimeType));
        }

        var mdat = isobmff_1.getMDAT(chunkBytes);
        _sdData = string_from_utf8_1.default(mdat);
      } else {
        var chunkString;

        if (typeof data !== "string") {
          var bytesData = data instanceof Uint8Array ? data : new Uint8Array(data);
          chunkString = byte_parsing_1.bytesToStr(bytesData);
        } else {
          chunkString = data;
        }

        var segmentTime = segment.time || 0; // vod is simple WebVTT or TTML text

        _sdStart = segmentTime;
        _sdEnd = segmentTime + segment.duration;
        _sdTimescale = segment.timescale;

        switch (mimeType) {
          case "application/x-sami":
          case "application/smil":
            // TODO SMIL should be its own format, no?
            _sdType = "sami";
            break;

          case "application/ttml+xml":
            _sdType = "ttml";
            break;

          case "text/vtt":
            _sdType = "vtt";
            break;
        }

        if (!_sdType) {
          var _lcCodec = codec.toLowerCase();

          if (_lcCodec === "srt") {
            _sdType = "srt";
          } else {
            throw new Error("could not find a text-track parser for the type ".concat(mimeType));
          }
        }

        _sdData = chunkString;
      }

      if (chunkInfos != null && nextSegments) {
        addNextSegments(adaptation, nextSegments, chunkInfos);
      }

      return rxjs_1.of({
        chunkData: {
          type: _sdType,
          data: _sdData,
          language: language,
          timescale: _sdTimescale,
          start: _sdStart,
          end: _sdEnd
        },
        chunkInfos: chunkInfos,
        chunkOffset: _sdStart == null ? 0 : _sdStart / _sdTimescale,
        appendWindow: [undefined, undefined]
      });
    }
  };
  var imageTrackPipeline = {
    loader: function loader(_ref7) {
      var segment = _ref7.segment;

      if (segment.isInit || segment.mediaURL == null) {
        // image do not need an init segment. Passthrough directly to the parser
        return rxjs_1.of({
          type: "data-created",
          value: {
            responseData: null
          }
        });
      }

      return request_1.default({
        url: segment.mediaURL,
        responseType: "arraybuffer",
        sendProgressEvents: true
      });
    },
    parser: function parser(_ref8) {
      var response = _ref8.response,
          content = _ref8.content;
      var segment = content.segment;
      var data = response.data,
          isChunked = response.isChunked;

      if (isChunked) {
        throw new Error("Image data should not be downloaded in chunks");
      } // TODO image Parsing should be more on the sourceBuffer side, no?


      if (data === null || features_1.default.imageParser == null) {
        return rxjs_1.of({
          chunkData: null,
          chunkInfos: segment.timescale > 0 ? {
            duration: segment.isInit ? 0 : segment.duration,
            time: segment.isInit ? 0 : segment.time,
            timescale: segment.timescale
          } : null,
          chunkOffset: 0,
          appendWindow: [undefined, undefined]
        });
      }

      var bifObject = features_1.default.imageParser(new Uint8Array(data));
      var thumbsData = bifObject.thumbs;
      return rxjs_1.of({
        chunkData: {
          data: thumbsData,
          start: 0,
          end: Number.MAX_VALUE,
          timescale: 1,
          type: "bif"
        },
        chunkInfos: {
          time: 0,
          duration: Number.MAX_VALUE,
          timescale: bifObject.timescale
        },
        chunkOffset: 0,
        appendWindow: [undefined, undefined]
      });
    }
  };
  return {
    manifest: manifestPipeline,
    audio: segmentPipeline,
    video: segmentPipeline,
    text: textTrackPipeline,
    image: imageTrackPipeline
  };
}

exports.default = default_1;
/**
 * Returns true if the given texttrack segment represents a textrack embedded
 * in a mp4 file.
 * @param {Representation} representation
 * @returns {Boolean}
 */

function isMP4EmbeddedTrack(representation) {
  return !!representation.mimeType && representation.mimeType.indexOf("mp4") >= 0;
}
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../features":"../../../features/index.ts","../../log":"../../../log.ts","../../manifest":"../../../manifest/index.ts","../../parsers/containers/isobmff":"../../../parsers/containers/isobmff/index.ts","../../parsers/manifest/smooth":"../../../parsers/manifest/smooth/index.ts","../../utils/byte_parsing":"../../../utils/byte_parsing.ts","../../utils/request":"../../../utils/request/index.ts","../../utils/string_from_utf8":"../../../utils/string_from_utf8.ts","../../utils/warn_once":"../../../utils/warn_once.ts","../utils/check_isobmff_integrity":"../../../transports/utils/check_isobmff_integrity.ts","../utils/document_manifest_loader":"../../../transports/utils/document_manifest_loader.ts","./extract_timings_infos":"../../../transports/smooth/extract_timings_infos.ts","./isobmff":"../../../transports/smooth/isobmff/index.ts","./segment_loader":"../../../transports/smooth/segment_loader.ts","./utils":"../../../transports/smooth/utils.ts"}],"../../../transports/smooth/index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

var pipelines_1 = __importDefault(require("./pipelines"));

exports.default = pipelines_1.default;
},{"./pipelines":"../../../transports/smooth/pipelines.ts"}],"../../../core/pipelines/utils/backoff.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var compat_1 = require("../../../compat");

var errors_1 = require("../../../errors");

var get_fuzzed_delay_1 = __importDefault(require("../../../utils/get_fuzzed_delay"));
/**
 * Called on a pipeline's loader error.
 * Returns whether the loader request should be retried.
 * @param {Error} error
 * @returns {Boolean} - If true, the request can be retried.
 */


function shouldRetry(error) {
  if (error instanceof errors_1.RequestError) {
    if (error.type === errors_1.NetworkErrorTypes.ERROR_HTTP_CODE) {
      return error.status >= 500 || error.status === 404 || error.status === 415 || // some CDN seems to use that code when
      // requesting low-latency segments too much
      // in advance
      error.status === 412;
    }

    return error.type === errors_1.NetworkErrorTypes.TIMEOUT || error.type === errors_1.NetworkErrorTypes.ERROR_EVENT;
  }

  return errors_1.isKnownError(error) && error.code === "INTEGRITY_ERROR";
}
/**
 * Returns true if we're pretty sure that the current error is due to the
 * user being offline.
 * @param {Error} error
 * @returns {Boolean}
 */


function isOfflineRequestError(error) {
  return error.type === errors_1.NetworkErrorTypes.ERROR_EVENT && compat_1.isOffline();
}
/**
 * Specific exponential backoff algorithm used for segments/manifest
 * downloading.
 *
 * The specificty here in comparaison to a "regular" backoff algorithm is
 * the separation between type of errors:
 *   - "offline" errors
 *   - other xhr errors
 * Both have their own counters which are resetted if the error type changes.
 * @param {Observable} obs$
 * @param {Object} options - Configuration options.
 * @returns {Observable}
 */


function backoff(obs$, options) {
  var baseDelay = options.baseDelay,
      maxDelay = options.maxDelay,
      maxRetryRegular = options.maxRetryRegular,
      maxRetryOffline = options.maxRetryOffline;
  var retryCount = 0;
  var ERROR_TYPES = {
    NONE: 0,
    REGULAR: 1,
    OFFLINE: 2
  };
  var lastError = ERROR_TYPES.NONE;
  return obs$.pipe(operators_1.map(function (res) {
    return {
      type: "response",
      value: res
    };
  }), operators_1.catchError(function (error, source) {
    if (!shouldRetry(error)) {
      throw error;
    }

    var currentError = error instanceof errors_1.RequestError && isOfflineRequestError(error) ? ERROR_TYPES.OFFLINE : ERROR_TYPES.REGULAR;
    var maxRetry = currentError === ERROR_TYPES.OFFLINE ? maxRetryOffline : maxRetryRegular;

    if (currentError !== lastError) {
      retryCount = 0;
      lastError = currentError;
    }

    if (++retryCount > maxRetry) {
      throw error;
    }

    var delay = Math.min(baseDelay * Math.pow(2, retryCount - 1), maxDelay);
    var fuzzedDelay = get_fuzzed_delay_1.default(delay);
    return rxjs_1.timer(fuzzedDelay).pipe(operators_1.mergeMap(function () {
      return source;
    }), operators_1.startWith({
      type: "retry",
      value: error
    }));
  }));
}

exports.default = backoff;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../../compat":"../../../compat/index.ts","../../../errors":"../../../errors/index.ts","../../../utils/get_fuzzed_delay":"../../../utils/get_fuzzed_delay.ts"}],"../../../core/pipelines/utils/error_selector.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var errors_1 = require("../../../errors");
/**
 * Generate a new error from the infos given.
 * @param {string} code
 * @param {Error} error
 * @returns {Error}
 */


function errorSelector(error) {
  if (error instanceof errors_1.RequestError) {
    return new errors_1.NetworkError("PIPELINE_LOAD_ERROR", error);
  }

  return errors_1.formatError(error, {
    defaultCode: "PIPELINE_LOAD_ERROR",
    defaultReason: "Unknown error when fetching the Manifest"
  });
}

exports.default = errorSelector;
},{"../../../errors":"../../../errors/index.ts"}],"../../../core/pipelines/manifest/create_manifest_loader.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var rx_try_catch_1 = __importDefault(require("../../../utils/rx-try_catch"));

var backoff_1 = __importDefault(require("../utils/backoff"));

var error_selector_1 = __importDefault(require("../utils/error_selector"));
/**
 * Returns function allowing to download the Manifest through a resolver ->
 * loader pipeline.
 *
 * The function returned takes the loader's data in arguments and returns an
 * Observable which will emit:
 *
 *   - each time a minor request error is encountered (type "warning").
 *     With the error as a value.
 *
 *   - The fetched data (type "response").
 *
 * This observable will throw if, following the options given, the request and
 * possible retry all failed.
 *
 * This observable will complete after emitting the data.
 *
 * @param {Object} manifestPipeline
 * @param {Object} options
 * @returns {Function}
 */


function createManifestLoader(manifestPipeline, options) {
  var maxRetry = options.maxRetry,
      maxRetryOffline = options.maxRetryOffline;
  var loader = manifestPipeline.loader; // TODO Remove the resolver completely

  var resolver = manifestPipeline.resolver != null ? manifestPipeline.resolver :
  /* tslint:disable deprecation */
  rxjs_1.of;
  /* tslint:enable deprecation */
  // Backoff options given to the backoff retry done with the loader function.

  var backoffOptions = {
    baseDelay: options.baseDelay,
    maxDelay: options.maxDelay,
    maxRetryRegular: maxRetry,
    maxRetryOffline: maxRetryOffline
  };
  /**
   * Call the transport's resolver - if it exists - with the given data.
   *
   * Throws with the right error if it fails.
   * @param {Object} resolverArgument
   * @returns {Observable}
   */

  function callResolver(resolverArgument) {
    return rx_try_catch_1.default(resolver, resolverArgument).pipe() // Weird TypeScript/RxJS behavior
    .pipe(operators_1.catchError(function (error) {
      throw error_selector_1.default(error);
    }));
  }
  /**
   * Load wanted data:
   *   - get it from cache if present
   *   - call the transport loader - with an exponential backoff - if not
   *
   * @param {Object} loaderArgument - Input given to the loader
   * @returns {Observable}
   */


  function loadData(loaderArgument) {
    return backoff_1.default(rx_try_catch_1.default(loader, loaderArgument), backoffOptions).pipe(operators_1.catchError(function (error) {
      throw error_selector_1.default(error);
    }), operators_1.map(function (evt) {
      return evt.type === "response" ? evt.value : {
        type: "warning",
        value: error_selector_1.default(evt.value)
      };
    }));
  }
  /**
   * Load the corresponding data.
   * @param {Object} pipelineInputData
   * @returns {Observable}
   */


  return function startPipeline(loaderArgs) {
    return callResolver(loaderArgs).pipe(operators_1.mergeMap(function (resolverResponse) {
      return loadData(resolverResponse).pipe(operators_1.mergeMap(function (arg) {
        if (arg.type === "warning") {
          return rxjs_1.of(arg);
        }

        var value = arg.value;
        return rxjs_1.of({
          type: "response",
          value: {
            responseData: value.responseData,
            url: value.url,
            sendingTime: value.sendingTime,
            receivedTime: value.receivedTime
          }
        });
      }));
    }));
  };
}

exports.default = createManifestLoader;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../../utils/rx-try_catch":"../../../utils/rx-try_catch.ts","../utils/backoff":"../../../core/pipelines/utils/backoff.ts","../utils/error_selector":"../../../core/pipelines/utils/error_selector.ts"}],"../../../core/pipelines/manifest/parse_manifest_pipeline_options.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var config_1 = __importDefault(require("../../../config"));

var _config_1$default = config_1.default,
    DEFAULT_MAX_MANIFEST_REQUEST_RETRY = _config_1$default.DEFAULT_MAX_MANIFEST_REQUEST_RETRY,
    DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR = _config_1$default.DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR,
    INITIAL_BACKOFF_DELAY_BASE = _config_1$default.INITIAL_BACKOFF_DELAY_BASE,
    MAX_BACKOFF_DELAY_BASE = _config_1$default.MAX_BACKOFF_DELAY_BASE;
/**
 * Parse config to replace missing manifest pipeline options.
 * @param {Object} manifestPipelineOptions
 * @returns {Object}
 */

function parseManifestPipelineOptions(_ref) {
  var manifestRetry = _ref.manifestRetry,
      offlineRetry = _ref.offlineRetry,
      lowLatencyMode = _ref.lowLatencyMode;
  var baseDelay = lowLatencyMode ? INITIAL_BACKOFF_DELAY_BASE.LOW_LATENCY : INITIAL_BACKOFF_DELAY_BASE.REGULAR;
  var maxDelay = lowLatencyMode ? MAX_BACKOFF_DELAY_BASE.LOW_LATENCY : MAX_BACKOFF_DELAY_BASE.REGULAR;
  return {
    baseDelay: baseDelay,
    maxDelay: maxDelay,
    maxRetry: manifestRetry != null ? manifestRetry : DEFAULT_MAX_MANIFEST_REQUEST_RETRY,
    maxRetryOffline: offlineRetry != null ? offlineRetry : DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR,
    lowLatencyMode: lowLatencyMode
  };
}

exports.default = parseManifestPipelineOptions;
},{"../../../config":"../../../config.ts"}],"../../../core/pipelines/manifest/create_manifest_pipeline.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var errors_1 = require("../../../errors");

var rx_try_catch_1 = __importDefault(require("../../../utils/rx-try_catch"));

var backoff_1 = __importDefault(require("../utils/backoff"));

var error_selector_1 = __importDefault(require("../utils/error_selector"));

var create_manifest_loader_1 = __importDefault(require("./create_manifest_loader"));

var parse_manifest_pipeline_options_1 = __importDefault(require("./parse_manifest_pipeline_options"));
/**
 * Create function allowing to easily fetch and parse the manifest from its URL.
 *
 * @example
 * ```js
 * const manifestPipeline = createManifestPipeline(pipelines, options, warning$);
 * manifestPipeline.fetch(manifestURL)
 *  .mergeMap((evt) => {
 *    if (evt.type !== "response") { // Might also receive warning events
 *      return EMPTY;
 *    }
 *    return manifestPipeline.parse(evt.value);
 *  }).subscribe(({ manifest }) => console.log("Manifest:", manifest));
 * ```
 *
 * @param {Object} pipelines
 * @param {Subject} pipelineOptions
 * @param {Subject} warning$
 * @returns {Function}
 */


function createManifestPipeline(pipelines, pipelineOptions, warning$) {
  var parsedOptions = parse_manifest_pipeline_options_1.default(pipelineOptions);
  var loader = create_manifest_loader_1.default(pipelines.manifest, parsedOptions);
  var parser = pipelines.manifest.parser;
  /**
   * Allow the parser to schedule a new request.
   * @param {Object} transportPipeline
   * @param {Object} options
   * @returns {Function}
   */

  function scheduleRequest(request) {
    var backoffOptions = {
      baseDelay: parsedOptions.baseDelay,
      maxDelay: parsedOptions.maxDelay,
      maxRetryRegular: parsedOptions.maxRetry,
      maxRetryOffline: parsedOptions.maxRetryOffline
    };
    return backoff_1.default(rx_try_catch_1.default(request, undefined), backoffOptions).pipe(operators_1.mergeMap(function (evt) {
      if (evt.type === "retry") {
        warning$.next(error_selector_1.default(evt.value));
        return rxjs_1.EMPTY;
      }

      return rxjs_1.of(evt.value);
    }), operators_1.catchError(function (error) {
      throw error_selector_1.default(error);
    }));
  }

  return {
    /**
     * Fetch the manifest corresponding to the URL given.
     * @param {string} url - URL of the manifest
     * @returns {Observable}
     */
    fetch: function fetch(url) {
      return loader({
        url: url
      }).pipe(operators_1.tap(function (arg) {
        if (arg.type === "warning") {
          warning$.next(arg.value); // TODO not through warning$
        }
      }), operators_1.filter(function (arg) {
        return arg.type === "response";
      }));
    },

    /**
     * Fetch the manifest corresponding to the URL given.
     * @param {Object} value - The Manifest document to parse.
     * @param {string} [url] - URL of the manifest
     * @param {number} [externalClockOffset]
     * @returns {Observable}
     */
    parse: function parse(value, fetchedURL, externalClockOffset) {
      var sendingTime = value.sendingTime;
      return parser({
        response: value,
        url: fetchedURL,
        externalClockOffset: externalClockOffset,
        scheduleRequest: scheduleRequest
      }).pipe(operators_1.catchError(function (error) {
        throw errors_1.formatError(error, {
          defaultCode: "PIPELINE_PARSE_ERROR",
          defaultReason: "Unknown error when parsing the Manifest"
        });
      }), operators_1.map(function (_ref) {
        var manifest = _ref.manifest;
        var warnings = manifest.parsingErrors;

        for (var i = 0; i < warnings.length; i++) {
          warning$.next(warnings[i]); // TODO not through warning$
        }

        return {
          manifest: manifest,
          sendingTime: sendingTime
        };
      }));
    }
  };
}

exports.default = createManifestPipeline;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../../errors":"../../../errors/index.ts","../../../utils/rx-try_catch":"../../../utils/rx-try_catch.ts","../utils/backoff":"../../../core/pipelines/utils/backoff.ts","../utils/error_selector":"../../../core/pipelines/utils/error_selector.ts","./create_manifest_loader":"../../../core/pipelines/manifest/create_manifest_loader.ts","./parse_manifest_pipeline_options":"../../../core/pipelines/manifest/parse_manifest_pipeline_options.ts"}],"../../../core/pipelines/manifest/index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var create_manifest_pipeline_1 = __importStar(require("./create_manifest_pipeline"));

exports.IFetchManifestResult = create_manifest_pipeline_1.IFetchManifestResult;
exports.default = create_manifest_pipeline_1.default;
},{"./create_manifest_pipeline":"../../../core/pipelines/manifest/create_manifest_pipeline.ts"}],"../../../core/pipelines/segment/prioritized_segment_fetcher.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * This function basically put in relation:
 *   - a SegmentFetcher, which will be used to perform the segment request
 *   - a prioritizer, which will handle the priority of a segment request
 *
 * and returns functions to fetch segments with a given priority.
 * @param {Object} prioritizer
 * @param {Object} fetcher
 * @returns {Object}
 */

function applyPrioritizerToSegmentFetcher(prioritizer, fetcher) {
  return {
    /**
     * Create a Segment request with a given priority.
     * @param {Object} content - content to request
     * @param {Number} priority - priority at which the content should be
     * requested.
     * @returns {Observable}
     */
    createRequest: function createRequest(content) {
      var priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return prioritizer.create(fetcher(content), priority);
    },

    /**
     * Update the priority of a pending request, created through createRequest.
     * @param {Observable} observable - the corresponding request
     * @param {Number} priority
     */
    updatePriority: function updatePriority(observable, priority) {
      prioritizer.updatePriority(observable, priority);
    }
  };
}

exports.default = applyPrioritizerToSegmentFetcher;
},{}],"../../../utils/assert_unreachable.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var errors_1 = require("../errors");

function assertUnreachable(_) {
  throw new errors_1.AssertionError("Unreachable path taken");
}

exports.default = assertUnreachable;
},{"../errors":"../../../errors/index.ts"}],"../../../core/pipelines/segment/create_segment_loader.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var object_assign_1 = __importDefault(require("object-assign"));

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var assert_unreachable_1 = __importDefault(require("../../../utils/assert_unreachable"));

var cast_to_observable_1 = __importDefault(require("../../../utils/cast_to_observable"));

var rx_try_catch_1 = __importDefault(require("../../../utils/rx-try_catch"));

var backoff_1 = __importDefault(require("../utils/backoff"));

var error_selector_1 = __importDefault(require("../utils/error_selector"));
/**
 * Returns function allowing to download the wanted data through the loader.
 *
 * (The data can be for example: audio and video segments, text,
 * images...)
 *
 * The function returned takes the initial data in arguments and returns an
 * Observable which will emit:
 *
 *   - each time a request begins (type "request").
 *     This is not emitted if the value is retrieved from a local js cache.
 *     This event emits the payload as a value.
 *
 *   - as the request progresses (type "progress").
 *
 *   - each time a request ends (type "metrics").
 *     This event contains information about the metrics of the request.
 *
 *   - each time a minor request error is encountered (type "warning").
 *     With the error as a value.
 *
 *   - Lastly, with the fetched data (type "response").
 *
 *
 * Each of these but "warning" can be emitted at most one time.
 *
 * This observable will throw if, following the options given, the request and
 * possible retry all failed.
 *
 * This observable will complete after emitting the data.
 *
 * Type parameters:
 *   - T: type of the data emitted
 *
 * @param {Object} segmentPipeline
 * @param {Object} options
 * @returns {Function}
 */


function createSegmentLoader(loader, options) {
  var cache = options.cache,
      maxRetry = options.maxRetry,
      maxRetryOffline = options.maxRetryOffline; // Backoff options given to the backoff retry done with the loader function.

  var backoffOptions = {
    baseDelay: options.initialBackoffDelay,
    maxDelay: options.maximumBackoffDelay,
    maxRetryRegular: maxRetry,
    maxRetryOffline: maxRetryOffline
  };
  /**
   * Load wanted data:
   *   - get it from cache if present
   *   - call the transport loader - with an exponential backoff - if not
   *
   * @param {Object} loaderArgument - Input given to the loader
   * @returns {Observable}
   */

  function loadData(loaderArgument) {
    /**
     * Call the Pipeline's loader with an exponential Backoff.
     * @returns {Observable}
     */
    function startLoaderWithBackoff() {
      var request$ = backoff_1.default(rx_try_catch_1.default(loader, loaderArgument), backoffOptions).pipe(operators_1.catchError(function (error) {
        throw error_selector_1.default(error);
      }), operators_1.map(function (evt) {
        if (evt.type === "retry") {
          return {
            type: "warning",
            value: error_selector_1.default(evt.value)
          };
        }

        var response = evt.value;

        if (response.type === "data-loaded" && cache != null) {
          cache.add(loaderArgument, response.value);
        }

        return evt.value;
      }));
      return rxjs_1.concat(rxjs_1.of({
        type: "request",
        value: loaderArgument
      }), request$);
    }

    var dataFromCache = cache != null ? cache.get(loaderArgument) : null;

    if (dataFromCache != null) {
      return cast_to_observable_1.default(dataFromCache).pipe(operators_1.map(function (response) {
        return {
          type: "cache",
          value: response
        };
      }), operators_1.catchError(startLoaderWithBackoff));
    }

    return startLoaderWithBackoff();
  }
  /**
   * Load the corresponding data.
   * @param {Object} pipelineInputData
   * @returns {Observable}
   */


  return function startPipeline(pipelineInputData) {
    return loadData(pipelineInputData).pipe(operators_1.mergeMap(function (arg) {
      var metrics$ = arg.type === "data-chunk-complete" || arg.type === "data-loaded" ? rxjs_1.of({
        type: "metrics",
        value: {
          size: arg.value.size,
          duration: arg.value.duration
        }
      }) : rxjs_1.EMPTY; // "cache": data taken from cache by the pipeline
      // "data-created": the data is available but no request has been done
      // "data-loaded": data received through a request

      switch (arg.type) {
        case "warning":
          return rxjs_1.of(arg);

        case "cache":
        case "data-created":
        case "data-loaded":
          var chunck$ = rxjs_1.of({
            type: "data",
            value: object_assign_1.default({}, pipelineInputData, {
              responseData: arg.value.responseData
            })
          });
          return rxjs_1.concat(chunck$, metrics$);

        case "request":
        case "progress":
          return rxjs_1.of(arg);

        case "data-chunk":
          return rxjs_1.of({
            type: "chunk",
            value: object_assign_1.default({}, pipelineInputData, {
              responseData: arg.value.responseData
            })
          });

        case "data-chunk-complete":
          var _complete$ = rxjs_1.of({
            type: "chunk-complete",
            value: null
          });

          return rxjs_1.concat(_complete$, metrics$);
      }

      return assert_unreachable_1.default(arg);
    }));
  };
}

exports.default = createSegmentLoader;
},{"object-assign":"../../../../node_modules/object-assign/index.js","rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../../utils/assert_unreachable":"../../../utils/assert_unreachable.ts","../../../utils/cast_to_observable":"../../../utils/cast_to_observable.ts","../../../utils/rx-try_catch":"../../../utils/rx-try_catch.ts","../utils/backoff":"../../../core/pipelines/utils/backoff.ts","../utils/error_selector":"../../../core/pipelines/utils/error_selector.ts"}],"../../../core/pipelines/segment/segment_fetcher.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var errors_1 = require("../../../errors");

var id_generator_1 = __importDefault(require("../../../utils/id_generator"));

var create_segment_loader_1 = __importDefault(require("./create_segment_loader"));

var generateRequestID = id_generator_1.default();
/**
 * Create a function which will fetch segments.
 *
 * @param {string} bufferType
 * @param {Object} transport
 * @param {Subject} requests$
 * @param {Object} options
 * @returns {Function}
 */

function createSegmentFetcher(bufferType, transport, requests$, options) {
  var segmentLoader = create_segment_loader_1.default(transport[bufferType].loader, options);
  var segmentParser = transport[bufferType].parser; // deal with it

  /**
   * Process a pipeline observable to adapt it to the the rest of the code:
   *   - use the requests subject for network requests and their progress
   *   - use the warning$ subject for retries' error messages
   *   - only emit the data
   * @param {string} pipelineType
   * @param {Observable} pipeline$
   * @returns {Observable}
   */

  return function fetchSegment(content) {
    var id = generateRequestID();
    var requestBeginSent = false;
    return segmentLoader(content).pipe(operators_1.tap(function (arg) {
      switch (arg.type) {
        case "metrics":
          {
            var value = arg.value;
            var size = value.size,
                duration = value.duration; // unwrapping for TS
            // format it for ABR Handling

            if (size != null && duration != null) {
              requests$.next({
                type: "metrics",
                value: {
                  size: size,
                  duration: duration,
                  content: content
                }
              });
            }

            break;
          }

        case "request":
          {
            var _value = arg.value; // format it for ABR Handling

            var segment = _value && _value.segment;

            if (segment == null || segment.duration == null) {
              return;
            }

            requestBeginSent = true;

            var _duration = segment.duration / segment.timescale;

            var time = segment.time / segment.timescale;
            requests$.next({
              type: "requestBegin",
              value: {
                duration: _duration,
                time: time,
                requestTimestamp: performance.now(),
                id: id
              }
            });
            break;
          }

        case "progress":
          {
            var _value2 = arg.value;

            if (_value2.totalSize != null && _value2.size < _value2.totalSize) {
              requests$.next({
                type: "progress",
                value: {
                  duration: _value2.duration,
                  size: _value2.size,
                  totalSize: _value2.totalSize,
                  timestamp: performance.now(),
                  id: id
                }
              });
            }

            break;
          }
      }
    }), operators_1.finalize(function () {
      if (requestBeginSent) {
        requests$.next({
          type: "requestEnd",
          value: {
            id: id
          }
        });
      }
    }), operators_1.filter(function (e) {
      return e.type === "warning" || e.type === "chunk" || e.type === "chunk-complete" || e.type === "data";
    }), operators_1.mergeMap(function (evt) {
      if (evt.type === "warning") {
        return rxjs_1.of(evt);
      }

      if (evt.type === "chunk-complete") {
        return rxjs_1.of({
          type: "chunk-complete"
        });
      }

      var isChunked = evt.type === "chunk";
      var data = {
        type: "chunk",

        /**
         * Parse the loaded data.
         * @param {Object} [init]
         * @returns {Observable}
         */
        parse: function parse(init) {
          var response = {
            data: evt.value.responseData,
            isChunked: isChunked
          };
          return segmentParser({
            response: response,
            init: init,
            content: content
          }).pipe(operators_1.catchError(function (error) {
            throw errors_1.formatError(error, {
              defaultCode: "PIPELINE_PARSE_ERROR",
              defaultReason: "Unknown parsing error"
            });
          }));
        }
      };

      if (isChunked) {
        return rxjs_1.of(data);
      }

      return rxjs_1.concat(rxjs_1.of(data), rxjs_1.of({
        type: "chunk-complete"
      }));
    }), operators_1.share() // avoid multiple side effects if multiple subs
    );
  };
}

exports.default = createSegmentFetcher;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../../errors":"../../../errors/index.ts","../../../utils/id_generator":"../../../utils/id_generator.ts","./create_segment_loader":"../../../core/pipelines/segment/create_segment_loader.ts"}],"../../../utils/initialization_segment_cache.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Caching object used to cache initialization segments.
 * This allow to have a faster representation switch and faster seeking.
 * @class InitializationSegmentCache
 */

var InitializationSegmentCache =
/*#__PURE__*/
function () {
  function InitializationSegmentCache() {
    _classCallCheck(this, InitializationSegmentCache);

    this._cache = new WeakMap();
  }
  /**
   * @param {Object} obj
   * @param {*} response
   */


  _createClass(InitializationSegmentCache, [{
    key: "add",
    value: function add(_ref, response) {
      var representation = _ref.representation,
          segment = _ref.segment;

      if (segment.isInit) {
        this._cache.set(representation, response);
      }
    }
    /**
     * @param {Object} obj
     * @returns {*} response
     */

  }, {
    key: "get",
    value: function get(_ref2) {
      var representation = _ref2.representation,
          segment = _ref2.segment;

      if (segment.isInit) {
        var value = this._cache.get(representation);

        if (value != null) {
          return value;
        }
      }

      return null;
    }
  }]);

  return InitializationSegmentCache;
}();

exports.default = InitializationSegmentCache;
},{}],"../../../core/pipelines/segment/get_segment_pipeline_options.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var config_1 = __importDefault(require("../../../config"));

var array_includes_1 = __importDefault(require("../../../utils/array_includes"));

var initialization_segment_cache_1 = __importDefault(require("../../../utils/initialization_segment_cache"));

var _config_1$default = config_1.default,
    DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR = _config_1$default.DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR,
    DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE = _config_1$default.DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE,
    INITIAL_BACKOFF_DELAY_BASE = _config_1$default.INITIAL_BACKOFF_DELAY_BASE,
    MAX_BACKOFF_DELAY_BASE = _config_1$default.MAX_BACKOFF_DELAY_BASE;
/**
 * @param {string} bufferType
 * @param {Object}
 * @returns {Object}
 */

function parseSegmentPipelineOptions(bufferType, _ref) {
  var segmentRetry = _ref.segmentRetry,
      offlineRetry = _ref.offlineRetry,
      lowLatencyMode = _ref.lowLatencyMode;
  var cache = array_includes_1.default(["audio", "video"], bufferType) ? new initialization_segment_cache_1.default() : undefined;
  var maxRetry;

  if (bufferType === "image") {
    maxRetry = 0; // Deactivate BIF fetching if it fails
  } else {
    maxRetry = segmentRetry != null ? segmentRetry : DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR;
  }

  var maxRetryOffline = offlineRetry != null ? offlineRetry : DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE;
  var initialBackoffDelay = lowLatencyMode ? INITIAL_BACKOFF_DELAY_BASE.LOW_LATENCY : INITIAL_BACKOFF_DELAY_BASE.REGULAR;
  var maximumBackoffDelay = lowLatencyMode ? MAX_BACKOFF_DELAY_BASE.LOW_LATENCY : MAX_BACKOFF_DELAY_BASE.REGULAR;
  return {
    cache: cache,
    maxRetry: maxRetry,
    maxRetryOffline: maxRetryOffline,
    initialBackoffDelay: initialBackoffDelay,
    maximumBackoffDelay: maximumBackoffDelay
  };
}

exports.default = parseSegmentPipelineOptions;
},{"../../../config":"../../../config.ts","../../../utils/array_includes":"../../../utils/array_includes.ts","../../../utils/initialization_segment_cache":"../../../utils/initialization_segment_cache.ts"}],"../../../core/pipelines/segment/prioritizer.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var array_find_index_1 = __importDefault(require("../../../utils/array_find_index"));
/**
 * Create Observables which can be priorized between one another.
 *
 * With this class, you can create Observables with linked priority numbers.
 * The lower this number is, the more priority the resulting Observable will
 * have.
 *
 * Such Observable will then basically wait for pending Observables with more
 * priority to finish before "starting".
 *
 * You can also update the priority of an already-created Observable.
 * This will only have an effect if the Observable is currently "waiting" for
 * its turn (started observable won't be canceled if their priority were
 * lowered).
 *
 * ```js
 * const prioritizer = new ObservablePrioritizer();
 *
 * const observable1 = Observable.of(1);
 * const observable2 = Observable.of(2);
 * const observable3 = Observable.of(3);
 * const observable4 = Observable.of(4);
 * const observable5 = Observable.of(5);
 *
 * const pObservable1 = prioritizer.create(observable1, 4);
 * const pObservable2 = prioritizer.create(observable2, 2);
 * const pObservable3 = prioritizer.create(observable3, 1);
 * const pObservable4 = prioritizer.create(observable4, 3);
 * const pObservable5 = prioritizer.create(observable5, 2);
 *
 * // start every Observables at the same time
 * observableMerge(
 *   pObservable1,
 *   pObservable2,
 *   pObservable3,
 *   pObservable4,
 *   pObservable5
 * ).subscribe((i) => {
 *   // To spice things up, update pObservable1 priority to go before
 *   // pObservable4
 *   if (i === 5) { // if pObservable5 is currently emitting
 *     prioritizer.updatePriority(pObservable1, 1);
 *   }
 *   console.log(i);
 * });
 *
 * // Result:
 * // 3
 * // 2
 * // 5
 * // 1
 * // 4
 *
 * // Note: here "1" goes before "4" only because the former's priority has been
 * // updated before the latter was started.
 * // It would be the other way around if not.
 * ```
 *
 * @class ObservablePrioritizer
 */


var ObservablePrioritizer =
/*#__PURE__*/
function () {
  function ObservablePrioritizer() {
    _classCallCheck(this, ObservablePrioritizer);

    this._pendingPriority = null;
    this._numberOfPendingObservables = 0;
    this._queue = [];
  }
  /**
   * Create a priorized Observable from a base Observable.
   *
   * When subscribed to, this Observable will have its priority compared to
   * all the already-running Observables created from this class.
   * Only if this number is inferior or equal to the priority of the
   * currently-running Observables will it be immediately started.
   * In the opposite case, we will wait for higher-priority Observables to
   * finish before starting it.
   *
   * Note that while this Observable is waiting for its turn, it is possible
   * to update its property through the updatePriority method, by providing
   * the Observable returned by this function and its new priority number.
   *
   * @param {Observable} obs
   * @param {number} priority
   * @returns {Observable}
   */


  _createClass(ObservablePrioritizer, [{
    key: "create",
    value: function create(obs, priority) {
      var _this = this;

      var pObs$ = rxjs_1.defer(function () {
        if (_this._pendingPriority == null || _this._pendingPriority >= priority) {
          // Update the priority and start immediately the Observable
          _this._pendingPriority = priority;
          return _this._startObservable(obs);
        } else {
          var trigger = new rxjs_1.Subject();

          _this._queue.push({
            observable: pObs$,
            priority: priority,
            trigger: trigger
          });

          return trigger.pipe(operators_1.mergeMap(function () {
            return _this._startObservable(obs);
          }));
        }
      });
      return pObs$;
    }
    /**
     * Update the priority of an Observable created through the create method.
     *
     * Note that this will only have an effect on Observable which are not yet
     * started.
     * This means it will only have an effect on:
     *   - unsubscribed Observables
     *   - Observables waiting for Observables with an higher priority to
     *     finish
     *
     * @param {Observable} obs
     * @param {number} priority
     */

  }, {
    key: "updatePriority",
    value: function updatePriority(obs, priority) {
      var index = array_find_index_1.default(this._queue, function (elt) {
        return elt.observable === obs;
      });

      if (index < 0) {
        return;
      }

      var queueElement = this._queue[index];
      queueElement.priority = priority;

      if (this._pendingPriority == null || this._pendingPriority >= priority) {
        this._queue.splice(index, 1);

        queueElement.trigger.next();
        queueElement.trigger.complete();
      }
    }
  }, {
    key: "_startObservable",
    value: function _startObservable(obs) {
      var _this2 = this;

      var onObservableFinish = function onObservableFinish() {
        _this2._numberOfPendingObservables--;

        if (_this2._numberOfPendingObservables > 0) {
          // still waiting for Observables to finish
          return;
        }

        _this2._pendingPriority = null;

        if (_this2._queue.length === 0) {
          return;
        }

        _this2._pendingPriority = _this2._queue.reduce(function (acc, elt) {
          return acc == null || acc > elt.priority ? elt.priority : acc;
        }, null);

        for (var i = 0; i < _this2._queue.length; i++) {
          var elt = _this2._queue[i];

          if (elt.priority === _this2._pendingPriority) {
            _this2._queue.splice(i, 1);

            i--;
            elt.trigger.next();
            elt.trigger.complete();
          }
        }
      };

      this._numberOfPendingObservables++;
      return obs.pipe(operators_1.finalize(onObservableFinish));
    }
  }]);

  return ObservablePrioritizer;
}();

exports.default = ObservablePrioritizer;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../../utils/array_find_index":"../../../utils/array_find_index.ts"}],"../../../core/pipelines/segment/segment_pipelines_manager.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var create_segment_loader_1 = require("./create_segment_loader");

exports.ISegmentPipelineOptions = create_segment_loader_1.ISegmentPipelineLoaderOptions;

var get_segment_pipeline_options_1 = __importDefault(require("./get_segment_pipeline_options"));

var prioritized_segment_fetcher_1 = __importDefault(require("./prioritized_segment_fetcher"));

var prioritizer_1 = __importDefault(require("./prioritizer"));

var segment_fetcher_1 = __importDefault(require("./segment_fetcher"));
/**
 * Interact with the networking pipelines to download segments with the right
 * priority.
 *
 * @class SegmentPipelinesManager
 *
 * @example
 * ```js
 * // 1 - create the manager
 * const segmentPipelinesManager = new SegmentPipelinesManager(transport);
 *
 * // 2 - create a new pipeline with its own options
 * const pipeline = segmentPipelinesManager.createPipeline("audio", {
 *   maxRetry: Infinity,
 *   maxRetryOffline: Infinity,
 * });
 *
 * // 3 - load a segment with a given priority
 * pipeline.createRequest(myContent, 1)
 *
 *   // 4 - parse it
 *   .pipe(
 *     filter(evt => evt.type === "response"),
 *     mergeMap(response => response.parse());
 *   )
 *
 *   // 5 - use it
 *   .subscribe((res) => console.log("audio segment downloaded:", res));
 * ```
 */


var SegmentPipelinesManager =
/*#__PURE__*/
function () {
  /**
   * @param {Object} transport
   */
  function SegmentPipelinesManager(transport, options) {
    _classCallCheck(this, SegmentPipelinesManager);

    this._transport = transport;
    this._prioritizer = new prioritizer_1.default();
    this._pipelineOptions = options;
  }
  /**
   * Create a segment pipeline, allowing to easily perform segment requests.
   * @param {string} bufferType
   * @param {Object} options
   * @returns {Object}
   */


  _createClass(SegmentPipelinesManager, [{
    key: "createPipeline",
    value: function createPipeline(bufferType, requests$) {
      var options = get_segment_pipeline_options_1.default(bufferType, this._pipelineOptions);
      var segmentFetcher = segment_fetcher_1.default(bufferType, this._transport, requests$, options);
      return prioritized_segment_fetcher_1.default(this._prioritizer, segmentFetcher);
    }
  }]);

  return SegmentPipelinesManager;
}();

exports.default = SegmentPipelinesManager;
},{"./create_segment_loader":"../../../core/pipelines/segment/create_segment_loader.ts","./get_segment_pipeline_options":"../../../core/pipelines/segment/get_segment_pipeline_options.ts","./prioritized_segment_fetcher":"../../../core/pipelines/segment/prioritized_segment_fetcher.ts","./prioritizer":"../../../core/pipelines/segment/prioritizer.ts","./segment_fetcher":"../../../core/pipelines/segment/segment_fetcher.ts"}],"../../../core/pipelines/segment/index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var prioritized_segment_fetcher_1 = require("./prioritized_segment_fetcher");

exports.IPrioritizedSegmentFetcher = prioritized_segment_fetcher_1.IPrioritizedSegmentFetcher;

var segment_fetcher_1 = require("./segment_fetcher");

exports.ISegmentFetcherChunkCompleteEvent = segment_fetcher_1.ISegmentFetcherChunkCompleteEvent;
exports.ISegmentFetcherChunkEvent = segment_fetcher_1.ISegmentFetcherChunkEvent;
exports.ISegmentFetcherEvent = segment_fetcher_1.ISegmentFetcherEvent;
exports.ISegmentFetcherWarning = segment_fetcher_1.ISegmentFetcherWarning;

var segment_pipelines_manager_1 = __importStar(require("./segment_pipelines_manager"));

exports.ISegmentPipelineManagerOptions = segment_pipelines_manager_1.ISegmentPipelineManagerOptions;
exports.default = segment_pipelines_manager_1.default;
},{"./prioritized_segment_fetcher":"../../../core/pipelines/segment/prioritized_segment_fetcher.ts","./segment_fetcher":"../../../core/pipelines/segment/segment_fetcher.ts","./segment_pipelines_manager":"../../../core/pipelines/segment/segment_pipelines_manager.ts"}],"../../../core/pipelines/index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var manifest_1 = __importStar(require("./manifest"));

exports.createManifestPipeline = manifest_1.default;
exports.IFetchManifestResult = manifest_1.IFetchManifestResult;

var segment_1 = __importStar(require("./segment"));

exports.SegmentPipelinesManager = segment_1.default;
exports.IPrioritizedSegmentFetcher = segment_1.IPrioritizedSegmentFetcher;
exports.ISegmentFetcherChunkCompleteEvent = segment_1.ISegmentFetcherChunkCompleteEvent;
exports.ISegmentFetcherChunkEvent = segment_1.ISegmentFetcherChunkEvent;
exports.ISegmentFetcherEvent = segment_1.ISegmentFetcherEvent;
exports.ISegmentFetcherWarning = segment_1.ISegmentFetcherWarning;
exports.ISegmentPipelineManagerOptions = segment_1.ISegmentPipelineManagerOptions;
},{"./manifest":"../../../core/pipelines/manifest/index.ts","./segment":"../../../core/pipelines/segment/index.ts"}],"apis/publicApi/offlineDownload.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2019 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var dash_1 = __importDefault(require("../../../../../transports/dash"));

var smooth_1 = __importDefault(require("../../../../../transports/smooth"));

var pipelines_1 = require("../../../../../core/pipelines");
/**
 * Launch the pipeline by url
 *
 * @param manifestURL - Manifest url on the web
 * @param transport - Transport that need to be use.
 * @returns The rxpManifest ready to be inserted in IndexDB
 *
 */


function manifestLoader(manifestURL) {
  var transport = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "dash";
  var pipelineTypes = {
    "smooth": smooth_1.default,
    "dash": dash_1.default
  };
  var transportPipelines = pipelineTypes[transport]({
    lowLatencyMode: false
  });
  var manifestPipeline = pipelines_1.createManifestPipeline(transportPipelines, {
    lowLatencyMode: false,
    manifestRetry: 5,
    offlineRetry: 5
  }, new rxjs_1.Subject());
  return manifestPipeline.fetch(manifestURL).pipe(operators_1.mergeMap(function (response) {
    return manifestPipeline.parse(response.value, manifestURL).pipe(operators_1.map(function (_ref) {
      var manifest = _ref.manifest;
      return manifest;
    }));
  }));
}

exports.manifestLoader = manifestLoader;
/**
 * Returns the structure of the manifest needed by the rxPlayer transport local.
 *
 * @remarks
 * It's mandatory to construct again the rxpManifest
 * when the user want it because we can't insert function type in IndexDB
 *
 * @param ILocalManifestOnline - The rxpManifest we downloaded when online
 * @returns The manifest that the rxPlayer expect
 *
 */

function offlineManifestLoader(rxpManifestOnlineFormat, db) {
  return Object.assign(Object.assign({}, rxpManifestOnlineFormat), {
    type: 'local',
    periods: rxpManifestOnlineFormat.periods.map(function (period) {
      return Object.assign(Object.assign({}, period), {
        adaptations: period.adaptations.map(function (adaptation) {
          return Object.assign(Object.assign({}, adaptation), {
            type: adaptation.type,
            representations: adaptation.representations.map(function (representation) {
              return Object.assign(Object.assign({}, representation), {
                index: {
                  loadInitSegment: function loadInitSegment(_ref2) {
                    var resolve = _ref2.resolve,
                        reject = _ref2.reject;

                    if (representation.index.init) {
                      db.get("segments", representation.index.init).then(function (segmentIndex) {
                        if (!segmentIndex) {
                          reject(new Error("Segment not found"));
                          return;
                        }

                        resolve({
                          data: segmentIndex.data
                        });
                        return;
                      }).catch(function (err) {
                        reject(err);
                      });
                      return;
                    }

                    resolve({
                      data: null
                    });
                    return;
                  },
                  loadSegment: function loadSegment(segmentID, _ref3) {
                    var resolve = _ref3.resolve,
                        reject = _ref3.reject;
                    db.get("segments", segmentID).then(function (segment) {
                      if (!segment) {
                        reject(new Error("Segment not found"));
                        return;
                      }

                      resolve({
                        data: segment.data
                      });
                      return;
                    }).catch(function (err) {
                      reject(err);
                    });
                  },
                  segments: representation.index.segments.map(function (segment) {
                    if (!Array.isArray(segment)) {
                      return {
                        duration: 0,
                        time: 0,
                        timescale: 0
                      };
                    }

                    var _segment = _slicedToArray(segment, 4),
                        time = _segment[1],
                        timescale = _segment[2],
                        duration = _segment[3];

                    return {
                      duration: duration,
                      time: time,
                      timescale: timescale
                    };
                  })
                }
              });
            })
          });
        })
      });
    })
  });
}

exports.offlineManifestLoader = offlineManifestLoader;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../../../../transports/dash":"../../../transports/dash/index.ts","../../../../../transports/smooth":"../../../transports/smooth/index.ts","../../../../../core/pipelines":"../../../core/pipelines/index.ts"}],"apis/dash/dashConnectivity.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2019 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var request_1 = __importDefault(require("../../../../../utils/request"));

var utils_1 = require("../../utils");
/**
 * Get a segment from a server.
 *
 * @param ISidxSegment - SIDX or ISegment Segment information
 * @param url - base url of the segment
 * @returns The data,duration,time,timescale of the current segment retrieved
 *
 */


exports.getSegmentBuffer = function (_ref) {
  var segment = _ref.segment,
      url = _ref.url,
      type = _ref.type;

  if (type === "BaseRepresentationIndex") {
    if (!url) {
      throw new utils_1.SegmentConstuctionError("The mediaURL is not defined for the given representation segment");
    }

    var range = segment.range,
        duration = segment.duration,
        timescale = segment.timescale,
        time = segment.time;
    return request_1.default({
      url: url,
      headers: {
        Range: "bytes=".concat(range.join("-"))
      },
      responseType: "arraybuffer"
    }).pipe(operators_1.map(function (_ref2) {
      var value = _ref2.value;
      return {
        data: value.responseData,
        duration: duration,
        time: time,
        timescale: timescale
      };
    }));
  } else {
    var mediaURL = segment.mediaURL,
        _segment$duration = segment.duration,
        _duration = _segment$duration === void 0 ? 0 : _segment$duration,
        _timescale = segment.timescale,
        _time = segment.time;

    return request_1.default({
      url: mediaURL || "",
      responseType: "arraybuffer"
    }).pipe(operators_1.map(function (_ref3) {
      var value = _ref3.value;
      return {
        data: value.responseData,
        duration: _duration,
        time: _time,
        timescale: _timescale
      };
    }));
  }
};
/**
 * A simple manager observable that either get the segment
 * if is not already built or skip to the next one.
 *
 * @param segmentBuilder - Either a SegmentBuilt type or a ISegmentBuilder
 * @param optionBuilder - Emitter and db instances
 * @returns An Observable of the SegmentBuilt
 *
 */


exports.createSegment = function (segmentBuilder, optionBuilder) {
  var segment = segmentBuilder.segment,
      utils = segmentBuilder.utils;
  return exports.getSegmentBuffer({
    segment: segment,
    type: utils.type,
    url: utils.url
  }).pipe(operators_1.mergeMap(function (_ref4) {
    var data = _ref4.data,
        duration = _ref4.duration,
        timescale = _ref4.timescale,
        time = _ref4.time;
    var sizePerBuffer = data.byteLength;

    var _utils$segmentKey = _slicedToArray(utils.segmentKey, 1),
        segmentKey = _utils$segmentKey[0];

    optionBuilder.db.put("segments", {
      contentID: utils.contentID,
      data: data,
      segmentKey: segmentKey,
      size: sizePerBuffer,
      duration: duration
    }).catch(rxjs_1.throwError);

    if (optionBuilder.progressBarBuilder$) {
      optionBuilder.progressBarBuilder$.next({
        id: utils.id,
        segmentDownloaded: 1,
        size: sizePerBuffer
      });
    }

    return rxjs_1.of([utils.segmentKey, time, timescale, duration]);
  }));
};
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../../../../utils/request":"../../../utils/request/index.ts","../../utils":"utils.ts"}],"apis/dash/types.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2019 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var Quality;

(function (Quality) {
  Quality["HIGH"] = "HIGH";
  Quality["MEDIUM"] = "MEDIUM";
  Quality["LOW"] = "LOW";
})(Quality = exports.Quality || (exports.Quality = {}));
},{}],"apis/dash/dashTools.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2019 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var array_find_1 = __importDefault(require("../../../../../utils/array_find"));

var utils_1 = require("../../utils");

var types_1 = require("../dash/types");
/**
 * A tool function to choose quality depending of what we receive
 *
 * @remarks
 * This function, try to define what quality we should use by either:
 * - determining the exact quality we want
 * - determine the quality by telling to get the HIGHEST, MEDIUM or LOWEST quality
 *
 * @param IParsedRepresentation[] - The representation video of the current
 * parsed dash content
 * @param currentTypeAdaptation - The current type of the adapation we are currently on.
 * @param quality - The quality we want to choose, either a exact number or
 * HIGH,MEDIUM,LOW
 * @returns The representation that correspond to the quality wanted
 *
 */


exports.chooseVideoQuality = function (representations, currentTypeAdaptation, quality) {
  if (currentTypeAdaptation !== "video") {
    return representations;
  }

  if (!representations || representations.length === 0) {
    throw new utils_1.SegmentConstuctionError("No representations video found");
  }

  if (Array.isArray(quality)) {
    var _quality = _slicedToArray(quality, 2),
        widthWanted = _quality[0],
        heightWanted = _quality[1];

    var reprensentationQuality = array_find_1.default(representations, function (_ref) {
      var width = _ref.width,
          height = _ref.height;
      return width === widthWanted && height === heightWanted;
    });

    if (reprensentationQuality) {
      return [reprensentationQuality];
    }
  }

  var sortedRepresentationsByDESC = representations.sort(function (a, b) {
    return b.height && a.height ? b.height - a.height : 0;
  });

  switch (quality) {
    case types_1.Quality.HIGH:
      return [sortedRepresentationsByDESC[0]];

    case types_1.Quality.MEDIUM:
      return [sortedRepresentationsByDESC[Math.floor(sortedRepresentationsByDESC.length / 2)]];

    case types_1.Quality.LOW:
      return [sortedRepresentationsByDESC[sortedRepresentationsByDESC.length - 1]];

    default:
      return [sortedRepresentationsByDESC[Math.floor(sortedRepresentationsByDESC.length / 2)]];
  }
};
/**
 * An operator that take a Observable in parameter that
 * is emitting a progress status. Then, decide when to emit next manifest.
 *
 * @param progress$ - An Observable under the form ProgressBarBuilder type
 * @returns - An Observable
 *
 */


function emitEveryNth(progress$, utilsBuilder, contentID, pause$) {
  return function (source$) {
    var storeManifestEvery = utilsBuilder.storeManifestEvery,
        emitter = utilsBuilder.emitter;
    return new rxjs_1.Observable(function (obs) {
      var progressFiltered$ = progress$.pipe(operators_1.mergeMap(function (_a) {
        var progress = _a.progress,
            props = __rest(_a, ["progress"]);

        return rxjs_1.of(Object.assign({
          progress: progress > 98 && progress < 100 ? progress : Math.round(progress)
        }, props));
      }), operators_1.distinctUntilKeyChanged("progress"));
      var builder$ = rxjs_1.combineLatest([source$, progressFiltered$]).pipe(operators_1.distinctUntilChanged(function (_ref2, _ref3) {
        var _ref4 = _slicedToArray(_ref2, 2),
            _ = _ref4[0],
            prevProgress = _ref4[1].progress;

        var _ref5 = _slicedToArray(_ref3, 2),
            __ = _ref5[0],
            currProgress = _ref5[1].progress;

        return prevProgress === currProgress;
      }), operators_1.tap(function (builder) {
        var _builder = _slicedToArray(builder, 2),
            _builder$ = _builder[1],
            status = _builder$.status,
            progress = _builder$.progress,
            size = _builder$.size;

        emitter.trigger("progress", {
          contentID: contentID,
          progress: progress,
          size: size,
          status: status
        });
      }), operators_1.share());
      rxjs_1.merge(builder$.pipe(operators_1.filter(function (_ref6) {
        var _ref7 = _slicedToArray(_ref6, 2),
            _ = _ref7[0],
            progress = _ref7[1].progress;

        return storeManifestEvery && typeof storeManifestEvery === "function" ? storeManifestEvery(progress) || progress === 100 : progress % 10 === 0;
      })), pause$).pipe(operators_1.withLatestFrom(builder$)).subscribe(function (_a) {
        var _a2 = _slicedToArray(_a, 2),
            _ = _a2[0],
            _b = _a2[1],
            _b2 = _slicedToArray(_b, 2),
            manifest = _b2[0],
            _c = _b2[1],
            progress = _c.progress,
            status = _c.status,
            props = __rest(_c, ["progress", "status"]);

        obs.next(Object.assign({
          manifest: Object.assign(Object.assign({}, manifest), {
            isFinished: progress === 100
          }),
          progress: props.progressBarBuilder.progress / props.progressBarBuilder.overall * 100
        }, props));
      }, function (err) {
        return obs.error(err);
      }, function () {
        return obs.complete();
      });
    });
  };
}

exports.emitEveryNth = emitEveryNth;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../../../../utils/array_find":"../../../utils/array_find.ts","../../utils":"utils.ts","../dash/types":"apis/dash/types.ts"}],"apis/dash/dashSegmentsBuilder.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2019 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var operators_1 = require("rxjs/operators");

var is_offline_1 = __importDefault(require("../../../../../compat/is_offline"));

var isobmff_1 = require("../../../../../parsers/containers/isobmff");

var array_find_index_1 = __importDefault(require("../../../../../utils/array_find_index"));

var byte_parsing_1 = require("../../../../../utils/byte_parsing");

var promise_1 = __importDefault(require("../../../../../utils/promise"));

var request_1 = __importDefault(require("../../../../../utils/request"));

var utils_1 = require("../../utils");

var keySystems_1 = __importDefault(require("../drm/keySystems"));

var offlineDownload_1 = require("../publicApi/offlineDownload");

var dashConnectivity_1 = require("./dashConnectivity");

var dashTools_1 = require("./dashTools");
/**
 * Build the init segments
 *
 * @param IRepresentationIndex - index segment we use to build segments
 * @param ILoaderBuilder - variables we need to create a Loader
 * @param IUtils - Utils to stock and emit
 * @returns An Observable of the segments freshly constructed
 *
 */


exports.buildInitSegments = function (index, loaderBuilder, utilsBuilder) {
  var Segment = index.getInitSegment();

  if (!Segment) {
    throw new utils_1.SegmentConstuctionError('Impossible to get the init segment');
  }

  var id = loaderBuilder.id,
      contentID = loaderBuilder.contentID,
      durationCurrPeriod = loaderBuilder.duration;
  var db = utilsBuilder.db,
      emitter = utilsBuilder.emitter,
      progressBarBuilder$ = utilsBuilder.progressBarBuilder$;
  return getInitSegments(Segment).pipe(operators_1.mergeMap(function (segmentData) {
    var dataInit = segmentData.dataInit,
        _segmentData$nextSegm = segmentData.nextSegmentsRanges,
        nextSegmentsRanges = _segmentData$nextSegm === void 0 ? index.getSegments(0, durationCurrPeriod) : _segmentData$nextSegm,
        type = segmentData.type,
        mediaURL = segmentData.mediaURL,
        duration = segmentData.duration;

    if (!nextSegmentsRanges) {
      throw new utils_1.SegmentConstuctionError('Error when parsing Segments index box');
    }

    if (!durationCurrPeriod && type === 'TemplateRepresentationIndex') {
      throw new utils_1.SegmentConstuctionError("Error during the contruction of segments,\
          no duration of the current period given because \
          it's a TemplateRepresentationIndex");
    }

    if (progressBarBuilder$) {
      progressBarBuilder$.next({
        id: id,
        segmentDownloaded: 0,
        totalSegments: nextSegmentsRanges.length
      });
    }

    if (loaderBuilder.keySystemsOptions && loaderBuilder.type === 'video') {
      return keySystems_1.default(loaderBuilder.keySystemsOptions, {
        codec: loaderBuilder.codecs || '',
        contentID: contentID,
        initSegment: dataInit,
        storageUtils: {
          emitter: emitter,
          db: db,
          progressBarBuilder$: progressBarBuilder$
        }
      }).pipe(operators_1.mergeMap(function () {
        return rxjs_1.from(db.put('segments', {
          contentID: contentID,
          data: dataInit,
          duration: duration,
          segmentKey: "".concat(id, "--").concat(contentID, "--init"),
          size: dataInit.byteLength
        })).pipe(operators_1.map(function (key) {
          if (typeof key !== 'string') {
            throw new Error("Invalid Key for init segment: ".concat(key));
          }

          var segmentsBuilder = [];

          for (var i = 0; i < nextSegmentsRanges.length; i++) {
            segmentsBuilder.push({
              segment: nextSegmentsRanges[i],
              utils: {
                contentID: contentID,
                id: id,
                segmentKey: ["".concat(id, "--").concat(contentID, "--").concat(i), i],
                type: type,
                url: mediaURL || ''
              }
            });
          }

          return {
            init: key,
            segments: segmentsBuilder
          };
        }));
      }));
    }

    return rxjs_1.from(db.put('segments', {
      contentID: contentID,
      data: dataInit,
      duration: duration,
      segmentKey: "".concat(id, "--").concat(contentID, "--init"),
      size: dataInit.byteLength
    })).pipe(operators_1.map(function (key) {
      if (typeof key !== 'string') {
        throw new Error("Invalid Key for init segment: ".concat(key));
      }

      var segmentsBuilder = [];

      for (var i = 0; i < nextSegmentsRanges.length; i++) {
        segmentsBuilder.push({
          segment: nextSegmentsRanges[i],
          utils: {
            contentID: contentID,
            id: id,
            segmentKey: ["".concat(id, "--").concat(contentID, "--").concat(i), i],
            type: type,
            url: mediaURL || ''
          }
        });
      }

      return {
        init: key,
        segments: segmentsBuilder
      };
    }));
  }));
};
/**
 * Get the init segments buffer from a server
 *
 * @param ISegment - index segment we use to build segments
 * @returns An Observable of init segment get on the server
 *
 */


var getInitSegments = function getInitSegments(Segment) {
  var indexRange = Segment.indexRange,
      range = Segment.range,
      mediaURL = Segment.mediaURL,
      _Segment$duration = Segment.duration,
      duration = _Segment$duration === void 0 ? 0 : _Segment$duration;

  if (indexRange && range) {
    return rxjs_1.forkJoin({
      initSegment: request_1.default({
        url: mediaURL || '',
        headers: {
          Range: "bytes=".concat(range.join('-'))
        },
        responseType: 'arraybuffer'
      }).pipe(operators_1.map(function (_ref) {
        var value = _ref.value;
        return value.responseData;
      })),
      indexSegment: request_1.default({
        url: mediaURL || '',
        headers: {
          Range: "bytes=".concat(indexRange.join('-'))
        },
        responseType: 'arraybuffer'
      }).pipe(operators_1.map(function (_ref2) {
        var value = _ref2.value;
        return value.responseData;
      }))
    }).pipe(operators_1.mergeMap(function (_ref3) {
      var initSegment = _ref3.initSegment,
          indexSegment = _ref3.indexSegment;
      var dataInit = byte_parsing_1.concat(new Uint8Array(initSegment), new Uint8Array(indexSegment));
      var nextSegmentsRanges = isobmff_1.getSegmentsFromSidx(dataInit, indexRange ? indexRange[0] : 0);
      return rxjs_1.of({
        dataInit: dataInit,
        duration: duration,
        mediaURL: mediaURL,
        nextSegmentsRanges: nextSegmentsRanges,
        type: 'BaseRepresentationIndex'
      });
    }));
  }

  return request_1.default({
    url: mediaURL || '',
    responseType: 'arraybuffer'
  }).pipe(operators_1.map(function (_ref4) {
    var value = _ref4.value;
    return {
      dataInit: value.responseData,
      mediaURL: mediaURL,
      type: 'TemplateRepresentationIndex'
    };
  }));
};
/**
 * A download manager that take all the representations to execute them
 * concurrently and tranform a Segment non built into a segment built
 *
 * @param utilsBuilder - Emitter and db instances
 * @param progress$ - A Subject observable to emit related with the progress percentage
 * @param pause$ - A Subject observable to emit when the user pause the download
 * @param contentID - A string that define the content id of the current download
 * @returns An Observable of rxpManifest flow
 *
 */


exports.downloadManager = function (utilsBuilder, progress$, pause$, contentID) {
  return function (source$) {
    return source$.pipe(operators_1.concatMap(function (manifest) {
      if (!manifest) {
        return rxjs_1.from([]);
      }

      return rxjs_1.from(manifest.periods).pipe(operators_1.concatMap(function (period) {
        return rxjs_1.from(period.adaptations).pipe(operators_1.mergeMap(function (adaptation) {
          return rxjs_1.from(adaptation.representations).pipe(operators_1.mergeMap(function (representation) {
            return rxjs_1.from(representation.index.segments).pipe(operators_1.concatMap(function (segment) {
              if (Array.isArray(segment)) {
                return rxjs_1.of(segment);
              }

              return dashConnectivity_1.createSegment(segment, utilsBuilder).pipe(operators_1.retry(2));
            }), operators_1.map(function (segmentBuilt) {
              var _segmentBuilt = _slicedToArray(segmentBuilt, 1),
                  _segmentBuilt$ = _slicedToArray(_segmentBuilt[0], 2),
                  i = _segmentBuilt$[1];

              representation.index.segments[i] = segmentBuilt;
              return segmentBuilt;
            }));
          }, adaptation.representations.length));
        }, period.adaptations.length), operators_1.takeUntil(pause$));
      }), operators_1.map(function () {
        return manifest;
      }));
    }), dashTools_1.emitEveryNth(progress$, utilsBuilder, contentID, pause$));
  };
};
/**
 * A subscription manager that take care to choose between a start and a resume download
 *
 * @param IDownloaderManagerAbstract - Download manager need
 * @param IUtils- Some variables we need to emit and insert in DB
 * @returns The Subscription
 *
 */


function downloadManagerSubscription(_ref5, _ref6) {
  var settings = _ref5.settings,
      activeSubsDownloader = _ref5.activeSubsDownloader,
      progress$ = _ref5.progress$,
      pause$ = _ref5.pause$,
      progressSetupUnsubFn = _ref5.progressSetupUnsubFn;
  var db = _ref6.db,
      emitter = _ref6.emitter,
      storeManifestEvery = _ref6.storeManifestEvery,
      progressBarBuilder$ = _ref6.progressBarBuilder$;
  var metaData = settings.type === 'start' ? settings.dbSettings.metaData : settings.metaData;
  var contentID = settings.type === 'start' ? settings.dbSettings.contentID : settings.contentID; // console.warn('polo');

  var downloadManagerSub = (settings.type === "start" ? exports.initAtStart(settings, {
    db: db,
    emitter: emitter,
    progressBarBuilder$: progressBarBuilder$
  }) : rxjs_1.of(settings.rxpManifest)).pipe(exports.downloadManager({
    emitter: emitter,
    db: db,
    storeManifestEvery: storeManifestEvery,
    progressBarBuilder$: progressBarBuilder$
  }, progress$, pause$, contentID)).subscribe(
  /*#__PURE__*/
  function () {
    var _ref7 = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee(_a) {
      var manifest, props;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              manifest = _a.manifest, props = __rest(_a, ["manifest"]);
              _context.next = 3;
              return promise_1.default.all([db.put("manifests", Object.assign(Object.assign({
                contentID: contentID,
                rxpManifest: manifest
              }, metaData && {
                metaData: metaData
              }), props)), emitter.trigger("insertDB", {
                action: "store",
                contentID: contentID,
                progress: props.progress
              })]);

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref7.apply(this, arguments);
    };
  }(), function (err) {
    progressSetupUnsubFn.unsubscribe();
    delete activeSubsDownloader[contentID];

    switch (err.message) {
      case "ERROR_EVENT":
        if (is_offline_1.default()) {
          emitter.trigger("error", {
            action: "download",
            contentID: contentID,
            error: new Error("NETWORK_ERROR")
          });
          return;
        }

      default:
        emitter.trigger("error", {
          action: "download",
          contentID: contentID,
          error: err
        });
        return;
    }
  }, function () {
    progressSetupUnsubFn.unsubscribe();
    delete activeSubsDownloader[contentID];
  });
  return downloadManagerSub;
}

exports.downloadManagerSubscription = downloadManagerSubscription;
/**
 * Create a local manifest type understandable by the manifest loader
 *
 * @returns An Observable of the local manifest type
 *
 */

exports.buildLocalManifest = function () {
  return function (source$) {
    return source$.pipe(operators_1.map(function (parsedManifest) {
      return {
        version: '0.2',
        duration: parsedManifest.getDuration() || 0,
        periods: parsedManifest.periods.map(function (period) {
          return {
            start: period.start,
            duration: period.duration || 0,
            adaptations: Object.keys(period.adaptations).reduce(function (accAdaptation, curr) {
              return accAdaptation.concat(period.adaptations[curr]);
            }, []).map(function (_a) {
              var id = _a.id,
                  adaptation = __rest(_a, ["id"]);

              return Object.assign(Object.assign({}, adaptation), {
                representations: adaptation.representations.map(function (representation) {
                  return Object.assign(Object.assign(Object.assign({
                    bitrate: representation.bitrate,
                    mimeType: representation.mimeType || '',
                    codecs: representation.codecs || ''
                  }, representation.width && {
                    width: representation.width
                  }), representation.height && {
                    height: representation.height
                  }), {
                    index: representation.index
                  });
                })
              });
            })
          };
        }),
        isFinished: false
      };
    }));
  };
};
/**
 * In case of start download type, take all the init segments we need
 *
 * @param ISettingsDownloader - Setting that the user provided
 * @param IUtils - Some variables we need to emit and insert in DB
 * @returns An Observable of Local manifest
 *
 */


exports.initAtStart = function (settings, _ref8) {
  var db = _ref8.db,
      emitter = _ref8.emitter,
      progressBarBuilder$ = _ref8.progressBarBuilder$;
  return offlineDownload_1.manifestLoader(settings.url).pipe(operators_1.concatMap(function (manifest) {
    return rxjs_1.from(manifest.periods).pipe(operators_1.concatMap(function (period) {
      var groupedAdaptation = Object.keys(period.adaptations).reduce(function (acc, curr) {
        return acc.concat(period.adaptations[curr]);
      }, []);
      return rxjs_1.from(groupedAdaptation).pipe(operators_1.mergeMap(function (adaptation) {
        return rxjs_1.from(adaptation.type === 'video' ? dashTools_1.chooseVideoQuality(adaptation.representations, adaptation.type, settings.videoSettings.quality) : adaptation.representations).pipe(operators_1.mergeMap(function (representation) {
          return exports.buildInitSegments(representation.index, {
            codecs: "".concat(representation.mimeType, ";codecs=\"").concat(representation.codecs, "\""),
            contentID: settings.dbSettings.contentID,
            duration: period.duration,
            id: representation.id,
            keySystemsOptions: settings.videoSettings.keySystems,
            type: adaptation.type
          }, {
            db: db,
            emitter: emitter,
            progressBarBuilder$: progressBarBuilder$
          }).pipe(operators_1.retry(2));
        }), operators_1.map(function (segmentInitBuilt) {
          var representations = adaptation.representations;
          var initID = segmentInitBuilt.init.split('--')[0];
          var indexToReplace = array_find_index_1.default(representations, function (representation) {
            return representation.id === initID;
          });
          var indexKey = 'index';
          representations[indexToReplace][indexKey] = segmentInitBuilt;

          if (adaptation.type === 'video') {
            var representationToKeep = representations.filter(function (_, index) {
              return representations[index].id === adaptation.representations[indexToReplace].id;
            });
            adaptation.representations = representationToKeep;
          }

          return segmentInitBuilt;
        }));
      }));
    }), operators_1.map(function () {
      return manifest;
    }));
  }), operators_1.last(), exports.buildLocalManifest());
};
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","rxjs/operators":"../../../../node_modules/rxjs/_esm5/operators/index.js","../../../../../compat/is_offline":"../../../compat/is_offline.ts","../../../../../parsers/containers/isobmff":"../../../parsers/containers/isobmff/index.ts","../../../../../utils/array_find_index":"../../../utils/array_find_index.ts","../../../../../utils/byte_parsing":"../../../utils/byte_parsing.ts","../../../../../utils/promise":"../../../utils/promise.ts","../../../../../utils/request":"../../../utils/request/index.ts","../../utils":"utils.ts","../drm/keySystems":"apis/drm/keySystems.ts","../publicApi/offlineDownload":"apis/publicApi/offlineDownload.ts","./dashConnectivity":"apis/dash/dashConnectivity.ts","./dashTools":"apis/dash/dashTools.ts"}],"apis/publicApi/download.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2019 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var utils_1 = require("../../utils");

var dashSegmentsBuilder_1 = require("../dash/dashSegmentsBuilder");
/**
 * A downloader that instanciate the event api and launch the downloadManager
 *
 * @param settings -
 * The settings that need the download manager depending if we are in resume or start mode
 * @param progressBuilderAssets -
 * The progressBuilder variables that are needed to construct the progress percentage
 * @param utils - Emitter and db instances
 * @returns The subscription of the observable
 *
 */


function downloader(settings, progressBuilderAssets, _ref) {
  var db = _ref.db,
      emitter = _ref.emitter,
      storeManifestEvery = _ref.storeManifestEvery;
  var progressBarBuilder = progressBuilderAssets.progressBarBuilder,
      progress$ = progressBuilderAssets.progress$,
      pause$ = progressBuilderAssets.pause$,
      activeSubsDownloader = progressBuilderAssets.activeSubsDownloader;
  var size = progressBuilderAssets.size;
  var contentID = settings.type === "start" ? settings.dbSettings.contentID : settings.contentID;
  var progressBarBuilder$ = new rxjs_1.Subject();
  var progressSetupUnsubFn = progressBarBuilder$.subscribe(function (loaderBuilder) {
    utils_1.progressBuilder(loaderBuilder, progressBarBuilder);
    var progressInPercent = progressBarBuilder.progress / progressBarBuilder.overall * 100;
    progress$.next({
      progress: progressInPercent,
      progressBarBuilder: progressBarBuilder,
      size: loaderBuilder.size ? size += loaderBuilder.size : size += 0,
      status: loaderBuilder.segmentDownloaded === 0 ? "counting" : "processing"
    });

    if (progressInPercent === 100) {
      progressBarBuilder$.complete();
    }
  }, function (err) {
    emitter.trigger("error", {
      action: "download",
      contentID: contentID,
      error: err
    });
  }, function () {
    return progress$.complete();
  });
  var downloaderManagerSub = dashSegmentsBuilder_1.downloadManagerSubscription({
    activeSubsDownloader: activeSubsDownloader,
    pause$: pause$,
    progress$: progress$,
    progressSetupUnsubFn: progressSetupUnsubFn,
    settings: settings
  }, {
    emitter: emitter,
    db: db,
    storeManifestEvery: storeManifestEvery,
    progressBarBuilder$: progressBarBuilder$
  });
  return downloaderManagerSub;
}

exports.downloader = downloader;
},{"rxjs":"../../../../node_modules/rxjs/_esm5/index.js","../../utils":"utils.ts","../dash/dashSegmentsBuilder":"apis/dash/dashSegmentsBuilder.ts"}],"../../../../node_modules/idb/build/esm/chunk.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.a = wrap;
exports.b = addTraps;
exports.e = exports.d = exports.c = void 0;

const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);

exports.c = instanceOfAny;
let idbProxyableTypes;
let cursorAdvanceMethods; // This is a function to prevent it throwing up in node environments.

function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);
} // This is a function to prevent it throwing up in node environments.


function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);
}

const cursorRequestMap = new WeakMap();
const transactionDoneMap = new WeakMap();
const transactionStoreNamesMap = new WeakMap();
const transformCache = new WeakMap();
const reverseTransformCache = new WeakMap();
exports.d = reverseTransformCache;

function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener('success', success);
      request.removeEventListener('error', error);
    };

    const success = () => {
      resolve(wrap(request.result));
      unlisten();
    };

    const error = () => {
      reject(request.error);
      unlisten();
    };

    request.addEventListener('success', success);
    request.addEventListener('error', error);
  });
  promise.then(value => {
    // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval
    // (see wrapFunction).
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }); // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This
  // is because we create many promises from a single IDBRequest.

  reverseTransformCache.set(promise, request);
  return promise;
}

function cacheDonePromiseForTransaction(tx) {
  // Early bail if we've already created a done promise for this transaction.
  if (transactionDoneMap.has(tx)) return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener('complete', complete);
      tx.removeEventListener('error', error);
      tx.removeEventListener('abort', error);
    };

    const complete = () => {
      resolve();
      unlisten();
    };

    const error = () => {
      reject(tx.error);
      unlisten();
    };

    tx.addEventListener('complete', complete);
    tx.addEventListener('error', error);
    tx.addEventListener('abort', error);
  }); // Cache it for later retrieval.

  transactionDoneMap.set(tx, done);
}

let idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      // Special handling for transaction.done.
      if (prop === 'done') return transactionDoneMap.get(target); // Polyfill for objectStoreNames because of Edge.

      if (prop === 'objectStoreNames') {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      } // Make tx.store return the only store in the transaction, or undefined if there are many.


      if (prop === 'store') {
        return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    } // Else transform whatever we get back.


    return wrap(target[prop]);
  },

  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) return true;
    return prop in target;
  }

};

function addTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}

function wrapFunction(func) {
  // Due to expected object equality (which is enforced by the caching in `wrap`), we
  // only create one new func per func.
  // Edge doesn't support objectStoreNames (booo), so we polyfill it here.
  if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {
    return function (storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  } // Cursor methods are special, as the behaviour is a little more different to standard IDB. In
  // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the
  // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense
  // with real promises, so each advance methods returns a new promise for the cursor object, or
  // undefined if the end of the cursor has been reached.


  if (getCursorAdvanceMethods().includes(func)) {
    return function (...args) {
      // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
      // the original object.
      func.apply(unwrap(this), args);
      return wrap(cursorRequestMap.get(this));
    };
  }

  return function (...args) {
    // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
    // the original object.
    return wrap(func.apply(unwrap(this), args));
  };
}

function transformCachableValue(value) {
  if (typeof value === 'function') return wrapFunction(value); // This doesn't return, it just creates a 'done' promise for the transaction,
  // which is later returned for transaction.done (see idbObjectHandler).

  if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps); // Return the same value back if we're not going to transform it.

  return value;
}

function wrap(value) {
  // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because
  // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.
  if (value instanceof IDBRequest) return promisifyRequest(value); // If we've already transformed this value before, reuse the transformed value.
  // This is faster, but it also provides object equality.

  if (transformCache.has(value)) return transformCache.get(value);
  const newValue = transformCachableValue(value); // Not all types are transformed.
  // These may be primitive types, so they can't be WeakMap keys.

  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }

  return newValue;
}

const unwrap = value => reverseTransformCache.get(value);

exports.e = unwrap;
},{}],"../../../../node_modules/idb/build/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.openDB = openDB;
exports.deleteDB = deleteDB;
Object.defineProperty(exports, "unwrap", {
  enumerable: true,
  get: function () {
    return _chunk.e;
  }
});
Object.defineProperty(exports, "wrap", {
  enumerable: true,
  get: function () {
    return _chunk.a;
  }
});

var _chunk = require("./chunk.js");

/**
 * Open a database.
 *
 * @param name Name of the database.
 * @param version Schema version.
 * @param callbacks Additional callbacks.
 */
function openDB(name, version, {
  blocked,
  upgrade,
  blocking
} = {}) {
  const request = indexedDB.open(name, version);
  const openPromise = (0, _chunk.a)(request);

  if (upgrade) {
    request.addEventListener('upgradeneeded', event => {
      upgrade((0, _chunk.a)(request.result), event.oldVersion, event.newVersion, (0, _chunk.a)(request.transaction));
    });
  }

  if (blocked) request.addEventListener('blocked', () => blocked());
  if (blocking) openPromise.then(db => db.addEventListener('versionchange', blocking));
  return openPromise;
}
/**
 * Delete a database.
 *
 * @param name Name of the database.
 */


function deleteDB(name, {
  blocked
} = {}) {
  const request = indexedDB.deleteDatabase(name);
  if (blocked) request.addEventListener('blocked', () => blocked());
  return (0, _chunk.a)(request).then(() => undefined);
}

const readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];
const writeMethods = ['put', 'add', 'delete', 'clear'];
const cachedMethods = new Map();

function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) return;
  if (cachedMethods.get(prop)) return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, '');
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if ( // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
  !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) return;

  const method = async function (storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');
    let target = tx.store;
    if (useIndex) target = target.index(args.shift());
    const returnVal = target[targetFuncName](...args);
    if (isWrite) await tx.done;
    return returnVal;
  };

  cachedMethods.set(prop, method);
  return method;
}

(0, _chunk.b)(oldTraps => ({
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));
},{"./chunk.js":"../../../../node_modules/idb/build/esm/chunk.js"}],"apis/transactionDB/dbSetUp.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2019 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var idb_1 = require("idb");

var utils_1 = require("../../utils");
/**
 * A very short function to know if IndexDB is supported by the current browser.
 *
 * @returns Wether or not IndexDB is supported
 *
 */


exports.isIndexDBSupported = function () {
  return "indexedDB" in window;
};
/**
 * Set up IndexDB with few checks and creating table
 *
 * @returns The IndexDB object
 *
 */


function setUpDb(nameDB) {
  if (!exports.isIndexDBSupported()) {
    throw new utils_1.IndexDBError("IndexDB is not supported in your browser");
  }

  try {
    return idb_1.openDB(nameDB, 1, {
      upgrade: function upgrade(db) {
        db.createObjectStore("manifests", {
          keyPath: "contentID"
        });
        var segmentObjectStore = db.createObjectStore("segments", {
          keyPath: "segmentKey"
        });
        db.createObjectStore("drm", {
          keyPath: "contentID"
        });
        segmentObjectStore.createIndex("contentID", "contentID", {
          unique: false
        });
      }
    });
  } catch (e) {
    throw new utils_1.IndexDBError(e.message);
  }
}

exports.setUpDb = setUpDb;
},{"idb":"../../../../node_modules/idb/build/esm/index.js","../../utils":"utils.ts"}],"index.ts":[function(require,module,exports) {
"use strict";
/**
 * Copyright 2019 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require("core-js/modules/es6.array.copy-within");

require("core-js/modules/es6.array.fill");

require("core-js/modules/es6.array.find");

require("core-js/modules/es6.array.find-index");

require("core-js/modules/es6.array.from");

require("core-js/modules/es7.array.includes");

require("core-js/modules/es6.array.iterator");

require("core-js/modules/es6.array.of");

require("core-js/modules/es6.array.sort");

require("core-js/modules/es6.array.species");

require("core-js/modules/es6.date.to-json");

require("core-js/modules/es6.date.to-primitive");

require("core-js/modules/es6.function.has-instance");

require("core-js/modules/es6.function.name");

require("core-js/modules/es6.map");

require("core-js/modules/es6.math.acosh");

require("core-js/modules/es6.math.asinh");

require("core-js/modules/es6.math.atanh");

require("core-js/modules/es6.math.cbrt");

require("core-js/modules/es6.math.clz32");

require("core-js/modules/es6.math.cosh");

require("core-js/modules/es6.math.expm1");

require("core-js/modules/es6.math.fround");

require("core-js/modules/es6.math.hypot");

require("core-js/modules/es6.math.imul");

require("core-js/modules/es6.math.log1p");

require("core-js/modules/es6.math.log10");

require("core-js/modules/es6.math.log2");

require("core-js/modules/es6.math.sign");

require("core-js/modules/es6.math.sinh");

require("core-js/modules/es6.math.tanh");

require("core-js/modules/es6.math.trunc");

require("core-js/modules/es6.number.constructor");

require("core-js/modules/es6.number.epsilon");

require("core-js/modules/es6.number.is-finite");

require("core-js/modules/es6.number.is-integer");

require("core-js/modules/es6.number.is-nan");

require("core-js/modules/es6.number.is-safe-integer");

require("core-js/modules/es6.number.max-safe-integer");

require("core-js/modules/es6.number.min-safe-integer");

require("core-js/modules/es6.number.parse-float");

require("core-js/modules/es6.number.parse-int");

require("core-js/modules/es6.object.assign");

require("core-js/modules/es7.object.define-getter");

require("core-js/modules/es7.object.define-setter");

require("core-js/modules/es7.object.entries");

require("core-js/modules/es6.object.freeze");

require("core-js/modules/es6.object.get-own-property-descriptor");

require("core-js/modules/es7.object.get-own-property-descriptors");

require("core-js/modules/es6.object.get-own-property-names");

require("core-js/modules/es6.object.get-prototype-of");

require("core-js/modules/es7.object.lookup-getter");

require("core-js/modules/es7.object.lookup-setter");

require("core-js/modules/es6.object.prevent-extensions");

require("core-js/modules/es6.object.is");

require("core-js/modules/es6.object.is-frozen");

require("core-js/modules/es6.object.is-sealed");

require("core-js/modules/es6.object.is-extensible");

require("core-js/modules/es6.object.keys");

require("core-js/modules/es6.object.seal");

require("core-js/modules/es6.object.set-prototype-of");

require("core-js/modules/es7.object.values");

require("core-js/modules/es6.promise");

require("core-js/modules/es7.promise.finally");

require("core-js/modules/es6.reflect.apply");

require("core-js/modules/es6.reflect.construct");

require("core-js/modules/es6.reflect.define-property");

require("core-js/modules/es6.reflect.delete-property");

require("core-js/modules/es6.reflect.get");

require("core-js/modules/es6.reflect.get-own-property-descriptor");

require("core-js/modules/es6.reflect.get-prototype-of");

require("core-js/modules/es6.reflect.has");

require("core-js/modules/es6.reflect.is-extensible");

require("core-js/modules/es6.reflect.own-keys");

require("core-js/modules/es6.reflect.prevent-extensions");

require("core-js/modules/es6.reflect.set");

require("core-js/modules/es6.reflect.set-prototype-of");

require("core-js/modules/es6.regexp.constructor");

require("core-js/modules/es6.regexp.flags");

require("core-js/modules/es6.regexp.match");

require("core-js/modules/es6.regexp.replace");

require("core-js/modules/es6.regexp.split");

require("core-js/modules/es6.regexp.search");

require("core-js/modules/es6.regexp.to-string");

require("core-js/modules/es6.set");

require("core-js/modules/es6.symbol");

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.string.anchor");

require("core-js/modules/es6.string.big");

require("core-js/modules/es6.string.blink");

require("core-js/modules/es6.string.bold");

require("core-js/modules/es6.string.code-point-at");

require("core-js/modules/es6.string.ends-with");

require("core-js/modules/es6.string.fixed");

require("core-js/modules/es6.string.fontcolor");

require("core-js/modules/es6.string.fontsize");

require("core-js/modules/es6.string.from-code-point");

require("core-js/modules/es6.string.includes");

require("core-js/modules/es6.string.italics");

require("core-js/modules/es6.string.iterator");

require("core-js/modules/es6.string.link");

require("core-js/modules/es7.string.pad-start");

require("core-js/modules/es7.string.pad-end");

require("core-js/modules/es6.string.raw");

require("core-js/modules/es6.string.repeat");

require("core-js/modules/es6.string.small");

require("core-js/modules/es6.string.starts-with");

require("core-js/modules/es6.string.strike");

require("core-js/modules/es6.string.sub");

require("core-js/modules/es6.string.sup");

require("core-js/modules/es6.typed.array-buffer");

require("core-js/modules/es6.typed.int8-array");

require("core-js/modules/es6.typed.uint8-array");

require("core-js/modules/es6.typed.uint8-clamped-array");

require("core-js/modules/es6.typed.int16-array");

require("core-js/modules/es6.typed.uint16-array");

require("core-js/modules/es6.typed.int32-array");

require("core-js/modules/es6.typed.uint32-array");

require("core-js/modules/es6.typed.float32-array");

require("core-js/modules/es6.typed.float64-array");

require("core-js/modules/es6.weak-map");

require("core-js/modules/es6.weak-set");

require("core-js/modules/es7.array.flat-map");

require("core-js/modules/web.timers");

require("core-js/modules/web.immediate");

require("core-js/modules/web.dom.iterable");

require("regenerator-runtime/runtime");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rxjs_1 = require("rxjs");

var download_1 = require("./apis/publicApi/download");

var offlineDownload_1 = require("./apis/publicApi/offlineDownload");

var dbSetUp_1 = require("./apis/transactionDB/dbSetUp");

var utils_1 = require("./utils");

var event_emitter_1 = __importDefault(require("../../../utils/event_emitter"));

var promise_1 = __importDefault(require("../../../utils/promise"));
/**
 * Instanciate a D2G downloader.
 * @param {Object<{nameDB, storeManifestEvery}>} IOptionsStarter
 * @return {IPublicAPI} IPublicAPI
 */


var D2G =
/*#__PURE__*/
function (_event_emitter_1$defa) {
  _inherits(D2G, _event_emitter_1$defa);

  function D2G() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, D2G);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(D2G).call(this));
    _this.nameDB = options.nameDB || "d2g";
    _this.storeManifestEvery = options.storeManifestEvery;
    _this.activeSubsDownloader = {};
    _this.activePauseSubject = {};
    _this.emitter = {
      trigger: function trigger(eventName, payload) {
        return _this.trigger(eventName, payload);
      }
    };
    return _this;
  }
  /**
   * An init function that you MUST use to instanciate the D2G.
   * https://stackoverflow.com/a/43433773/6826962
   *
   * @param  {Object<{nameDB, storeManifestEvery}>} IOptionsStarter
   * @returns {Promise.<D2G>}
   */


  _createClass(D2G, [{
    key: "setUp",

    /**
     * Setup async stuff.
     * @param {nameDB} string
     * @returns {Promise.<void>}
     */
    value: function () {
      var _setUp = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(nameDB) {
        var db;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return dbSetUp_1.setUpDb(nameDB);

              case 2:
                db = _context.sent;

                if (db) {
                  _context.next = 5;
                  break;
                }

                throw new utils_1.IndexDBError("A problem occured during the set up of IndexDB");

              case 5:
                this.db = db;

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setUp(_x) {
        return _setUp.apply(this, arguments);
      }

      return setUp;
    }()
    /**
     * Start a download from scratch.
     * @param {Object<ISettingsDownloader>} settings
     * @returns {Promise.<void>}
     */

  }, {
    key: "download",
    value: function () {
      var _download = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(settings) {
        var activeSubsDownloader, storeManifestEvery, db, size, progressBarBuilder, progress$, pause$, contentID, subcriptionDownloader;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                activeSubsDownloader = this.activeSubsDownloader, storeManifestEvery = this.storeManifestEvery, db = this.db;

                if (db) {
                  _context2.next = 4;
                  break;
                }

                throw new Error("The database doesnt exist!");

              case 4:
                _context2.next = 6;
                return utils_1.checkForSettingsAddMovie(settings, db, activeSubsDownloader);

              case 6:
                size = 0;
                progressBarBuilder = {
                  progress: 0,
                  overall: 0,
                  downloadedID: []
                };
                progress$ = new rxjs_1.ReplaySubject(1);
                pause$ = new rxjs_1.AsyncSubject();
                contentID = settings.dbSettings.contentID;
                this.activePauseSubject[contentID] = pause$;
                subcriptionDownloader = download_1.downloader(Object.assign(Object.assign({}, settings), {
                  type: "start"
                }), {
                  activeSubsDownloader: activeSubsDownloader,
                  pause$: pause$,
                  progress$: progress$,
                  progressBarBuilder: progressBarBuilder,
                  size: size
                }, {
                  db: db,
                  emitter: this.emitter,
                  storeManifestEvery: storeManifestEvery
                });
                activeSubsDownloader[contentID] = subcriptionDownloader;
                this.trigger("progress", {
                  contentID: contentID,
                  progress: 0,
                  size: size,
                  status: "processing"
                });
                _context2.next = 20;
                break;

              case 17:
                _context2.prev = 17;
                _context2.t0 = _context2["catch"](0);
                this.trigger("error", {
                  action: "download",
                  contentID: settings.dbSettings.contentID,
                  error: _context2.t0 || new Error("A Unexpected error happened")
                });

              case 20:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[0, 17]]);
      }));

      function download(_x2) {
        return _download.apply(this, arguments);
      }

      return download;
    }()
    /**
     * Resume a download already started earlier.
     * @param {string} contentID
     * @returns {Promise.<void>}
     */

  }, {
    key: "resume",
    value: function () {
      var _resume = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(contentID) {
        var activeSubsDownloader, activePauseSubject, db, storeManifestEvery, manifest, size, progressBarBuilder, progress$, pause$, settings, subcriptionDownloader;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                activeSubsDownloader = this.activeSubsDownloader, activePauseSubject = this.activePauseSubject, db = this.db, storeManifestEvery = this.storeManifestEvery;

                if (db) {
                  _context3.next = 4;
                  break;
                }

                throw new Error("The database doesnt exist!");

              case 4:
                _context3.next = 6;
                return db.get("manifests", contentID);

              case 6:
                manifest = _context3.sent;
                utils_1.checkForResumeAPausedMovie(manifest, activeSubsDownloader);
                size = manifest.size;
                progressBarBuilder = manifest.progressBarBuilder;
                progress$ = new rxjs_1.ReplaySubject(1);
                pause$ = new rxjs_1.AsyncSubject();
                settings = {
                  contentID: contentID,
                  metaData: manifest.metaData,
                  rxpManifest: manifest.rxpManifest
                };
                activePauseSubject[contentID] = pause$;
                subcriptionDownloader = download_1.downloader(Object.assign(Object.assign({}, settings), {
                  type: "resume"
                }), {
                  activeSubsDownloader: activeSubsDownloader,
                  pause$: pause$,
                  progress$: progress$,
                  progressBarBuilder: progressBarBuilder,
                  size: size
                }, {
                  db: db,
                  emitter: this.emitter,
                  storeManifestEvery: storeManifestEvery
                });
                activeSubsDownloader[contentID] = subcriptionDownloader;
                _context3.next = 21;
                break;

              case 18:
                _context3.prev = 18;
                _context3.t0 = _context3["catch"](0);
                this.trigger("error", {
                  action: "resume",
                  contentID: contentID,
                  error: _context3.t0 || new Error("A Unexpected error happened")
                });

              case 21:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[0, 18]]);
      }));

      function resume(_x3) {
        return _resume.apply(this, arguments);
      }

      return resume;
    }()
    /**
     * Pause a download already started earlier.
     * @param {string} contentID
     * @returns {void}
     */

  }, {
    key: "pause",
    value: function pause(contentID) {
      try {
        utils_1.checkForPauseAMovie(contentID);
        var activePauseSubject = this.activePauseSubject,
            activeSubsDownloader = this.activeSubsDownloader;

        if (activeSubsDownloader[contentID] && activePauseSubject[contentID]) {
          activePauseSubject[contentID].next();
          activePauseSubject[contentID].complete();
          activeSubsDownloader[contentID].unsubscribe();
          delete activeSubsDownloader[contentID];
          activePauseSubject[contentID].unsubscribe();
          delete activePauseSubject[contentID];
        }
      } catch (e) {
        this.trigger("error", {
          action: "resume",
          contentID: contentID,
          error: e || new Error("A Unexpected error happened")
        });
      }
    }
    /**
     * Get all the downloaded entry (manifest) partially or fully downloaded.
     * @returns {Promise.<T[]|void>}
     */

  }, {
    key: "getAllDownloadedMovies",
    value: function () {
      var _getAllDownloadedMovies = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.prev = 0;

                if (this.db) {
                  _context4.next = 3;
                  break;
                }

                throw new Error("The database doesnt exist!");

              case 3:
                _context4.next = 5;
                return this.db.getAll("manifests");

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 8:
                _context4.prev = 8;
                _context4.t0 = _context4["catch"](0);
                this.trigger("error", {
                  action: "getAllDownloadedMovies",
                  error: new utils_1.IndexDBError(_context4.t0.message)
                });
                return _context4.abrupt("return", undefined);

              case 12:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[0, 8]]);
      }));

      function getAllDownloadedMovies() {
        return _getAllDownloadedMovies.apply(this, arguments);
      }

      return getAllDownloadedMovies;
    }()
    /**
     * Get a singleMovie ready to be played by the rx-player,
     * could be fully or partially downloaded.
     * @param {string} contentID
     * @returns {Promise.<T|void>}
     */

  }, {
    key: "getSingleMovie",
    value: function () {
      var _getSingleMovie = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(contentID) {
        var _ref, _ref2, movie, encryption;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.prev = 0;

                if (this.db) {
                  _context5.next = 3;
                  break;
                }

                throw new Error("The database doesnt exist!");

              case 3:
                _context5.next = 5;
                return promise_1.default.all([this.db.get("manifests", contentID), this.db.get("drm", contentID)]);

              case 5:
                _ref = _context5.sent;
                _ref2 = _slicedToArray(_ref, 2);
                movie = _ref2[0];
                encryption = _ref2[1];

                if (movie) {
                  _context5.next = 11;
                  break;
                }

                throw new Error("A content doesnt exist with the given contentID: " + contentID);

              case 11:
                return _context5.abrupt("return", Object.assign(Object.assign(Object.assign({}, movie), encryption), {
                  rxpManifest: offlineDownload_1.offlineManifestLoader(movie.rxpManifest, this.db)
                }));

              case 14:
                _context5.prev = 14;
                _context5.t0 = _context5["catch"](0);
                this.trigger("error", {
                  action: "getSingleMovie",
                  contentID: contentID,
                  error: _context5.t0 || new Error("A Unexpected error happened")
                });

              case 17:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[0, 14]]);
      }));

      function getSingleMovie(_x4) {
        return _getSingleMovie.apply(this, arguments);
      }

      return getSingleMovie;
    }()
  }, {
    key: "getAvailableSpace",
    value: function () {
      var _getAvailableSpace = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6() {
        var _ref3, quota, usage;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!(navigator.storage && navigator.storage.estimate)) {
                  _context6.next = 8;
                  break;
                }

                _context6.next = 3;
                return navigator.storage.estimate();

              case 3:
                _ref3 = _context6.sent;
                quota = _ref3.quota;
                usage = _ref3.usage;

                if (!(quota && usage)) {
                  _context6.next = 8;
                  break;
                }

                return _context6.abrupt("return", {
                  total: quota / 1e6,
                  used: usage / 1e6
                });

              case 8:
                return _context6.abrupt("return", {});

              case 9:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));

      function getAvailableSpace() {
        return _getAvailableSpace.apply(this, arguments);
      }

      return getAvailableSpace;
    }()
    /**
     * Delete an entry partially or fully downloaded and stop the download
     * if the content is downloading, then delete.
     * @param {string} contentID
     * @returns {Promise.<void>}
     */

  }, {
    key: "deleteDownloadedMovie",
    value: function () {
      var _deleteDownloadedMovie = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7(contentID) {
        var activePauseSubject, activeSubsDownloader, db, indexTx, cursor;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.prev = 0;
                activePauseSubject = this.activePauseSubject, activeSubsDownloader = this.activeSubsDownloader, db = this.db;

                if (db) {
                  _context7.next = 4;
                  break;
                }

                throw new Error("The database doesnt exist!");

              case 4:
                if (activeSubsDownloader[contentID] && activePauseSubject[contentID]) {
                  activePauseSubject[contentID].next();
                  activePauseSubject[contentID].complete();
                  activePauseSubject[contentID].unsubscribe(); // Add an additional check when pause complete.

                  if (activeSubsDownloader[contentID]) {
                    activeSubsDownloader[contentID].unsubscribe();
                    delete activeSubsDownloader[contentID];
                  }

                  delete activePauseSubject[contentID];
                }

                indexTx = db.transaction("segments", "readwrite").objectStore("segments").index("contentID");
                _context7.next = 8;
                return indexTx.openCursor(IDBKeyRange.only(contentID));

              case 8:
                cursor = _context7.sent;

              case 9:
                if (!cursor) {
                  _context7.next = 17;
                  break;
                }

                _context7.next = 12;
                return cursor.delete();

              case 12:
                _context7.next = 14;
                return cursor.continue();

              case 14:
                cursor = _context7.sent;
                _context7.next = 9;
                break;

              case 17:
                _context7.next = 19;
                return promise_1.default.all([db.delete("drm", contentID), db.delete("manifests", contentID)]);

              case 19:
                _context7.next = 24;
                break;

              case 21:
                _context7.prev = 21;
                _context7.t0 = _context7["catch"](0);
                this.trigger("error", {
                  action: "deleteDownloadedMovie",
                  contentID: contentID,
                  error: _context7.t0 || new Error("A Unexpected error happened")
                });

              case 24:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[0, 21]]);
      }));

      function deleteDownloadedMovie(_x5) {
        return _deleteDownloadedMovie.apply(this, arguments);
      }

      return deleteDownloadedMovie;
    }()
  }], [{
    key: "init",
    value: function init() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8() {
        var d2g;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                d2g = new D2G(options);
                _context8.next = 3;
                return d2g.setUp(options.nameDB || "d2g");

              case 3:
                return _context8.abrupt("return", d2g);

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }))();
    }
  }]);

  return D2G;
}(event_emitter_1.default);

window.__DEV__ = true;
window.d2g = D2G;
exports.default = D2G;
},{"core-js/modules/es6.array.copy-within":"../../../../node_modules/core-js/modules/es6.array.copy-within.js","core-js/modules/es6.array.fill":"../../../../node_modules/core-js/modules/es6.array.fill.js","core-js/modules/es6.array.find":"../../../../node_modules/core-js/modules/es6.array.find.js","core-js/modules/es6.array.find-index":"../../../../node_modules/core-js/modules/es6.array.find-index.js","core-js/modules/es6.array.from":"../../../../node_modules/core-js/modules/es6.array.from.js","core-js/modules/es7.array.includes":"../../../../node_modules/core-js/modules/es7.array.includes.js","core-js/modules/es6.array.iterator":"../../../../node_modules/core-js/modules/es6.array.iterator.js","core-js/modules/es6.array.of":"../../../../node_modules/core-js/modules/es6.array.of.js","core-js/modules/es6.array.sort":"../../../../node_modules/core-js/modules/es6.array.sort.js","core-js/modules/es6.array.species":"../../../../node_modules/core-js/modules/es6.array.species.js","core-js/modules/es6.date.to-json":"../../../../node_modules/core-js/modules/es6.date.to-json.js","core-js/modules/es6.date.to-primitive":"../../../../node_modules/core-js/modules/es6.date.to-primitive.js","core-js/modules/es6.function.has-instance":"../../../../node_modules/core-js/modules/es6.function.has-instance.js","core-js/modules/es6.function.name":"../../../../node_modules/core-js/modules/es6.function.name.js","core-js/modules/es6.map":"../../../../node_modules/core-js/modules/es6.map.js","core-js/modules/es6.math.acosh":"../../../../node_modules/core-js/modules/es6.math.acosh.js","core-js/modules/es6.math.asinh":"../../../../node_modules/core-js/modules/es6.math.asinh.js","core-js/modules/es6.math.atanh":"../../../../node_modules/core-js/modules/es6.math.atanh.js","core-js/modules/es6.math.cbrt":"../../../../node_modules/core-js/modules/es6.math.cbrt.js","core-js/modules/es6.math.clz32":"../../../../node_modules/core-js/modules/es6.math.clz32.js","core-js/modules/es6.math.cosh":"../../../../node_modules/core-js/modules/es6.math.cosh.js","core-js/modules/es6.math.expm1":"../../../../node_modules/core-js/modules/es6.math.expm1.js","core-js/modules/es6.math.fround":"../../../../node_modules/core-js/modules/es6.math.fround.js","core-js/modules/es6.math.hypot":"../../../../node_modules/core-js/modules/es6.math.hypot.js","core-js/modules/es6.math.imul":"../../../../node_modules/core-js/modules/es6.math.imul.js","core-js/modules/es6.math.log1p":"../../../../node_modules/core-js/modules/es6.math.log1p.js","core-js/modules/es6.math.log10":"../../../../node_modules/core-js/modules/es6.math.log10.js","core-js/modules/es6.math.log2":"../../../../node_modules/core-js/modules/es6.math.log2.js","core-js/modules/es6.math.sign":"../../../../node_modules/core-js/modules/es6.math.sign.js","core-js/modules/es6.math.sinh":"../../../../node_modules/core-js/modules/es6.math.sinh.js","core-js/modules/es6.math.tanh":"../../../../node_modules/core-js/modules/es6.math.tanh.js","core-js/modules/es6.math.trunc":"../../../../node_modules/core-js/modules/es6.math.trunc.js","core-js/modules/es6.number.constructor":"../../../../node_modules/core-js/modules/es6.number.constructor.js","core-js/modules/es6.number.epsilon":"../../../../node_modules/core-js/modules/es6.number.epsilon.js","core-js/modules/es6.number.is-finite":"../../../../node_modules/core-js/modules/es6.number.is-finite.js","core-js/modules/es6.number.is-integer":"../../../../node_modules/core-js/modules/es6.number.is-integer.js","core-js/modules/es6.number.is-nan":"../../../../node_modules/core-js/modules/es6.number.is-nan.js","core-js/modules/es6.number.is-safe-integer":"../../../../node_modules/core-js/modules/es6.number.is-safe-integer.js","core-js/modules/es6.number.max-safe-integer":"../../../../node_modules/core-js/modules/es6.number.max-safe-integer.js","core-js/modules/es6.number.min-safe-integer":"../../../../node_modules/core-js/modules/es6.number.min-safe-integer.js","core-js/modules/es6.number.parse-float":"../../../../node_modules/core-js/modules/es6.number.parse-float.js","core-js/modules/es6.number.parse-int":"../../../../node_modules/core-js/modules/es6.number.parse-int.js","core-js/modules/es6.object.assign":"../../../../node_modules/core-js/modules/es6.object.assign.js","core-js/modules/es7.object.define-getter":"../../../../node_modules/core-js/modules/es7.object.define-getter.js","core-js/modules/es7.object.define-setter":"../../../../node_modules/core-js/modules/es7.object.define-setter.js","core-js/modules/es7.object.entries":"../../../../node_modules/core-js/modules/es7.object.entries.js","core-js/modules/es6.object.freeze":"../../../../node_modules/core-js/modules/es6.object.freeze.js","core-js/modules/es6.object.get-own-property-descriptor":"../../../../node_modules/core-js/modules/es6.object.get-own-property-descriptor.js","core-js/modules/es7.object.get-own-property-descriptors":"../../../../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js","core-js/modules/es6.object.get-own-property-names":"../../../../node_modules/core-js/modules/es6.object.get-own-property-names.js","core-js/modules/es6.object.get-prototype-of":"../../../../node_modules/core-js/modules/es6.object.get-prototype-of.js","core-js/modules/es7.object.lookup-getter":"../../../../node_modules/core-js/modules/es7.object.lookup-getter.js","core-js/modules/es7.object.lookup-setter":"../../../../node_modules/core-js/modules/es7.object.lookup-setter.js","core-js/modules/es6.object.prevent-extensions":"../../../../node_modules/core-js/modules/es6.object.prevent-extensions.js","core-js/modules/es6.object.is":"../../../../node_modules/core-js/modules/es6.object.is.js","core-js/modules/es6.object.is-frozen":"../../../../node_modules/core-js/modules/es6.object.is-frozen.js","core-js/modules/es6.object.is-sealed":"../../../../node_modules/core-js/modules/es6.object.is-sealed.js","core-js/modules/es6.object.is-extensible":"../../../../node_modules/core-js/modules/es6.object.is-extensible.js","core-js/modules/es6.object.keys":"../../../../node_modules/core-js/modules/es6.object.keys.js","core-js/modules/es6.object.seal":"../../../../node_modules/core-js/modules/es6.object.seal.js","core-js/modules/es6.object.set-prototype-of":"../../../../node_modules/core-js/modules/es6.object.set-prototype-of.js","core-js/modules/es7.object.values":"../../../../node_modules/core-js/modules/es7.object.values.js","core-js/modules/es6.promise":"../../../../node_modules/core-js/modules/es6.promise.js","core-js/modules/es7.promise.finally":"../../../../node_modules/core-js/modules/es7.promise.finally.js","core-js/modules/es6.reflect.apply":"../../../../node_modules/core-js/modules/es6.reflect.apply.js","core-js/modules/es6.reflect.construct":"../../../../node_modules/core-js/modules/es6.reflect.construct.js","core-js/modules/es6.reflect.define-property":"../../../../node_modules/core-js/modules/es6.reflect.define-property.js","core-js/modules/es6.reflect.delete-property":"../../../../node_modules/core-js/modules/es6.reflect.delete-property.js","core-js/modules/es6.reflect.get":"../../../../node_modules/core-js/modules/es6.reflect.get.js","core-js/modules/es6.reflect.get-own-property-descriptor":"../../../../node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js","core-js/modules/es6.reflect.get-prototype-of":"../../../../node_modules/core-js/modules/es6.reflect.get-prototype-of.js","core-js/modules/es6.reflect.has":"../../../../node_modules/core-js/modules/es6.reflect.has.js","core-js/modules/es6.reflect.is-extensible":"../../../../node_modules/core-js/modules/es6.reflect.is-extensible.js","core-js/modules/es6.reflect.own-keys":"../../../../node_modules/core-js/modules/es6.reflect.own-keys.js","core-js/modules/es6.reflect.prevent-extensions":"../../../../node_modules/core-js/modules/es6.reflect.prevent-extensions.js","core-js/modules/es6.reflect.set":"../../../../node_modules/core-js/modules/es6.reflect.set.js","core-js/modules/es6.reflect.set-prototype-of":"../../../../node_modules/core-js/modules/es6.reflect.set-prototype-of.js","core-js/modules/es6.regexp.constructor":"../../../../node_modules/core-js/modules/es6.regexp.constructor.js","core-js/modules/es6.regexp.flags":"../../../../node_modules/core-js/modules/es6.regexp.flags.js","core-js/modules/es6.regexp.match":"../../../../node_modules/core-js/modules/es6.regexp.match.js","core-js/modules/es6.regexp.replace":"../../../../node_modules/core-js/modules/es6.regexp.replace.js","core-js/modules/es6.regexp.split":"../../../../node_modules/core-js/modules/es6.regexp.split.js","core-js/modules/es6.regexp.search":"../../../../node_modules/core-js/modules/es6.regexp.search.js","core-js/modules/es6.regexp.to-string":"../../../../node_modules/core-js/modules/es6.regexp.to-string.js","core-js/modules/es6.set":"../../../../node_modules/core-js/modules/es6.set.js","core-js/modules/es6.symbol":"../../../../node_modules/core-js/modules/es6.symbol.js","core-js/modules/es7.symbol.async-iterator":"../../../../node_modules/core-js/modules/es7.symbol.async-iterator.js","core-js/modules/es6.string.anchor":"../../../../node_modules/core-js/modules/es6.string.anchor.js","core-js/modules/es6.string.big":"../../../../node_modules/core-js/modules/es6.string.big.js","core-js/modules/es6.string.blink":"../../../../node_modules/core-js/modules/es6.string.blink.js","core-js/modules/es6.string.bold":"../../../../node_modules/core-js/modules/es6.string.bold.js","core-js/modules/es6.string.code-point-at":"../../../../node_modules/core-js/modules/es6.string.code-point-at.js","core-js/modules/es6.string.ends-with":"../../../../node_modules/core-js/modules/es6.string.ends-with.js","core-js/modules/es6.string.fixed":"../../../../node_modules/core-js/modules/es6.string.fixed.js","core-js/modules/es6.string.fontcolor":"../../../../node_modules/core-js/modules/es6.string.fontcolor.js","core-js/modules/es6.string.fontsize":"../../../../node_modules/core-js/modules/es6.string.fontsize.js","core-js/modules/es6.string.from-code-point":"../../../../node_modules/core-js/modules/es6.string.from-code-point.js","core-js/modules/es6.string.includes":"../../../../node_modules/core-js/modules/es6.string.includes.js","core-js/modules/es6.string.italics":"../../../../node_modules/core-js/modules/es6.string.italics.js","core-js/modules/es6.string.iterator":"../../../../node_modules/core-js/modules/es6.string.iterator.js","core-js/modules/es6.string.link":"../../../../node_modules/core-js/modules/es6.string.link.js","core-js/modules/es7.string.pad-start":"../../../../node_modules/core-js/modules/es7.string.pad-start.js","core-js/modules/es7.string.pad-end":"../../../../node_modules/core-js/modules/es7.string.pad-end.js","core-js/modules/es6.string.raw":"../../../../node_modules/core-js/modules/es6.string.raw.js","core-js/modules/es6.string.repeat":"../../../../node_modules/core-js/modules/es6.string.repeat.js","core-js/modules/es6.string.small":"../../../../node_modules/core-js/modules/es6.string.small.js","core-js/modules/es6.string.starts-with":"../../../../node_modules/core-js/modules/es6.string.starts-with.js","core-js/modules/es6.string.strike":"../../../../node_modules/core-js/modules/es6.string.strike.js","core-js/modules/es6.string.sub":"../../../../node_modules/core-js/modules/es6.string.sub.js","core-js/modules/es6.string.sup":"../../../../node_modules/core-js/modules/es6.string.sup.js","core-js/modules/es6.typed.array-buffer":"../../../../node_modules/core-js/modules/es6.typed.array-buffer.js","core-js/modules/es6.typed.int8-array":"../../../../node_modules/core-js/modules/es6.typed.int8-array.js","core-js/modules/es6.typed.uint8-array":"../../../../node_modules/core-js/modules/es6.typed.uint8-array.js","core-js/modules/es6.typed.uint8-clamped-array":"../../../../node_modules/core-js/modules/es6.typed.uint8-clamped-array.js","core-js/modules/es6.typed.int16-array":"../../../../node_modules/core-js/modules/es6.typed.int16-array.js","core-js/modules/es6.typed.uint16-array":"../../../../node_modules/core-js/modules/es6.typed.uint16-array.js","core-js/modules/es6.typed.int32-array":"../../../../node_modules/core-js/modules/es6.typed.int32-array.js","core-js/modules/es6.typed.uint32-array":"../../../../node_modules/core-js/modules/es6.typed.uint32-array.js","core-js/modules/es6.typed.float32-array":"../../../../node_modules/core-js/modules/es6.typed.float32-array.js","core-js/modules/es6.typed.float64-array":"../../../../node_modules/core-js/modules/es6.typed.float64-array.js","core-js/modules/es6.weak-map":"../../../../node_modules/core-js/modules/es6.weak-map.js","core-js/modules/es6.weak-set":"../../../../node_modules/core-js/modules/es6.weak-set.js","core-js/modules/es7.array.flat-map":"../../../../node_modules/core-js/modules/es7.array.flat-map.js","core-js/modules/web.timers":"../../../../node_modules/core-js/modules/web.timers.js","core-js/modules/web.immediate":"../../../../node_modules/core-js/modules/web.immediate.js","core-js/modules/web.dom.iterable":"../../../../node_modules/core-js/modules/web.dom.iterable.js","regenerator-runtime/runtime":"../../../../node_modules/regenerator-runtime/runtime.js","rxjs":"../../../../node_modules/rxjs/_esm5/index.js","./apis/publicApi/download":"apis/publicApi/download.ts","./apis/publicApi/offlineDownload":"apis/publicApi/offlineDownload.ts","./apis/transactionDB/dbSetUp":"apis/transactionDB/dbSetUp.ts","./utils":"utils.ts","../../../utils/event_emitter":"../../../utils/event_emitter.ts","../../../utils/promise":"../../../utils/promise.ts"}],"../../../../../../../.config/yarn/global/node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "36677" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else {
        window.location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] â¨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] ð¨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">ð¨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["../../../../../../../.config/yarn/global/node_modules/parcel-bundler/src/builtins/hmr-runtime.js","index.ts"], null)
//# sourceMappingURL=/download2go.77de5100.js.map