{"version":3,"sources":["../../src/rules/checkLineAlignment.js"],"names":["matchAll","string","regexp","callback","limit","result","index","exec","getFullDescription","lineString","getExpectedPositions","partsMaxLength","indentLevel","reduce","acc","cur","isNotAligned","expectedPositions","partsMatrix","some","line","position","partIndex","createFixer","comment","lineRegExp","tagIndentation","fixer","lineIndex","fixed","value","replace","spacings","repeat","length","replaceText","checkAlignedPerTag","tag","report","RegExp","lines","match","forEach","partLength","maxLength","spacers","checkNotAlignedPerTag","utils","ok","every","prop","checkProps","hasCheckProp","checkProp","source","tokens","test","fix","setTag","reportJSDoc","jsdocNode","context","indent","options","includes","paramTags","getPresentTags","iterateAllJsdocs","meta","docs","description","url","fixable","schema","enum","type"],"mappings":"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","sourcesContent":["import {\n  set,\n} from 'lodash';\nimport iterateJsdoc from '../iterateJsdoc';\n\n/**\n * Aux method until we consider the dev envs support `String.prototype.matchAll` (Node 12+).\n *\n * @param {string}   string   String that will be checked.\n * @param {RegExp}   regexp   Regular expression to run.\n * @param {Function} callback Function to be called each iteration.\n * @param {int}      limit    Limit of matches that we want to exec.\n *\n * @todo [engine:node@>=12]: Remove function and use `String.prototype.matchAll` instead.\n */\nconst matchAll = (string, regexp, callback, limit) => {\n  let result;\n  let index = 0;\n\n  while ((result = regexp.exec(string)) && index <= limit - 1) {\n    // eslint-disable-next-line promise/prefer-await-to-callbacks\n    callback(result, index++);\n  }\n};\n\n/**\n * Get the full description from a line.\n *\n * @param {string} lineString The line string.\n *\n * @returns {string} The full description.\n */\nconst getFullDescription = (lineString) => {\n  return /\\S+\\s+(?:{{.*?}}|{.*?})\\s+\\S+\\s+(.*)/.exec(lineString)[1];\n};\n\n/**\n * Get the expected positions for each part.\n *\n * @param {int[]} partsMaxLength Max length of each part.\n * @param {int}   indentLevel    JSDoc indent level.\n *\n * @returns {int[]} Expected position for each part.\n */\nconst getExpectedPositions = (partsMaxLength, indentLevel) => {\n  // eslint-disable-next-line unicorn/no-reduce\n  return partsMaxLength.reduce(\n    (acc, cur, index) => {\n      return [...acc, cur + acc[index] + 1];\n    },\n    [indentLevel],\n  );\n};\n\n/**\n * Check is not aligned.\n *\n * @param {int[]}   expectedPositions Expected position for each part.\n * @param {Array[]} partsMatrix       Parts matrix.\n *\n * @returns {boolean}\n */\nconst isNotAligned = (expectedPositions, partsMatrix) => {\n  return partsMatrix.some((line) => {\n    return line.some(\n      ({position}, partIndex) => {\n        return position !== expectedPositions[partIndex];\n      },\n    );\n  });\n};\n\n/**\n * Fix function creator for the report. It creates a function which fix\n * the JSDoc with the correct alignment.\n *\n * @param {object}  comment           Comment node.\n * @param {int[]}   expectedPositions Array with the expected positions.\n * @param {Array[]} partsMatrix       Parts matrix.\n * @param {RegExp}  lineRegExp        Line regular expression.\n * @param {string}  tagIndentation    Tag indentation.\n *\n * @returns {Function} Function which fixes the JSDoc alignment.\n */\nconst createFixer = (comment, expectedPositions, partsMatrix, lineRegExp, tagIndentation) => {\n  return (fixer) => {\n    let lineIndex = 0;\n\n    // Replace every line with the correct spacings.\n    const fixed = comment.value.replace(lineRegExp, () => {\n      // eslint-disable-next-line unicorn/no-reduce\n      return partsMatrix[lineIndex++].reduce(\n        (acc, {string}, index) => {\n          const spacings = ' '.repeat(expectedPositions[index] - acc.length);\n\n          return acc + (index === 0 ? tagIndentation : spacings) + string;\n        },\n        '',\n      );\n    });\n\n    return fixer.replaceText(comment, '/*' + fixed + '*/');\n  };\n};\n\n/**\n * Check comment per tag.\n *\n * @param {object}   comment        Comment node.\n * @param {string}   tag            Tag string.\n * @param {string}   tagIndentation Tag indentation.\n * @param {Function} report         Report function.\n */\nconst checkAlignedPerTag = (comment, tag, tagIndentation, report) => {\n  const lineRegExp = new RegExp(`.*@${tag}[\\\\s].*`, 'gm');\n  const lines = comment.value.match(lineRegExp);\n\n  if (!lines) {\n    return;\n  }\n\n  /**\n   * A matrix containing the current position and the string of each part for each line.\n   * 0 - Asterisk.\n   * 1 - Tag.\n   * 2 - Type.\n   * 3 - Variable name.\n   * 4 - Description (Optional).\n   */\n  const partsMatrix = [];\n\n  /**\n   * The max length of each part, comparing all the lines.\n   */\n  const partsMaxLength = [];\n\n  // Loop (lines x parts) to populate partsMatrix and partsMaxLength.\n  lines.forEach((lineString, lineIndex) => {\n    // All line parts until the first word of the description (if description exists).\n    matchAll(\n      lineString,\n      /{{.*?}}|{.*?}|\\S+/g,\n      ({0: match, index: position}, partIndex) => {\n        set(partsMatrix, [lineIndex, partIndex], {\n          position,\n          string: partIndex === 4 ? getFullDescription(lineString) : match,\n        });\n\n        const partLength = match.length;\n        const maxLength = partsMaxLength[partIndex];\n\n        partsMaxLength[partIndex] = maxLength > partLength ? maxLength : partLength;\n      },\n      5,\n    );\n  });\n\n  const expectedPositions = getExpectedPositions(partsMaxLength, tagIndentation.length);\n\n  if (isNotAligned(expectedPositions, partsMatrix)) {\n    report(\n      'Expected JSDoc block lines to be aligned.',\n      createFixer(\n        comment,\n        expectedPositions,\n        partsMatrix,\n        lineRegExp,\n        tagIndentation,\n      ),\n    );\n  }\n};\n\nconst spacers = [\n  ['postDelimiter', ['tag']],\n  ['postTag', ['type', 'name', 'description']],\n  ['postType', ['name', 'description']],\n  ['postName', ['description']],\n];\n\nconst checkNotAlignedPerTag = (utils, tag) => {\n  // If checking alignment on multiple lines, need to check other `source` items\n  const ok = spacers.every(([prop, checkProps]) => {\n    const hasCheckProp = checkProps.some((checkProp) => {\n      return tag.source[0].tokens[checkProp];\n    });\n\n    return !hasCheckProp || (/^[\\t ]$/).test(tag.source[0].tokens[prop]);\n  });\n  if (ok) {\n    return;\n  }\n  const fix = () => {\n    const tokens = tag.source[0].tokens;\n    spacers.forEach(([prop, checkProps]) => {\n      const hasCheckProp = checkProps.some((checkProp) => {\n        return tag.source[0].tokens[checkProp];\n      });\n      tokens[prop] = hasCheckProp ? ' ' : '';\n    });\n\n    utils.setTag(tag, tokens);\n  };\n  utils.reportJSDoc('Expected JSDoc block lines to not be aligned.', tag, fix, true);\n};\n\nexport default iterateJsdoc(({\n  jsdocNode,\n  report,\n  context,\n  indent,\n  utils,\n}) => {\n  if (context.options[0] === 'always') {\n    // Skip if it contains only a single line.\n    if (!jsdocNode.value.includes('\\n')) {\n      return;\n    }\n\n    // `indent` is whitespace from line 1 (`/**`), so slice and account for \"/\".\n    const tagIndentation = indent + ' ';\n\n    ['param', 'arg', 'argument', 'property', 'prop'].forEach((tag) => {\n      checkAlignedPerTag(jsdocNode, tag, tagIndentation, report);\n    });\n\n    return;\n  }\n\n  const paramTags = utils.getPresentTags(['param', 'arg', 'argument', 'property', 'prop']);\n  paramTags.forEach((tag) => {\n    checkNotAlignedPerTag(utils, tag, report);\n  });\n}, {\n  iterateAllJsdocs: true,\n  meta: {\n    docs: {\n      description: 'Reports invalid alignment of JSDoc block lines.',\n      url: 'https://github.com/gajus/eslint-plugin-jsdoc#eslint-plugin-jsdoc-rules-check-line-alignment',\n    },\n    fixable: 'whitespace',\n    schema: [\n      {\n        enum: ['always', 'never'],\n        type: 'string',\n      },\n    ],\n    type: 'layout',\n  },\n});\n"],"file":"checkLineAlignment.js"}