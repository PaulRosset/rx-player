let observableOf,observableRace,observableTimer,catchError,map,mergeMap,castToObservable;_ac9‍.x([["default",()=>closeSession$]]);_ac9‍.w("rxjs",[["of",["observableOf"],function(v){observableOf=v}],["race",["observableRace"],function(v){observableRace=v}],["timer",["observableTimer"],function(v){observableTimer=v}]]);_ac9‍.w("rxjs/operators",[["catchError",["catchError"],function(v){catchError=v}],["map",["map"],function(v){map=v}],["mergeMap",["mergeMap"],function(v){mergeMap=v}]]);_ac9‍.w("../../utils/cast_to_observable",[["default",["castToObservable"],function(v){castToObservable=v}]]);/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Close session and returns and observable that emits when
 * the session is closed.
 * @param {MediaKeySession|Object} session
 * @returns {Observable}
 */
               function closeSession$(session) {
    return observableRace(castToObservable(session.close()), 
    // If the session is not closed after 1000ms, try
    // to call another method on session to guess if
    // session is closed or not.
    observableTimer(1000).pipe(mergeMap(function () {
        var tryToUpdateSession$ = castToObservable(session.update(new Uint8Array(1)));
        return tryToUpdateSession$.pipe(
        // Update has resolved, so we can't know if session is closed
        map(function () {
            throw new Error("Compat: Couldn't know if session is " +
                "closed");
        }), catchError(function (err) {
            // The caught error can tell if session is closed
            // (Chrome may throw this error)
            if (err instanceof Error &&
                err.message === "The session is already closed.") {
                return observableOf(null);
            }
            // The `closed` promise may resolve, even if `close()` result has not
            // (it may happen on Firefox). Wait for it and timeout after 1 second.
            var sessionIsClosed$ = castToObservable(session.closed);
            return observableRace(sessionIsClosed$, observableTimer(1000).pipe(map(function () {
                throw new Error("Compat: Couldn't know if session is " +
                    "closed");
            })));
        }));
    })));
}
