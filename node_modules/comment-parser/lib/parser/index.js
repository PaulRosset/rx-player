"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var source_parser_1 = require("./source-parser");
var block_parser_1 = require("./block-parser");
var spec_parser_1 = require("./spec-parser");
var spacer_1 = require("./spacer");
var util_1 = require("../util");
function getParser(_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.startLine, startLine = _c === void 0 ? 0 : _c, _d = _b.fence, fence = _d === void 0 ? '```' : _d, _e = _b.spacing, spacing = _e === void 0 ? 'compact' : _e, _f = _b.tokenizers, tokenizers = _f === void 0 ? [
        spec_parser_1.tagTokenizer(),
        spec_parser_1.typeTokenizer(),
        spec_parser_1.nameTokenizer(),
        spec_parser_1.descriptionTokenizer(spacer_1.default(spacing)),
    ] : _f;
    if (startLine < 0 || startLine % 1 > 0)
        throw new Error('Invalid startLine');
    var parseSource = source_parser_1.default({ startLine: startLine });
    var parseBlock = block_parser_1.default({ fence: fence });
    var parseSpec = spec_parser_1.default({ tokenizers: tokenizers });
    var join = spacer_1.default(spacing);
    var notEmpty = function (line) {
        return line.tokens.description.trim() != '';
    };
    return function (source) {
        var blocks = [];
        for (var _i = 0, _a = util_1.splitLines(source); _i < _a.length; _i++) {
            var line = _a[_i];
            var lines = parseSource(line);
            if (lines === null)
                continue;
            if (lines.find(notEmpty) === undefined)
                continue;
            var sections = parseBlock(lines);
            var specs = sections.slice(1).map(parseSpec);
            blocks.push({
                description: join(sections[0]),
                tags: specs,
                source: lines,
                problems: specs.reduce(function (acc, spec) { return acc.concat(spec.problems); }, []),
            });
        }
        return blocks;
    };
}
exports.default = getParser;
