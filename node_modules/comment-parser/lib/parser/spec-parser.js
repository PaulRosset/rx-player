"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.descriptionTokenizer = exports.nameTokenizer = exports.typeTokenizer = exports.tagTokenizer = void 0;
var util_1 = require("../util");
function getParser(_a) {
    var tokenizers = _a.tokenizers;
    return function parseSpec(source) {
        var _a;
        var spec = util_1.seedSpec({ source: source });
        for (var _i = 0, tokenizers_1 = tokenizers; _i < tokenizers_1.length; _i++) {
            var tokenize = tokenizers_1[_i];
            spec = tokenize(spec);
            if ((_a = spec.problems[spec.problems.length - 1]) === null || _a === void 0 ? void 0 : _a.critical)
                break;
        }
        return spec;
    };
}
exports.default = getParser;
function tagTokenizer() {
    return function (spec) {
        var tokens = spec.source[0].tokens;
        var match = tokens.description.match(/\s*(@(\S+))(\s*)/);
        if (match === null) {
            spec.problems.push({
                code: 'spec:tag:prefix',
                message: 'tag should start with "@" symbol',
                line: spec.source[0].number,
                critical: true,
            });
            return spec;
        }
        tokens.tag = match[1];
        tokens.postTag = match[3];
        tokens.description = tokens.description.slice(match[0].length);
        spec.tag = match[2];
        return spec;
    };
}
exports.tagTokenizer = tagTokenizer;
function typeTokenizer() {
    return function (spec) {
        var _a;
        var res = '';
        var curlies = 0;
        var tokens = spec.source[0].tokens;
        var source = tokens.description.trimLeft();
        if (source[0] !== '{')
            return spec;
        for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {
            var ch = source_1[_i];
            if (ch === '{')
                curlies++;
            if (ch === '}')
                curlies--;
            res += ch;
            if (curlies === 0) {
                break;
            }
        }
        if (curlies !== 0) {
            spec.problems.push({
                code: 'spec:type:unpaired-curlies',
                message: 'unpaired curlies',
                line: spec.source[0].number,
                critical: true,
            });
            return spec;
        }
        spec.type = res.slice(1, -1);
        tokens.type = res;
        _a = util_1.splitSpace(source.slice(tokens.type.length)), tokens.postType = _a[0], tokens.description = _a[1];
        return spec;
    };
}
exports.typeTokenizer = typeTokenizer;
function nameTokenizer() {
    return function (spec) {
        var _a, _b;
        var _c;
        var tokens = spec.source[0].tokens;
        var source = tokens.description.trimLeft();
        var quotedGroups = source.split('"');
        // if it starts with quoted group, assume it is a literal
        if (quotedGroups.length > 1 &&
            quotedGroups[0] === '' &&
            quotedGroups.length % 2 === 1) {
            spec.name = quotedGroups[1];
            tokens.name = "\"" + quotedGroups[1] + "\"";
            _a = util_1.splitSpace(source.slice(tokens.name.length)), tokens.postName = _a[0], tokens.description = _a[1];
            return spec;
        }
        var brackets = 0;
        var name = '';
        var optional = false;
        var defaultValue;
        // assume name is non-space string or anything wrapped into brackets
        for (var _i = 0, source_2 = source; _i < source_2.length; _i++) {
            var ch = source_2[_i];
            if (brackets === 0 && util_1.isSpace(ch))
                break;
            if (ch === '[')
                brackets++;
            if (ch === ']')
                brackets--;
            name += ch;
        }
        if (brackets !== 0) {
            spec.problems.push({
                code: 'spec:name:unpaired-brackets',
                message: 'unpaired brackets',
                line: spec.source[0].number,
                critical: true,
            });
            return spec;
        }
        var nameToken = name;
        if (name[0] === '[' && name[name.length - 1] === ']') {
            optional = true;
            name = name.slice(1, -1);
            var parts = name.split('=');
            name = parts[0].trim();
            defaultValue = (_c = parts[1]) === null || _c === void 0 ? void 0 : _c.trim();
            if (name === '') {
                spec.problems.push({
                    code: 'spec:name:empty-name',
                    message: 'empty name',
                    line: spec.source[0].number,
                    critical: true,
                });
                return spec;
            }
            if (parts.length > 2) {
                spec.problems.push({
                    code: 'spec:name:invalid-default',
                    message: 'invalid default value syntax',
                    line: spec.source[0].number,
                    critical: true,
                });
                return spec;
            }
            if (defaultValue === '') {
                spec.problems.push({
                    code: 'spec:name:empty-default',
                    message: 'empty default value',
                    line: spec.source[0].number,
                    critical: true,
                });
                return spec;
            }
        }
        spec.optional = optional;
        spec.name = name;
        tokens.name = nameToken;
        if (defaultValue !== undefined)
            spec.default = defaultValue;
        _b = util_1.splitSpace(source.slice(tokens.name.length)), tokens.postName = _b[0], tokens.description = _b[1];
        return spec;
    };
}
exports.nameTokenizer = nameTokenizer;
function descriptionTokenizer(join) {
    return function (spec) {
        spec.description = join(spec.source);
        return spec;
    };
}
exports.descriptionTokenizer = descriptionTokenizer;
